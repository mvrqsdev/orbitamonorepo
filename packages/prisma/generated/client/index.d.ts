
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model UserPermission
 * 
 */
export type UserPermission = $Result.DefaultSelection<Prisma.$UserPermissionPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model ScheduleParticipant
 * 
 */
export type ScheduleParticipant = $Result.DefaultSelection<Prisma.$ScheduleParticipantPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model LeadMetadata
 * 
 */
export type LeadMetadata = $Result.DefaultSelection<Prisma.$LeadMetadataPayload>
/**
 * Model LeadLostReason
 * 
 */
export type LeadLostReason = $Result.DefaultSelection<Prisma.$LeadLostReasonPayload>
/**
 * Model LeadComment
 * 
 */
export type LeadComment = $Result.DefaultSelection<Prisma.$LeadCommentPayload>
/**
 * Model LeadChat
 * 
 */
export type LeadChat = $Result.DefaultSelection<Prisma.$LeadChatPayload>
/**
 * Model LeadDocument
 * 
 */
export type LeadDocument = $Result.DefaultSelection<Prisma.$LeadDocumentPayload>
/**
 * Model Lane
 * 
 */
export type Lane = $Result.DefaultSelection<Prisma.$LanePayload>
/**
 * Model ConstructionCompany
 * 
 */
export type ConstructionCompany = $Result.DefaultSelection<Prisma.$ConstructionCompanyPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model LeadCampaign
 * 
 */
export type LeadCampaign = $Result.DefaultSelection<Prisma.$LeadCampaignPayload>
/**
 * Model CampaignSource
 * 
 */
export type CampaignSource = $Result.DefaultSelection<Prisma.$CampaignSourcePayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model LeadTag
 * 
 */
export type LeadTag = $Result.DefaultSelection<Prisma.$LeadTagPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserStatus: {
  Invited: 'Invited',
  Active: 'Active',
  Inactive: 'Inactive'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const LeadStatus: {
  Pending: 'Pending',
  Progress: 'Progress',
  Lost: 'Lost',
  Won: 'Won'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const ScheduleStatus: {
  Scheduled: 'Scheduled',
  Completed: 'Completed',
  Canceled: 'Canceled'
};

export type ScheduleStatus = (typeof ScheduleStatus)[keyof typeof ScheduleStatus]

}

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type ScheduleStatus = $Enums.ScheduleStatus

export const ScheduleStatus: typeof $Enums.ScheduleStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPermission`: Exposes CRUD operations for the **UserPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPermissions
    * const userPermissions = await prisma.userPermission.findMany()
    * ```
    */
  get userPermission(): Prisma.UserPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduleParticipant`: Exposes CRUD operations for the **ScheduleParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleParticipants
    * const scheduleParticipants = await prisma.scheduleParticipant.findMany()
    * ```
    */
  get scheduleParticipant(): Prisma.ScheduleParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadMetadata`: Exposes CRUD operations for the **LeadMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadMetadata
    * const leadMetadata = await prisma.leadMetadata.findMany()
    * ```
    */
  get leadMetadata(): Prisma.LeadMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadLostReason`: Exposes CRUD operations for the **LeadLostReason** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadLostReasons
    * const leadLostReasons = await prisma.leadLostReason.findMany()
    * ```
    */
  get leadLostReason(): Prisma.LeadLostReasonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadComment`: Exposes CRUD operations for the **LeadComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadComments
    * const leadComments = await prisma.leadComment.findMany()
    * ```
    */
  get leadComment(): Prisma.LeadCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadChat`: Exposes CRUD operations for the **LeadChat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadChats
    * const leadChats = await prisma.leadChat.findMany()
    * ```
    */
  get leadChat(): Prisma.LeadChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadDocument`: Exposes CRUD operations for the **LeadDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadDocuments
    * const leadDocuments = await prisma.leadDocument.findMany()
    * ```
    */
  get leadDocument(): Prisma.LeadDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lane`: Exposes CRUD operations for the **Lane** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lanes
    * const lanes = await prisma.lane.findMany()
    * ```
    */
  get lane(): Prisma.LaneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.constructionCompany`: Exposes CRUD operations for the **ConstructionCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConstructionCompanies
    * const constructionCompanies = await prisma.constructionCompany.findMany()
    * ```
    */
  get constructionCompany(): Prisma.ConstructionCompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadCampaign`: Exposes CRUD operations for the **LeadCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadCampaigns
    * const leadCampaigns = await prisma.leadCampaign.findMany()
    * ```
    */
  get leadCampaign(): Prisma.LeadCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignSource`: Exposes CRUD operations for the **CampaignSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignSources
    * const campaignSources = await prisma.campaignSource.findMany()
    * ```
    */
  get campaignSource(): Prisma.CampaignSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leadTag`: Exposes CRUD operations for the **LeadTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadTags
    * const leadTags = await prisma.leadTag.findMany()
    * ```
    */
  get leadTag(): Prisma.LeadTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Permission: 'Permission',
    UserPermission: 'UserPermission',
    Customer: 'Customer',
    Schedule: 'Schedule',
    ScheduleParticipant: 'ScheduleParticipant',
    Lead: 'Lead',
    LeadMetadata: 'LeadMetadata',
    LeadLostReason: 'LeadLostReason',
    LeadComment: 'LeadComment',
    LeadChat: 'LeadChat',
    LeadDocument: 'LeadDocument',
    Lane: 'Lane',
    ConstructionCompany: 'ConstructionCompany',
    Project: 'Project',
    Campaign: 'Campaign',
    LeadCampaign: 'LeadCampaign',
    CampaignSource: 'CampaignSource',
    Tag: 'Tag',
    LeadTag: 'LeadTag',
    Contact: 'Contact'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "permission" | "userPermission" | "customer" | "schedule" | "scheduleParticipant" | "lead" | "leadMetadata" | "leadLostReason" | "leadComment" | "leadChat" | "leadDocument" | "lane" | "constructionCompany" | "project" | "campaign" | "leadCampaign" | "campaignSource" | "tag" | "leadTag" | "contact"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      UserPermission: {
        payload: Prisma.$UserPermissionPayload<ExtArgs>
        fields: Prisma.UserPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          findFirst: {
            args: Prisma.UserPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          findMany: {
            args: Prisma.UserPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>[]
          }
          create: {
            args: Prisma.UserPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          createMany: {
            args: Prisma.UserPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>[]
          }
          delete: {
            args: Prisma.UserPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          update: {
            args: Prisma.UserPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          deleteMany: {
            args: Prisma.UserPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>[]
          }
          upsert: {
            args: Prisma.UserPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPermissionPayload>
          }
          aggregate: {
            args: Prisma.UserPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPermission>
          }
          groupBy: {
            args: Prisma.UserPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<UserPermissionCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      ScheduleParticipant: {
        payload: Prisma.$ScheduleParticipantPayload<ExtArgs>
        fields: Prisma.ScheduleParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload>
          }
          findFirst: {
            args: Prisma.ScheduleParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload>
          }
          findMany: {
            args: Prisma.ScheduleParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload>[]
          }
          create: {
            args: Prisma.ScheduleParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload>
          }
          createMany: {
            args: Prisma.ScheduleParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload>[]
          }
          delete: {
            args: Prisma.ScheduleParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload>
          }
          update: {
            args: Prisma.ScheduleParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ScheduleParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleParticipantPayload>
          }
          aggregate: {
            args: Prisma.ScheduleParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleParticipant>
          }
          groupBy: {
            args: Prisma.ScheduleParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleParticipantCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      LeadMetadata: {
        payload: Prisma.$LeadMetadataPayload<ExtArgs>
        fields: Prisma.LeadMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload>
          }
          findFirst: {
            args: Prisma.LeadMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload>
          }
          findMany: {
            args: Prisma.LeadMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload>[]
          }
          create: {
            args: Prisma.LeadMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload>
          }
          createMany: {
            args: Prisma.LeadMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload>[]
          }
          delete: {
            args: Prisma.LeadMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload>
          }
          update: {
            args: Prisma.LeadMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload>
          }
          deleteMany: {
            args: Prisma.LeadMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload>[]
          }
          upsert: {
            args: Prisma.LeadMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadMetadataPayload>
          }
          aggregate: {
            args: Prisma.LeadMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadMetadata>
          }
          groupBy: {
            args: Prisma.LeadMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<LeadMetadataCountAggregateOutputType> | number
          }
        }
      }
      LeadLostReason: {
        payload: Prisma.$LeadLostReasonPayload<ExtArgs>
        fields: Prisma.LeadLostReasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadLostReasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadLostReasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload>
          }
          findFirst: {
            args: Prisma.LeadLostReasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadLostReasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload>
          }
          findMany: {
            args: Prisma.LeadLostReasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload>[]
          }
          create: {
            args: Prisma.LeadLostReasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload>
          }
          createMany: {
            args: Prisma.LeadLostReasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadLostReasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload>[]
          }
          delete: {
            args: Prisma.LeadLostReasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload>
          }
          update: {
            args: Prisma.LeadLostReasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload>
          }
          deleteMany: {
            args: Prisma.LeadLostReasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadLostReasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadLostReasonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload>[]
          }
          upsert: {
            args: Prisma.LeadLostReasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadLostReasonPayload>
          }
          aggregate: {
            args: Prisma.LeadLostReasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadLostReason>
          }
          groupBy: {
            args: Prisma.LeadLostReasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadLostReasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadLostReasonCountArgs<ExtArgs>
            result: $Utils.Optional<LeadLostReasonCountAggregateOutputType> | number
          }
        }
      }
      LeadComment: {
        payload: Prisma.$LeadCommentPayload<ExtArgs>
        fields: Prisma.LeadCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload>
          }
          findFirst: {
            args: Prisma.LeadCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload>
          }
          findMany: {
            args: Prisma.LeadCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload>[]
          }
          create: {
            args: Prisma.LeadCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload>
          }
          createMany: {
            args: Prisma.LeadCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload>[]
          }
          delete: {
            args: Prisma.LeadCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload>
          }
          update: {
            args: Prisma.LeadCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload>
          }
          deleteMany: {
            args: Prisma.LeadCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload>[]
          }
          upsert: {
            args: Prisma.LeadCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCommentPayload>
          }
          aggregate: {
            args: Prisma.LeadCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadComment>
          }
          groupBy: {
            args: Prisma.LeadCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCommentCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCommentCountAggregateOutputType> | number
          }
        }
      }
      LeadChat: {
        payload: Prisma.$LeadChatPayload<ExtArgs>
        fields: Prisma.LeadChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload>
          }
          findFirst: {
            args: Prisma.LeadChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload>
          }
          findMany: {
            args: Prisma.LeadChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload>[]
          }
          create: {
            args: Prisma.LeadChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload>
          }
          createMany: {
            args: Prisma.LeadChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload>[]
          }
          delete: {
            args: Prisma.LeadChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload>
          }
          update: {
            args: Prisma.LeadChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload>
          }
          deleteMany: {
            args: Prisma.LeadChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload>[]
          }
          upsert: {
            args: Prisma.LeadChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadChatPayload>
          }
          aggregate: {
            args: Prisma.LeadChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadChat>
          }
          groupBy: {
            args: Prisma.LeadChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadChatCountArgs<ExtArgs>
            result: $Utils.Optional<LeadChatCountAggregateOutputType> | number
          }
        }
      }
      LeadDocument: {
        payload: Prisma.$LeadDocumentPayload<ExtArgs>
        fields: Prisma.LeadDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload>
          }
          findFirst: {
            args: Prisma.LeadDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload>
          }
          findMany: {
            args: Prisma.LeadDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload>[]
          }
          create: {
            args: Prisma.LeadDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload>
          }
          createMany: {
            args: Prisma.LeadDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload>[]
          }
          delete: {
            args: Prisma.LeadDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload>
          }
          update: {
            args: Prisma.LeadDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload>
          }
          deleteMany: {
            args: Prisma.LeadDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload>[]
          }
          upsert: {
            args: Prisma.LeadDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadDocumentPayload>
          }
          aggregate: {
            args: Prisma.LeadDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadDocument>
          }
          groupBy: {
            args: Prisma.LeadDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<LeadDocumentCountAggregateOutputType> | number
          }
        }
      }
      Lane: {
        payload: Prisma.$LanePayload<ExtArgs>
        fields: Prisma.LaneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          findFirst: {
            args: Prisma.LaneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          findMany: {
            args: Prisma.LaneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>[]
          }
          create: {
            args: Prisma.LaneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          createMany: {
            args: Prisma.LaneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>[]
          }
          delete: {
            args: Prisma.LaneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          update: {
            args: Prisma.LaneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          deleteMany: {
            args: Prisma.LaneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LaneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>[]
          }
          upsert: {
            args: Prisma.LaneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          aggregate: {
            args: Prisma.LaneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLane>
          }
          groupBy: {
            args: Prisma.LaneGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaneGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaneCountArgs<ExtArgs>
            result: $Utils.Optional<LaneCountAggregateOutputType> | number
          }
        }
      }
      ConstructionCompany: {
        payload: Prisma.$ConstructionCompanyPayload<ExtArgs>
        fields: Prisma.ConstructionCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConstructionCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConstructionCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload>
          }
          findFirst: {
            args: Prisma.ConstructionCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConstructionCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload>
          }
          findMany: {
            args: Prisma.ConstructionCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload>[]
          }
          create: {
            args: Prisma.ConstructionCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload>
          }
          createMany: {
            args: Prisma.ConstructionCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConstructionCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload>[]
          }
          delete: {
            args: Prisma.ConstructionCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload>
          }
          update: {
            args: Prisma.ConstructionCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload>
          }
          deleteMany: {
            args: Prisma.ConstructionCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConstructionCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConstructionCompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload>[]
          }
          upsert: {
            args: Prisma.ConstructionCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConstructionCompanyPayload>
          }
          aggregate: {
            args: Prisma.ConstructionCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConstructionCompany>
          }
          groupBy: {
            args: Prisma.ConstructionCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConstructionCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConstructionCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<ConstructionCompanyCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      LeadCampaign: {
        payload: Prisma.$LeadCampaignPayload<ExtArgs>
        fields: Prisma.LeadCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload>
          }
          findFirst: {
            args: Prisma.LeadCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload>
          }
          findMany: {
            args: Prisma.LeadCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload>[]
          }
          create: {
            args: Prisma.LeadCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload>
          }
          createMany: {
            args: Prisma.LeadCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload>[]
          }
          delete: {
            args: Prisma.LeadCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload>
          }
          update: {
            args: Prisma.LeadCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload>
          }
          deleteMany: {
            args: Prisma.LeadCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadCampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload>[]
          }
          upsert: {
            args: Prisma.LeadCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadCampaignPayload>
          }
          aggregate: {
            args: Prisma.LeadCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadCampaign>
          }
          groupBy: {
            args: Prisma.LeadCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignSource: {
        payload: Prisma.$CampaignSourcePayload<ExtArgs>
        fields: Prisma.CampaignSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload>
          }
          findFirst: {
            args: Prisma.CampaignSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload>
          }
          findMany: {
            args: Prisma.CampaignSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload>[]
          }
          create: {
            args: Prisma.CampaignSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload>
          }
          createMany: {
            args: Prisma.CampaignSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload>[]
          }
          delete: {
            args: Prisma.CampaignSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload>
          }
          update: {
            args: Prisma.CampaignSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload>
          }
          deleteMany: {
            args: Prisma.CampaignSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload>[]
          }
          upsert: {
            args: Prisma.CampaignSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignSourcePayload>
          }
          aggregate: {
            args: Prisma.CampaignSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignSource>
          }
          groupBy: {
            args: Prisma.CampaignSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignSourceCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignSourceCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      LeadTag: {
        payload: Prisma.$LeadTagPayload<ExtArgs>
        fields: Prisma.LeadTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload>
          }
          findFirst: {
            args: Prisma.LeadTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload>
          }
          findMany: {
            args: Prisma.LeadTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload>[]
          }
          create: {
            args: Prisma.LeadTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload>
          }
          createMany: {
            args: Prisma.LeadTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload>[]
          }
          delete: {
            args: Prisma.LeadTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload>
          }
          update: {
            args: Prisma.LeadTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload>
          }
          deleteMany: {
            args: Prisma.LeadTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload>[]
          }
          upsert: {
            args: Prisma.LeadTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadTagPayload>
          }
          aggregate: {
            args: Prisma.LeadTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadTag>
          }
          groupBy: {
            args: Prisma.LeadTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadTagCountArgs<ExtArgs>
            result: $Utils.Optional<LeadTagCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    permission?: PermissionOmit
    userPermission?: UserPermissionOmit
    customer?: CustomerOmit
    schedule?: ScheduleOmit
    scheduleParticipant?: ScheduleParticipantOmit
    lead?: LeadOmit
    leadMetadata?: LeadMetadataOmit
    leadLostReason?: LeadLostReasonOmit
    leadComment?: LeadCommentOmit
    leadChat?: LeadChatOmit
    leadDocument?: LeadDocumentOmit
    lane?: LaneOmit
    constructionCompany?: ConstructionCompanyOmit
    project?: ProjectOmit
    campaign?: CampaignOmit
    leadCampaign?: LeadCampaignOmit
    campaignSource?: CampaignSourceOmit
    tag?: TagOmit
    leadTag?: LeadTagOmit
    contact?: ContactOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    Permissions: number
    Leads: number
    LeadComments: number
    LeadDocuments: number
    Schedules: number
    ScheduleParticipating: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    Permissions?: boolean | UserCountOutputTypeCountPermissionsArgs
    Leads?: boolean | UserCountOutputTypeCountLeadsArgs
    LeadComments?: boolean | UserCountOutputTypeCountLeadCommentsArgs
    LeadDocuments?: boolean | UserCountOutputTypeCountLeadDocumentsArgs
    Schedules?: boolean | UserCountOutputTypeCountSchedulesArgs
    ScheduleParticipating?: boolean | UserCountOutputTypeCountScheduleParticipatingArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeadCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeadDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScheduleParticipatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleParticipantWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    Users: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | PermissionCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    Leads: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Leads?: boolean | CustomerCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }


  /**
   * Count Type ScheduleCountOutputType
   */

  export type ScheduleCountOutputType = {
    Participants: number
  }

  export type ScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Participants?: boolean | ScheduleCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleCountOutputType
     */
    select?: ScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleParticipantWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    Campaigns: number
    Tags: number
    Documents: number
    Comments: number
    Metadata: number
    Chats: number
    Schedules: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaigns?: boolean | LeadCountOutputTypeCountCampaignsArgs
    Tags?: boolean | LeadCountOutputTypeCountTagsArgs
    Documents?: boolean | LeadCountOutputTypeCountDocumentsArgs
    Comments?: boolean | LeadCountOutputTypeCountCommentsArgs
    Metadata?: boolean | LeadCountOutputTypeCountMetadataArgs
    Chats?: boolean | LeadCountOutputTypeCountChatsArgs
    Schedules?: boolean | LeadCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadCampaignWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadTagWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadDocumentWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadCommentWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadMetadataWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadChatWhereInput
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }


  /**
   * Count Type LeadLostReasonCountOutputType
   */

  export type LeadLostReasonCountOutputType = {
    Leads: number
  }

  export type LeadLostReasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Leads?: boolean | LeadLostReasonCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * LeadLostReasonCountOutputType without action
   */
  export type LeadLostReasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReasonCountOutputType
     */
    select?: LeadLostReasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadLostReasonCountOutputType without action
   */
  export type LeadLostReasonCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }


  /**
   * Count Type LaneCountOutputType
   */

  export type LaneCountOutputType = {
    Leads: number
  }

  export type LaneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Leads?: boolean | LaneCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * LaneCountOutputType without action
   */
  export type LaneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaneCountOutputType
     */
    select?: LaneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LaneCountOutputType without action
   */
  export type LaneCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }


  /**
   * Count Type ConstructionCompanyCountOutputType
   */

  export type ConstructionCompanyCountOutputType = {
    Projects: number
    Contacts: number
  }

  export type ConstructionCompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Projects?: boolean | ConstructionCompanyCountOutputTypeCountProjectsArgs
    Contacts?: boolean | ConstructionCompanyCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * ConstructionCompanyCountOutputType without action
   */
  export type ConstructionCompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompanyCountOutputType
     */
    select?: ConstructionCompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConstructionCompanyCountOutputType without action
   */
  export type ConstructionCompanyCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * ConstructionCompanyCountOutputType without action
   */
  export type ConstructionCompanyCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    Campaigns: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaigns?: boolean | ProjectCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    Leads: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Leads?: boolean | CampaignCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadCampaignWhereInput
  }


  /**
   * Count Type CampaignSourceCountOutputType
   */

  export type CampaignSourceCountOutputType = {
    Campaigns: number
  }

  export type CampaignSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaigns?: boolean | CampaignSourceCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * CampaignSourceCountOutputType without action
   */
  export type CampaignSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSourceCountOutputType
     */
    select?: CampaignSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignSourceCountOutputType without action
   */
  export type CampaignSourceCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    Leads: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Leads?: boolean | TagCountOutputTypeCountLeadsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadTagWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    master: boolean | null
    status: $Enums.UserStatus | null
    chatwootAgentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    master: boolean | null
    status: $Enums.UserStatus | null
    chatwootAgentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    master: number
    status: number
    chatwootAgentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    master?: true
    status?: true
    chatwootAgentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    master?: true
    status?: true
    chatwootAgentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    master?: true
    status?: true
    chatwootAgentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: Date | null
    image: string | null
    master: boolean
    status: $Enums.UserStatus
    chatwootAgentId: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    master?: boolean
    status?: boolean
    chatwootAgentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    Permissions?: boolean | User$PermissionsArgs<ExtArgs>
    Leads?: boolean | User$LeadsArgs<ExtArgs>
    LeadComments?: boolean | User$LeadCommentsArgs<ExtArgs>
    LeadDocuments?: boolean | User$LeadDocumentsArgs<ExtArgs>
    Schedules?: boolean | User$SchedulesArgs<ExtArgs>
    ScheduleParticipating?: boolean | User$ScheduleParticipatingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    master?: boolean
    status?: boolean
    chatwootAgentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    master?: boolean
    status?: boolean
    chatwootAgentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    master?: boolean
    status?: boolean
    chatwootAgentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "master" | "status" | "chatwootAgentId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    Permissions?: boolean | User$PermissionsArgs<ExtArgs>
    Leads?: boolean | User$LeadsArgs<ExtArgs>
    LeadComments?: boolean | User$LeadCommentsArgs<ExtArgs>
    LeadDocuments?: boolean | User$LeadDocumentsArgs<ExtArgs>
    Schedules?: boolean | User$SchedulesArgs<ExtArgs>
    ScheduleParticipating?: boolean | User$ScheduleParticipatingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      Permissions: Prisma.$UserPermissionPayload<ExtArgs>[]
      Leads: Prisma.$LeadPayload<ExtArgs>[]
      LeadComments: Prisma.$LeadCommentPayload<ExtArgs>[]
      LeadDocuments: Prisma.$LeadDocumentPayload<ExtArgs>[]
      Schedules: Prisma.$SchedulePayload<ExtArgs>[]
      ScheduleParticipating: Prisma.$ScheduleParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: Date | null
      image: string | null
      master: boolean
      status: $Enums.UserStatus
      chatwootAgentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Permissions<T extends User$PermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$PermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Leads<T extends User$LeadsArgs<ExtArgs> = {}>(args?: Subset<T, User$LeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LeadComments<T extends User$LeadCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$LeadCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    LeadDocuments<T extends User$LeadDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$LeadDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Schedules<T extends User$SchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$SchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ScheduleParticipating<T extends User$ScheduleParticipatingArgs<ExtArgs> = {}>(args?: Subset<T, User$ScheduleParticipatingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly master: FieldRef<"User", 'Boolean'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly chatwootAgentId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.Permissions
   */
  export type User$PermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    where?: UserPermissionWhereInput
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    cursor?: UserPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * User.Leads
   */
  export type User$LeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * User.LeadComments
   */
  export type User$LeadCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    where?: LeadCommentWhereInput
    orderBy?: LeadCommentOrderByWithRelationInput | LeadCommentOrderByWithRelationInput[]
    cursor?: LeadCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadCommentScalarFieldEnum | LeadCommentScalarFieldEnum[]
  }

  /**
   * User.LeadDocuments
   */
  export type User$LeadDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    where?: LeadDocumentWhereInput
    orderBy?: LeadDocumentOrderByWithRelationInput | LeadDocumentOrderByWithRelationInput[]
    cursor?: LeadDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadDocumentScalarFieldEnum | LeadDocumentScalarFieldEnum[]
  }

  /**
   * User.Schedules
   */
  export type User$SchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * User.ScheduleParticipating
   */
  export type User$ScheduleParticipatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    where?: ScheduleParticipantWhereInput
    orderBy?: ScheduleParticipantOrderByWithRelationInput | ScheduleParticipantOrderByWithRelationInput[]
    cursor?: ScheduleParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleParticipantScalarFieldEnum | ScheduleParticipantScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const accountWithUserIdOnly = await prisma.account.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `userId`
     * const accountWithUserIdOnly = await prisma.account.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `userId`
     * const accountWithUserIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    sessionToken: string
    userId: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionToken" | "userId" | "expires" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionToken: string
      userId: string
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.findMany({ select: { sessionToken: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.createManyAndReturn({
     *   select: { sessionToken: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.updateManyAndReturn({
     *   select: { sessionToken: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    slug: string | null
    description: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    description: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    slug: number
    description: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    slug?: true
    description?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    slug?: true
    description?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    slug?: true
    description?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    slug: string
    description: string
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    description?: boolean
    Users?: boolean | Permission$UsersArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    description?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    description?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    slug?: boolean
    description?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "description", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Permission$UsersArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      Users: Prisma.$UserPermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      description: string
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends Permission$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Permission$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly slug: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.Users
   */
  export type Permission$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    where?: UserPermissionWhereInput
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    cursor?: UserPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserPermission
   */

  export type AggregateUserPermission = {
    _count: UserPermissionCountAggregateOutputType | null
    _min: UserPermissionMinAggregateOutputType | null
    _max: UserPermissionMaxAggregateOutputType | null
  }

  export type UserPermissionMinAggregateOutputType = {
    userId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type UserPermissionMaxAggregateOutputType = {
    userId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type UserPermissionCountAggregateOutputType = {
    userId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type UserPermissionMinAggregateInputType = {
    userId?: true
    permissionId?: true
    createdAt?: true
  }

  export type UserPermissionMaxAggregateInputType = {
    userId?: true
    permissionId?: true
    createdAt?: true
  }

  export type UserPermissionCountAggregateInputType = {
    userId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type UserPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPermission to aggregate.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPermissions
    **/
    _count?: true | UserPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPermissionMaxAggregateInputType
  }

  export type GetUserPermissionAggregateType<T extends UserPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPermission[P]>
      : GetScalarType<T[P], AggregateUserPermission[P]>
  }




  export type UserPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPermissionWhereInput
    orderBy?: UserPermissionOrderByWithAggregationInput | UserPermissionOrderByWithAggregationInput[]
    by: UserPermissionScalarFieldEnum[] | UserPermissionScalarFieldEnum
    having?: UserPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPermissionCountAggregateInputType | true
    _min?: UserPermissionMinAggregateInputType
    _max?: UserPermissionMaxAggregateInputType
  }

  export type UserPermissionGroupByOutputType = {
    userId: string
    permissionId: string
    createdAt: Date
    _count: UserPermissionCountAggregateOutputType | null
    _min: UserPermissionMinAggregateOutputType | null
    _max: UserPermissionMaxAggregateOutputType | null
  }

  type GetUserPermissionGroupByPayload<T extends UserPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], UserPermissionGroupByOutputType[P]>
        }
      >
    >


  export type UserPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPermission"]>

  export type UserPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPermission"]>

  export type UserPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPermission"]>

  export type UserPermissionSelectScalar = {
    userId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type UserPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "permissionId" | "createdAt", ExtArgs["result"]["userPermission"]>
  export type UserPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type UserPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type UserPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $UserPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPermission"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      permissionId: string
      createdAt: Date
    }, ExtArgs["result"]["userPermission"]>
    composites: {}
  }

  type UserPermissionGetPayload<S extends boolean | null | undefined | UserPermissionDefaultArgs> = $Result.GetResult<Prisma.$UserPermissionPayload, S>

  type UserPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPermissionCountAggregateInputType | true
    }

  export interface UserPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPermission'], meta: { name: 'UserPermission' } }
    /**
     * Find zero or one UserPermission that matches the filter.
     * @param {UserPermissionFindUniqueArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPermissionFindUniqueArgs>(args: SelectSubset<T, UserPermissionFindUniqueArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPermissionFindUniqueOrThrowArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionFindFirstArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPermissionFindFirstArgs>(args?: SelectSubset<T, UserPermissionFindFirstArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionFindFirstOrThrowArgs} args - Arguments to find a UserPermission
     * @example
     * // Get one UserPermission
     * const userPermission = await prisma.userPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPermissions
     * const userPermissions = await prisma.userPermission.findMany()
     * 
     * // Get first 10 UserPermissions
     * const userPermissions = await prisma.userPermission.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userPermissionWithUserIdOnly = await prisma.userPermission.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserPermissionFindManyArgs>(args?: SelectSubset<T, UserPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPermission.
     * @param {UserPermissionCreateArgs} args - Arguments to create a UserPermission.
     * @example
     * // Create one UserPermission
     * const UserPermission = await prisma.userPermission.create({
     *   data: {
     *     // ... data to create a UserPermission
     *   }
     * })
     * 
     */
    create<T extends UserPermissionCreateArgs>(args: SelectSubset<T, UserPermissionCreateArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPermissions.
     * @param {UserPermissionCreateManyArgs} args - Arguments to create many UserPermissions.
     * @example
     * // Create many UserPermissions
     * const userPermission = await prisma.userPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPermissionCreateManyArgs>(args?: SelectSubset<T, UserPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPermissions and returns the data saved in the database.
     * @param {UserPermissionCreateManyAndReturnArgs} args - Arguments to create many UserPermissions.
     * @example
     * // Create many UserPermissions
     * const userPermission = await prisma.userPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPermissions and only return the `userId`
     * const userPermissionWithUserIdOnly = await prisma.userPermission.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPermission.
     * @param {UserPermissionDeleteArgs} args - Arguments to delete one UserPermission.
     * @example
     * // Delete one UserPermission
     * const UserPermission = await prisma.userPermission.delete({
     *   where: {
     *     // ... filter to delete one UserPermission
     *   }
     * })
     * 
     */
    delete<T extends UserPermissionDeleteArgs>(args: SelectSubset<T, UserPermissionDeleteArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPermission.
     * @param {UserPermissionUpdateArgs} args - Arguments to update one UserPermission.
     * @example
     * // Update one UserPermission
     * const userPermission = await prisma.userPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPermissionUpdateArgs>(args: SelectSubset<T, UserPermissionUpdateArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPermissions.
     * @param {UserPermissionDeleteManyArgs} args - Arguments to filter UserPermissions to delete.
     * @example
     * // Delete a few UserPermissions
     * const { count } = await prisma.userPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPermissionDeleteManyArgs>(args?: SelectSubset<T, UserPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPermissions
     * const userPermission = await prisma.userPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPermissionUpdateManyArgs>(args: SelectSubset<T, UserPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPermissions and returns the data updated in the database.
     * @param {UserPermissionUpdateManyAndReturnArgs} args - Arguments to update many UserPermissions.
     * @example
     * // Update many UserPermissions
     * const userPermission = await prisma.userPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPermissions and only return the `userId`
     * const userPermissionWithUserIdOnly = await prisma.userPermission.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPermission.
     * @param {UserPermissionUpsertArgs} args - Arguments to update or create a UserPermission.
     * @example
     * // Update or create a UserPermission
     * const userPermission = await prisma.userPermission.upsert({
     *   create: {
     *     // ... data to create a UserPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPermission we want to update
     *   }
     * })
     */
    upsert<T extends UserPermissionUpsertArgs>(args: SelectSubset<T, UserPermissionUpsertArgs<ExtArgs>>): Prisma__UserPermissionClient<$Result.GetResult<Prisma.$UserPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionCountArgs} args - Arguments to filter UserPermissions to count.
     * @example
     * // Count the number of UserPermissions
     * const count = await prisma.userPermission.count({
     *   where: {
     *     // ... the filter for the UserPermissions we want to count
     *   }
     * })
    **/
    count<T extends UserPermissionCountArgs>(
      args?: Subset<T, UserPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPermissionAggregateArgs>(args: Subset<T, UserPermissionAggregateArgs>): Prisma.PrismaPromise<GetUserPermissionAggregateType<T>>

    /**
     * Group by UserPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPermissionGroupByArgs['orderBy'] }
        : { orderBy?: UserPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPermission model
   */
  readonly fields: UserPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPermission model
   */
  interface UserPermissionFieldRefs {
    readonly userId: FieldRef<"UserPermission", 'String'>
    readonly permissionId: FieldRef<"UserPermission", 'String'>
    readonly createdAt: FieldRef<"UserPermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPermission findUnique
   */
  export type UserPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission findUniqueOrThrow
   */
  export type UserPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission findFirst
   */
  export type UserPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPermissions.
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPermissions.
     */
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * UserPermission findFirstOrThrow
   */
  export type UserPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermission to fetch.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPermissions.
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPermissions.
     */
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * UserPermission findMany
   */
  export type UserPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserPermissions to fetch.
     */
    where?: UserPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPermissions to fetch.
     */
    orderBy?: UserPermissionOrderByWithRelationInput | UserPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPermissions.
     */
    cursor?: UserPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPermissions.
     */
    skip?: number
    distinct?: UserPermissionScalarFieldEnum | UserPermissionScalarFieldEnum[]
  }

  /**
   * UserPermission create
   */
  export type UserPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPermission.
     */
    data: XOR<UserPermissionCreateInput, UserPermissionUncheckedCreateInput>
  }

  /**
   * UserPermission createMany
   */
  export type UserPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPermissions.
     */
    data: UserPermissionCreateManyInput | UserPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPermission createManyAndReturn
   */
  export type UserPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many UserPermissions.
     */
    data: UserPermissionCreateManyInput | UserPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPermission update
   */
  export type UserPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPermission.
     */
    data: XOR<UserPermissionUpdateInput, UserPermissionUncheckedUpdateInput>
    /**
     * Choose, which UserPermission to update.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission updateMany
   */
  export type UserPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPermissions.
     */
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyInput>
    /**
     * Filter which UserPermissions to update
     */
    where?: UserPermissionWhereInput
    /**
     * Limit how many UserPermissions to update.
     */
    limit?: number
  }

  /**
   * UserPermission updateManyAndReturn
   */
  export type UserPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * The data used to update UserPermissions.
     */
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyInput>
    /**
     * Filter which UserPermissions to update
     */
    where?: UserPermissionWhereInput
    /**
     * Limit how many UserPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPermission upsert
   */
  export type UserPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPermission to update in case it exists.
     */
    where: UserPermissionWhereUniqueInput
    /**
     * In case the UserPermission found by the `where` argument doesn't exist, create a new UserPermission with this data.
     */
    create: XOR<UserPermissionCreateInput, UserPermissionUncheckedCreateInput>
    /**
     * In case the UserPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPermissionUpdateInput, UserPermissionUncheckedUpdateInput>
  }

  /**
   * UserPermission delete
   */
  export type UserPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
    /**
     * Filter which UserPermission to delete.
     */
    where: UserPermissionWhereUniqueInput
  }

  /**
   * UserPermission deleteMany
   */
  export type UserPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPermissions to delete
     */
    where?: UserPermissionWhereInput
    /**
     * Limit how many UserPermissions to delete.
     */
    limit?: number
  }

  /**
   * UserPermission without action
   */
  export type UserPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPermission
     */
    select?: UserPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPermission
     */
    omit?: UserPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPermissionInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    picture: string | null
    name: string | null
    phone: string | null
    email: string | null
    chatwootContactId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    picture: string | null
    name: string | null
    phone: string | null
    email: string | null
    chatwootContactId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    picture: number
    name: number
    phone: number
    email: number
    chatwootContactId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    picture?: true
    name?: true
    phone?: true
    email?: true
    chatwootContactId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    picture?: true
    name?: true
    phone?: true
    email?: true
    chatwootContactId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    picture?: true
    name?: true
    phone?: true
    email?: true
    chatwootContactId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    picture: string
    name: string
    phone: string
    email: string
    chatwootContactId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    picture?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    chatwootContactId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Leads?: boolean | Customer$LeadsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    picture?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    chatwootContactId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    picture?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    chatwootContactId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    picture?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    chatwootContactId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "picture" | "name" | "phone" | "email" | "chatwootContactId" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Leads?: boolean | Customer$LeadsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      Leads: Prisma.$LeadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      picture: string
      name: string
      phone: string
      email: string
      chatwootContactId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Leads<T extends Customer$LeadsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$LeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly picture: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly chatwootContactId: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.Leads
   */
  export type Customer$LeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    leadId: string | null
    date: Date | null
    address: string | null
    nextNotificationAt: Date | null
    status: $Enums.ScheduleStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    leadId: string | null
    date: Date | null
    address: string | null
    nextNotificationAt: Date | null
    status: $Enums.ScheduleStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    userId: number
    leadId: number
    date: number
    address: number
    nextNotificationAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleMinAggregateInputType = {
    id?: true
    userId?: true
    leadId?: true
    date?: true
    address?: true
    nextNotificationAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    userId?: true
    leadId?: true
    date?: true
    address?: true
    nextNotificationAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    userId?: true
    leadId?: true
    date?: true
    address?: true
    nextNotificationAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    userId: string
    leadId: string
    date: Date
    address: string
    nextNotificationAt: Date | null
    status: $Enums.ScheduleStatus
    createdAt: Date
    updatedAt: Date
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    leadId?: boolean
    date?: boolean
    address?: boolean
    nextNotificationAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Participants?: boolean | Schedule$ParticipantsArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    leadId?: boolean
    date?: boolean
    address?: boolean
    nextNotificationAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    leadId?: boolean
    date?: boolean
    address?: boolean
    nextNotificationAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    userId?: boolean
    leadId?: boolean
    date?: boolean
    address?: boolean
    nextNotificationAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "leadId" | "date" | "address" | "nextNotificationAt" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Participants?: boolean | Schedule$ParticipantsArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Lead: Prisma.$LeadPayload<ExtArgs>
      Participants: Prisma.$ScheduleParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      leadId: string
      date: Date
      address: string
      nextNotificationAt: Date | null
      status: $Enums.ScheduleStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Participants<T extends Schedule$ParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$ParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly userId: FieldRef<"Schedule", 'String'>
    readonly leadId: FieldRef<"Schedule", 'String'>
    readonly date: FieldRef<"Schedule", 'DateTime'>
    readonly address: FieldRef<"Schedule", 'String'>
    readonly nextNotificationAt: FieldRef<"Schedule", 'DateTime'>
    readonly status: FieldRef<"Schedule", 'ScheduleStatus'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule updateManyAndReturn
   */
  export type ScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule.Participants
   */
  export type Schedule$ParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    where?: ScheduleParticipantWhereInput
    orderBy?: ScheduleParticipantOrderByWithRelationInput | ScheduleParticipantOrderByWithRelationInput[]
    cursor?: ScheduleParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleParticipantScalarFieldEnum | ScheduleParticipantScalarFieldEnum[]
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleParticipant
   */

  export type AggregateScheduleParticipant = {
    _count: ScheduleParticipantCountAggregateOutputType | null
    _min: ScheduleParticipantMinAggregateOutputType | null
    _max: ScheduleParticipantMaxAggregateOutputType | null
  }

  export type ScheduleParticipantMinAggregateOutputType = {
    scheduleId: string | null
    userId: string | null
  }

  export type ScheduleParticipantMaxAggregateOutputType = {
    scheduleId: string | null
    userId: string | null
  }

  export type ScheduleParticipantCountAggregateOutputType = {
    scheduleId: number
    userId: number
    _all: number
  }


  export type ScheduleParticipantMinAggregateInputType = {
    scheduleId?: true
    userId?: true
  }

  export type ScheduleParticipantMaxAggregateInputType = {
    scheduleId?: true
    userId?: true
  }

  export type ScheduleParticipantCountAggregateInputType = {
    scheduleId?: true
    userId?: true
    _all?: true
  }

  export type ScheduleParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleParticipant to aggregate.
     */
    where?: ScheduleParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleParticipants to fetch.
     */
    orderBy?: ScheduleParticipantOrderByWithRelationInput | ScheduleParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleParticipants
    **/
    _count?: true | ScheduleParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleParticipantMaxAggregateInputType
  }

  export type GetScheduleParticipantAggregateType<T extends ScheduleParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleParticipant[P]>
      : GetScalarType<T[P], AggregateScheduleParticipant[P]>
  }




  export type ScheduleParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleParticipantWhereInput
    orderBy?: ScheduleParticipantOrderByWithAggregationInput | ScheduleParticipantOrderByWithAggregationInput[]
    by: ScheduleParticipantScalarFieldEnum[] | ScheduleParticipantScalarFieldEnum
    having?: ScheduleParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleParticipantCountAggregateInputType | true
    _min?: ScheduleParticipantMinAggregateInputType
    _max?: ScheduleParticipantMaxAggregateInputType
  }

  export type ScheduleParticipantGroupByOutputType = {
    scheduleId: string
    userId: string
    _count: ScheduleParticipantCountAggregateOutputType | null
    _min: ScheduleParticipantMinAggregateOutputType | null
    _max: ScheduleParticipantMaxAggregateOutputType | null
  }

  type GetScheduleParticipantGroupByPayload<T extends ScheduleParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scheduleId?: boolean
    userId?: boolean
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    Participant?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleParticipant"]>

  export type ScheduleParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scheduleId?: boolean
    userId?: boolean
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    Participant?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleParticipant"]>

  export type ScheduleParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scheduleId?: boolean
    userId?: boolean
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    Participant?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleParticipant"]>

  export type ScheduleParticipantSelectScalar = {
    scheduleId?: boolean
    userId?: boolean
  }

  export type ScheduleParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"scheduleId" | "userId", ExtArgs["result"]["scheduleParticipant"]>
  export type ScheduleParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    Participant?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ScheduleParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    Participant?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ScheduleParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    Participant?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ScheduleParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleParticipant"
    objects: {
      Schedule: Prisma.$SchedulePayload<ExtArgs>
      Participant: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      scheduleId: string
      userId: string
    }, ExtArgs["result"]["scheduleParticipant"]>
    composites: {}
  }

  type ScheduleParticipantGetPayload<S extends boolean | null | undefined | ScheduleParticipantDefaultArgs> = $Result.GetResult<Prisma.$ScheduleParticipantPayload, S>

  type ScheduleParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleParticipantCountAggregateInputType | true
    }

  export interface ScheduleParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleParticipant'], meta: { name: 'ScheduleParticipant' } }
    /**
     * Find zero or one ScheduleParticipant that matches the filter.
     * @param {ScheduleParticipantFindUniqueArgs} args - Arguments to find a ScheduleParticipant
     * @example
     * // Get one ScheduleParticipant
     * const scheduleParticipant = await prisma.scheduleParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleParticipantFindUniqueArgs>(args: SelectSubset<T, ScheduleParticipantFindUniqueArgs<ExtArgs>>): Prisma__ScheduleParticipantClient<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduleParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleParticipantFindUniqueOrThrowArgs} args - Arguments to find a ScheduleParticipant
     * @example
     * // Get one ScheduleParticipant
     * const scheduleParticipant = await prisma.scheduleParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleParticipantClient<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleParticipantFindFirstArgs} args - Arguments to find a ScheduleParticipant
     * @example
     * // Get one ScheduleParticipant
     * const scheduleParticipant = await prisma.scheduleParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleParticipantFindFirstArgs>(args?: SelectSubset<T, ScheduleParticipantFindFirstArgs<ExtArgs>>): Prisma__ScheduleParticipantClient<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleParticipantFindFirstOrThrowArgs} args - Arguments to find a ScheduleParticipant
     * @example
     * // Get one ScheduleParticipant
     * const scheduleParticipant = await prisma.scheduleParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleParticipantClient<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduleParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleParticipants
     * const scheduleParticipants = await prisma.scheduleParticipant.findMany()
     * 
     * // Get first 10 ScheduleParticipants
     * const scheduleParticipants = await prisma.scheduleParticipant.findMany({ take: 10 })
     * 
     * // Only select the `scheduleId`
     * const scheduleParticipantWithScheduleIdOnly = await prisma.scheduleParticipant.findMany({ select: { scheduleId: true } })
     * 
     */
    findMany<T extends ScheduleParticipantFindManyArgs>(args?: SelectSubset<T, ScheduleParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduleParticipant.
     * @param {ScheduleParticipantCreateArgs} args - Arguments to create a ScheduleParticipant.
     * @example
     * // Create one ScheduleParticipant
     * const ScheduleParticipant = await prisma.scheduleParticipant.create({
     *   data: {
     *     // ... data to create a ScheduleParticipant
     *   }
     * })
     * 
     */
    create<T extends ScheduleParticipantCreateArgs>(args: SelectSubset<T, ScheduleParticipantCreateArgs<ExtArgs>>): Prisma__ScheduleParticipantClient<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduleParticipants.
     * @param {ScheduleParticipantCreateManyArgs} args - Arguments to create many ScheduleParticipants.
     * @example
     * // Create many ScheduleParticipants
     * const scheduleParticipant = await prisma.scheduleParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleParticipantCreateManyArgs>(args?: SelectSubset<T, ScheduleParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleParticipants and returns the data saved in the database.
     * @param {ScheduleParticipantCreateManyAndReturnArgs} args - Arguments to create many ScheduleParticipants.
     * @example
     * // Create many ScheduleParticipants
     * const scheduleParticipant = await prisma.scheduleParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleParticipants and only return the `scheduleId`
     * const scheduleParticipantWithScheduleIdOnly = await prisma.scheduleParticipant.createManyAndReturn({
     *   select: { scheduleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduleParticipant.
     * @param {ScheduleParticipantDeleteArgs} args - Arguments to delete one ScheduleParticipant.
     * @example
     * // Delete one ScheduleParticipant
     * const ScheduleParticipant = await prisma.scheduleParticipant.delete({
     *   where: {
     *     // ... filter to delete one ScheduleParticipant
     *   }
     * })
     * 
     */
    delete<T extends ScheduleParticipantDeleteArgs>(args: SelectSubset<T, ScheduleParticipantDeleteArgs<ExtArgs>>): Prisma__ScheduleParticipantClient<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduleParticipant.
     * @param {ScheduleParticipantUpdateArgs} args - Arguments to update one ScheduleParticipant.
     * @example
     * // Update one ScheduleParticipant
     * const scheduleParticipant = await prisma.scheduleParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleParticipantUpdateArgs>(args: SelectSubset<T, ScheduleParticipantUpdateArgs<ExtArgs>>): Prisma__ScheduleParticipantClient<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduleParticipants.
     * @param {ScheduleParticipantDeleteManyArgs} args - Arguments to filter ScheduleParticipants to delete.
     * @example
     * // Delete a few ScheduleParticipants
     * const { count } = await prisma.scheduleParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleParticipantDeleteManyArgs>(args?: SelectSubset<T, ScheduleParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleParticipants
     * const scheduleParticipant = await prisma.scheduleParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleParticipantUpdateManyArgs>(args: SelectSubset<T, ScheduleParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleParticipants and returns the data updated in the database.
     * @param {ScheduleParticipantUpdateManyAndReturnArgs} args - Arguments to update many ScheduleParticipants.
     * @example
     * // Update many ScheduleParticipants
     * const scheduleParticipant = await prisma.scheduleParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduleParticipants and only return the `scheduleId`
     * const scheduleParticipantWithScheduleIdOnly = await prisma.scheduleParticipant.updateManyAndReturn({
     *   select: { scheduleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduleParticipant.
     * @param {ScheduleParticipantUpsertArgs} args - Arguments to update or create a ScheduleParticipant.
     * @example
     * // Update or create a ScheduleParticipant
     * const scheduleParticipant = await prisma.scheduleParticipant.upsert({
     *   create: {
     *     // ... data to create a ScheduleParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleParticipantUpsertArgs>(args: SelectSubset<T, ScheduleParticipantUpsertArgs<ExtArgs>>): Prisma__ScheduleParticipantClient<$Result.GetResult<Prisma.$ScheduleParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduleParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleParticipantCountArgs} args - Arguments to filter ScheduleParticipants to count.
     * @example
     * // Count the number of ScheduleParticipants
     * const count = await prisma.scheduleParticipant.count({
     *   where: {
     *     // ... the filter for the ScheduleParticipants we want to count
     *   }
     * })
    **/
    count<T extends ScheduleParticipantCountArgs>(
      args?: Subset<T, ScheduleParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleParticipantAggregateArgs>(args: Subset<T, ScheduleParticipantAggregateArgs>): Prisma.PrismaPromise<GetScheduleParticipantAggregateType<T>>

    /**
     * Group by ScheduleParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleParticipant model
   */
  readonly fields: ScheduleParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Schedule<T extends ScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleDefaultArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Participant<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleParticipant model
   */
  interface ScheduleParticipantFieldRefs {
    readonly scheduleId: FieldRef<"ScheduleParticipant", 'String'>
    readonly userId: FieldRef<"ScheduleParticipant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleParticipant findUnique
   */
  export type ScheduleParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleParticipant to fetch.
     */
    where: ScheduleParticipantWhereUniqueInput
  }

  /**
   * ScheduleParticipant findUniqueOrThrow
   */
  export type ScheduleParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleParticipant to fetch.
     */
    where: ScheduleParticipantWhereUniqueInput
  }

  /**
   * ScheduleParticipant findFirst
   */
  export type ScheduleParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleParticipant to fetch.
     */
    where?: ScheduleParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleParticipants to fetch.
     */
    orderBy?: ScheduleParticipantOrderByWithRelationInput | ScheduleParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleParticipants.
     */
    cursor?: ScheduleParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleParticipants.
     */
    distinct?: ScheduleParticipantScalarFieldEnum | ScheduleParticipantScalarFieldEnum[]
  }

  /**
   * ScheduleParticipant findFirstOrThrow
   */
  export type ScheduleParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleParticipant to fetch.
     */
    where?: ScheduleParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleParticipants to fetch.
     */
    orderBy?: ScheduleParticipantOrderByWithRelationInput | ScheduleParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleParticipants.
     */
    cursor?: ScheduleParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleParticipants.
     */
    distinct?: ScheduleParticipantScalarFieldEnum | ScheduleParticipantScalarFieldEnum[]
  }

  /**
   * ScheduleParticipant findMany
   */
  export type ScheduleParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleParticipants to fetch.
     */
    where?: ScheduleParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleParticipants to fetch.
     */
    orderBy?: ScheduleParticipantOrderByWithRelationInput | ScheduleParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleParticipants.
     */
    cursor?: ScheduleParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleParticipants.
     */
    skip?: number
    distinct?: ScheduleParticipantScalarFieldEnum | ScheduleParticipantScalarFieldEnum[]
  }

  /**
   * ScheduleParticipant create
   */
  export type ScheduleParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleParticipant.
     */
    data: XOR<ScheduleParticipantCreateInput, ScheduleParticipantUncheckedCreateInput>
  }

  /**
   * ScheduleParticipant createMany
   */
  export type ScheduleParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleParticipants.
     */
    data: ScheduleParticipantCreateManyInput | ScheduleParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleParticipant createManyAndReturn
   */
  export type ScheduleParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduleParticipants.
     */
    data: ScheduleParticipantCreateManyInput | ScheduleParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleParticipant update
   */
  export type ScheduleParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleParticipant.
     */
    data: XOR<ScheduleParticipantUpdateInput, ScheduleParticipantUncheckedUpdateInput>
    /**
     * Choose, which ScheduleParticipant to update.
     */
    where: ScheduleParticipantWhereUniqueInput
  }

  /**
   * ScheduleParticipant updateMany
   */
  export type ScheduleParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleParticipants.
     */
    data: XOR<ScheduleParticipantUpdateManyMutationInput, ScheduleParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleParticipants to update
     */
    where?: ScheduleParticipantWhereInput
    /**
     * Limit how many ScheduleParticipants to update.
     */
    limit?: number
  }

  /**
   * ScheduleParticipant updateManyAndReturn
   */
  export type ScheduleParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ScheduleParticipants.
     */
    data: XOR<ScheduleParticipantUpdateManyMutationInput, ScheduleParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleParticipants to update
     */
    where?: ScheduleParticipantWhereInput
    /**
     * Limit how many ScheduleParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleParticipant upsert
   */
  export type ScheduleParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleParticipant to update in case it exists.
     */
    where: ScheduleParticipantWhereUniqueInput
    /**
     * In case the ScheduleParticipant found by the `where` argument doesn't exist, create a new ScheduleParticipant with this data.
     */
    create: XOR<ScheduleParticipantCreateInput, ScheduleParticipantUncheckedCreateInput>
    /**
     * In case the ScheduleParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleParticipantUpdateInput, ScheduleParticipantUncheckedUpdateInput>
  }

  /**
   * ScheduleParticipant delete
   */
  export type ScheduleParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
    /**
     * Filter which ScheduleParticipant to delete.
     */
    where: ScheduleParticipantWhereUniqueInput
  }

  /**
   * ScheduleParticipant deleteMany
   */
  export type ScheduleParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleParticipants to delete
     */
    where?: ScheduleParticipantWhereInput
    /**
     * Limit how many ScheduleParticipants to delete.
     */
    limit?: number
  }

  /**
   * ScheduleParticipant without action
   */
  export type ScheduleParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleParticipant
     */
    select?: ScheduleParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleParticipant
     */
    omit?: ScheduleParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    laneId: number | null
    value: number | null
  }

  export type LeadSumAggregateOutputType = {
    laneId: number | null
    value: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    title: string | null
    customerId: string | null
    userId: string | null
    laneId: number | null
    value: number | null
    status: $Enums.LeadStatus | null
    lostedLeadReasonId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    title: string | null
    customerId: string | null
    userId: string | null
    laneId: number | null
    value: number | null
    status: $Enums.LeadStatus | null
    lostedLeadReasonId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    title: number
    customerId: number
    userId: number
    laneId: number
    value: number
    status: number
    lostedLeadReasonId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    laneId?: true
    value?: true
  }

  export type LeadSumAggregateInputType = {
    laneId?: true
    value?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    title?: true
    customerId?: true
    userId?: true
    laneId?: true
    value?: true
    status?: true
    lostedLeadReasonId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    title?: true
    customerId?: true
    userId?: true
    laneId?: true
    value?: true
    status?: true
    lostedLeadReasonId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    title?: true
    customerId?: true
    userId?: true
    laneId?: true
    value?: true
    status?: true
    lostedLeadReasonId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    title: string
    customerId: string
    userId: string | null
    laneId: number
    value: number
    status: $Enums.LeadStatus
    lostedLeadReasonId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    customerId?: boolean
    userId?: boolean
    laneId?: boolean
    value?: boolean
    status?: boolean
    lostedLeadReasonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Campaigns?: boolean | Lead$CampaignsArgs<ExtArgs>
    Customer?: boolean | Lead$CustomerArgs<ExtArgs>
    Broker?: boolean | Lead$BrokerArgs<ExtArgs>
    Tags?: boolean | Lead$TagsArgs<ExtArgs>
    Documents?: boolean | Lead$DocumentsArgs<ExtArgs>
    Comments?: boolean | Lead$CommentsArgs<ExtArgs>
    Metadata?: boolean | Lead$MetadataArgs<ExtArgs>
    Chats?: boolean | Lead$ChatsArgs<ExtArgs>
    Schedules?: boolean | Lead$SchedulesArgs<ExtArgs>
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    LostedReason?: boolean | Lead$LostedReasonArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    customerId?: boolean
    userId?: boolean
    laneId?: boolean
    value?: boolean
    status?: boolean
    lostedLeadReasonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Customer?: boolean | Lead$CustomerArgs<ExtArgs>
    Broker?: boolean | Lead$BrokerArgs<ExtArgs>
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    LostedReason?: boolean | Lead$LostedReasonArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    customerId?: boolean
    userId?: boolean
    laneId?: boolean
    value?: boolean
    status?: boolean
    lostedLeadReasonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Customer?: boolean | Lead$CustomerArgs<ExtArgs>
    Broker?: boolean | Lead$BrokerArgs<ExtArgs>
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    LostedReason?: boolean | Lead$LostedReasonArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    title?: boolean
    customerId?: boolean
    userId?: boolean
    laneId?: boolean
    value?: boolean
    status?: boolean
    lostedLeadReasonId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "customerId" | "userId" | "laneId" | "value" | "status" | "lostedLeadReasonId" | "createdAt" | "updatedAt", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaigns?: boolean | Lead$CampaignsArgs<ExtArgs>
    Customer?: boolean | Lead$CustomerArgs<ExtArgs>
    Broker?: boolean | Lead$BrokerArgs<ExtArgs>
    Tags?: boolean | Lead$TagsArgs<ExtArgs>
    Documents?: boolean | Lead$DocumentsArgs<ExtArgs>
    Comments?: boolean | Lead$CommentsArgs<ExtArgs>
    Metadata?: boolean | Lead$MetadataArgs<ExtArgs>
    Chats?: boolean | Lead$ChatsArgs<ExtArgs>
    Schedules?: boolean | Lead$SchedulesArgs<ExtArgs>
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    LostedReason?: boolean | Lead$LostedReasonArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customer?: boolean | Lead$CustomerArgs<ExtArgs>
    Broker?: boolean | Lead$BrokerArgs<ExtArgs>
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    LostedReason?: boolean | Lead$LostedReasonArgs<ExtArgs>
  }
  export type LeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customer?: boolean | Lead$CustomerArgs<ExtArgs>
    Broker?: boolean | Lead$BrokerArgs<ExtArgs>
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    LostedReason?: boolean | Lead$LostedReasonArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      Campaigns: Prisma.$LeadCampaignPayload<ExtArgs>[]
      Customer: Prisma.$CustomerPayload<ExtArgs> | null
      Broker: Prisma.$UserPayload<ExtArgs> | null
      Tags: Prisma.$LeadTagPayload<ExtArgs>[]
      Documents: Prisma.$LeadDocumentPayload<ExtArgs>[]
      Comments: Prisma.$LeadCommentPayload<ExtArgs>[]
      Metadata: Prisma.$LeadMetadataPayload<ExtArgs>[]
      Chats: Prisma.$LeadChatPayload<ExtArgs>[]
      Schedules: Prisma.$SchedulePayload<ExtArgs>[]
      Lane: Prisma.$LanePayload<ExtArgs>
      LostedReason: Prisma.$LeadLostReasonPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      customerId: string
      userId: string | null
      laneId: number
      value: number
      status: $Enums.LeadStatus
      lostedLeadReasonId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads and returns the data updated in the database.
     * @param {LeadUpdateManyAndReturnArgs} args - Arguments to update many Leads.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Campaigns<T extends Lead$CampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$CampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Customer<T extends Lead$CustomerArgs<ExtArgs> = {}>(args?: Subset<T, Lead$CustomerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Broker<T extends Lead$BrokerArgs<ExtArgs> = {}>(args?: Subset<T, Lead$BrokerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Tags<T extends Lead$TagsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$TagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Documents<T extends Lead$DocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$DocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Comments<T extends Lead$CommentsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$CommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Metadata<T extends Lead$MetadataArgs<ExtArgs> = {}>(args?: Subset<T, Lead$MetadataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Chats<T extends Lead$ChatsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$ChatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Schedules<T extends Lead$SchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Lead$SchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Lane<T extends LaneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaneDefaultArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    LostedReason<T extends Lead$LostedReasonArgs<ExtArgs> = {}>(args?: Subset<T, Lead$LostedReasonArgs<ExtArgs>>): Prisma__LeadLostReasonClient<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly title: FieldRef<"Lead", 'String'>
    readonly customerId: FieldRef<"Lead", 'String'>
    readonly userId: FieldRef<"Lead", 'String'>
    readonly laneId: FieldRef<"Lead", 'Int'>
    readonly value: FieldRef<"Lead", 'Int'>
    readonly status: FieldRef<"Lead", 'LeadStatus'>
    readonly lostedLeadReasonId: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead updateManyAndReturn
   */
  export type LeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead.Campaigns
   */
  export type Lead$CampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    where?: LeadCampaignWhereInput
    orderBy?: LeadCampaignOrderByWithRelationInput | LeadCampaignOrderByWithRelationInput[]
    cursor?: LeadCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadCampaignScalarFieldEnum | LeadCampaignScalarFieldEnum[]
  }

  /**
   * Lead.Customer
   */
  export type Lead$CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Lead.Broker
   */
  export type Lead$BrokerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Lead.Tags
   */
  export type Lead$TagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    where?: LeadTagWhereInput
    orderBy?: LeadTagOrderByWithRelationInput | LeadTagOrderByWithRelationInput[]
    cursor?: LeadTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadTagScalarFieldEnum | LeadTagScalarFieldEnum[]
  }

  /**
   * Lead.Documents
   */
  export type Lead$DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    where?: LeadDocumentWhereInput
    orderBy?: LeadDocumentOrderByWithRelationInput | LeadDocumentOrderByWithRelationInput[]
    cursor?: LeadDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadDocumentScalarFieldEnum | LeadDocumentScalarFieldEnum[]
  }

  /**
   * Lead.Comments
   */
  export type Lead$CommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    where?: LeadCommentWhereInput
    orderBy?: LeadCommentOrderByWithRelationInput | LeadCommentOrderByWithRelationInput[]
    cursor?: LeadCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadCommentScalarFieldEnum | LeadCommentScalarFieldEnum[]
  }

  /**
   * Lead.Metadata
   */
  export type Lead$MetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
    where?: LeadMetadataWhereInput
    orderBy?: LeadMetadataOrderByWithRelationInput | LeadMetadataOrderByWithRelationInput[]
    cursor?: LeadMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadMetadataScalarFieldEnum | LeadMetadataScalarFieldEnum[]
  }

  /**
   * Lead.Chats
   */
  export type Lead$ChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
    where?: LeadChatWhereInput
    orderBy?: LeadChatOrderByWithRelationInput | LeadChatOrderByWithRelationInput[]
    cursor?: LeadChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadChatScalarFieldEnum | LeadChatScalarFieldEnum[]
  }

  /**
   * Lead.Schedules
   */
  export type Lead$SchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Lead.LostedReason
   */
  export type Lead$LostedReasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
    where?: LeadLostReasonWhereInput
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model LeadMetadata
   */

  export type AggregateLeadMetadata = {
    _count: LeadMetadataCountAggregateOutputType | null
    _min: LeadMetadataMinAggregateOutputType | null
    _max: LeadMetadataMaxAggregateOutputType | null
  }

  export type LeadMetadataMinAggregateOutputType = {
    id: string | null
    leadId: string | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadMetadataMaxAggregateOutputType = {
    id: string | null
    leadId: string | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadMetadataCountAggregateOutputType = {
    id: number
    leadId: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadMetadataMinAggregateInputType = {
    id?: true
    leadId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadMetadataMaxAggregateInputType = {
    id?: true
    leadId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadMetadataCountAggregateInputType = {
    id?: true
    leadId?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadMetadata to aggregate.
     */
    where?: LeadMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadMetadata to fetch.
     */
    orderBy?: LeadMetadataOrderByWithRelationInput | LeadMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadMetadata
    **/
    _count?: true | LeadMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMetadataMaxAggregateInputType
  }

  export type GetLeadMetadataAggregateType<T extends LeadMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadMetadata[P]>
      : GetScalarType<T[P], AggregateLeadMetadata[P]>
  }




  export type LeadMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadMetadataWhereInput
    orderBy?: LeadMetadataOrderByWithAggregationInput | LeadMetadataOrderByWithAggregationInput[]
    by: LeadMetadataScalarFieldEnum[] | LeadMetadataScalarFieldEnum
    having?: LeadMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadMetadataCountAggregateInputType | true
    _min?: LeadMetadataMinAggregateInputType
    _max?: LeadMetadataMaxAggregateInputType
  }

  export type LeadMetadataGroupByOutputType = {
    id: string
    leadId: string
    key: string
    value: string
    createdAt: Date
    updatedAt: Date
    _count: LeadMetadataCountAggregateOutputType | null
    _min: LeadMetadataMinAggregateOutputType | null
    _max: LeadMetadataMaxAggregateOutputType | null
  }

  type GetLeadMetadataGroupByPayload<T extends LeadMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], LeadMetadataGroupByOutputType[P]>
        }
      >
    >


  export type LeadMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadMetadata"]>

  export type LeadMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadMetadata"]>

  export type LeadMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadMetadata"]>

  export type LeadMetadataSelectScalar = {
    id?: boolean
    leadId?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leadId" | "key" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["leadMetadata"]>
  export type LeadMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type LeadMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type LeadMetadataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }

  export type $LeadMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadMetadata"
    objects: {
      Lead: Prisma.$LeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leadId: string
      key: string
      value: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leadMetadata"]>
    composites: {}
  }

  type LeadMetadataGetPayload<S extends boolean | null | undefined | LeadMetadataDefaultArgs> = $Result.GetResult<Prisma.$LeadMetadataPayload, S>

  type LeadMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadMetadataCountAggregateInputType | true
    }

  export interface LeadMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadMetadata'], meta: { name: 'LeadMetadata' } }
    /**
     * Find zero or one LeadMetadata that matches the filter.
     * @param {LeadMetadataFindUniqueArgs} args - Arguments to find a LeadMetadata
     * @example
     * // Get one LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadMetadataFindUniqueArgs>(args: SelectSubset<T, LeadMetadataFindUniqueArgs<ExtArgs>>): Prisma__LeadMetadataClient<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadMetadataFindUniqueOrThrowArgs} args - Arguments to find a LeadMetadata
     * @example
     * // Get one LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadMetadataClient<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadMetadataFindFirstArgs} args - Arguments to find a LeadMetadata
     * @example
     * // Get one LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadMetadataFindFirstArgs>(args?: SelectSubset<T, LeadMetadataFindFirstArgs<ExtArgs>>): Prisma__LeadMetadataClient<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadMetadataFindFirstOrThrowArgs} args - Arguments to find a LeadMetadata
     * @example
     * // Get one LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadMetadataClient<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.findMany()
     * 
     * // Get first 10 LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadMetadataWithIdOnly = await prisma.leadMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadMetadataFindManyArgs>(args?: SelectSubset<T, LeadMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadMetadata.
     * @param {LeadMetadataCreateArgs} args - Arguments to create a LeadMetadata.
     * @example
     * // Create one LeadMetadata
     * const LeadMetadata = await prisma.leadMetadata.create({
     *   data: {
     *     // ... data to create a LeadMetadata
     *   }
     * })
     * 
     */
    create<T extends LeadMetadataCreateArgs>(args: SelectSubset<T, LeadMetadataCreateArgs<ExtArgs>>): Prisma__LeadMetadataClient<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadMetadata.
     * @param {LeadMetadataCreateManyArgs} args - Arguments to create many LeadMetadata.
     * @example
     * // Create many LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadMetadataCreateManyArgs>(args?: SelectSubset<T, LeadMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadMetadata and returns the data saved in the database.
     * @param {LeadMetadataCreateManyAndReturnArgs} args - Arguments to create many LeadMetadata.
     * @example
     * // Create many LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadMetadata and only return the `id`
     * const leadMetadataWithIdOnly = await prisma.leadMetadata.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadMetadata.
     * @param {LeadMetadataDeleteArgs} args - Arguments to delete one LeadMetadata.
     * @example
     * // Delete one LeadMetadata
     * const LeadMetadata = await prisma.leadMetadata.delete({
     *   where: {
     *     // ... filter to delete one LeadMetadata
     *   }
     * })
     * 
     */
    delete<T extends LeadMetadataDeleteArgs>(args: SelectSubset<T, LeadMetadataDeleteArgs<ExtArgs>>): Prisma__LeadMetadataClient<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadMetadata.
     * @param {LeadMetadataUpdateArgs} args - Arguments to update one LeadMetadata.
     * @example
     * // Update one LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadMetadataUpdateArgs>(args: SelectSubset<T, LeadMetadataUpdateArgs<ExtArgs>>): Prisma__LeadMetadataClient<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadMetadata.
     * @param {LeadMetadataDeleteManyArgs} args - Arguments to filter LeadMetadata to delete.
     * @example
     * // Delete a few LeadMetadata
     * const { count } = await prisma.leadMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadMetadataDeleteManyArgs>(args?: SelectSubset<T, LeadMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadMetadataUpdateManyArgs>(args: SelectSubset<T, LeadMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadMetadata and returns the data updated in the database.
     * @param {LeadMetadataUpdateManyAndReturnArgs} args - Arguments to update many LeadMetadata.
     * @example
     * // Update many LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadMetadata and only return the `id`
     * const leadMetadataWithIdOnly = await prisma.leadMetadata.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadMetadata.
     * @param {LeadMetadataUpsertArgs} args - Arguments to update or create a LeadMetadata.
     * @example
     * // Update or create a LeadMetadata
     * const leadMetadata = await prisma.leadMetadata.upsert({
     *   create: {
     *     // ... data to create a LeadMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadMetadata we want to update
     *   }
     * })
     */
    upsert<T extends LeadMetadataUpsertArgs>(args: SelectSubset<T, LeadMetadataUpsertArgs<ExtArgs>>): Prisma__LeadMetadataClient<$Result.GetResult<Prisma.$LeadMetadataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadMetadataCountArgs} args - Arguments to filter LeadMetadata to count.
     * @example
     * // Count the number of LeadMetadata
     * const count = await prisma.leadMetadata.count({
     *   where: {
     *     // ... the filter for the LeadMetadata we want to count
     *   }
     * })
    **/
    count<T extends LeadMetadataCountArgs>(
      args?: Subset<T, LeadMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadMetadataAggregateArgs>(args: Subset<T, LeadMetadataAggregateArgs>): Prisma.PrismaPromise<GetLeadMetadataAggregateType<T>>

    /**
     * Group by LeadMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadMetadataGroupByArgs['orderBy'] }
        : { orderBy?: LeadMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadMetadata model
   */
  readonly fields: LeadMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadMetadata model
   */
  interface LeadMetadataFieldRefs {
    readonly id: FieldRef<"LeadMetadata", 'String'>
    readonly leadId: FieldRef<"LeadMetadata", 'String'>
    readonly key: FieldRef<"LeadMetadata", 'String'>
    readonly value: FieldRef<"LeadMetadata", 'String'>
    readonly createdAt: FieldRef<"LeadMetadata", 'DateTime'>
    readonly updatedAt: FieldRef<"LeadMetadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeadMetadata findUnique
   */
  export type LeadMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
    /**
     * Filter, which LeadMetadata to fetch.
     */
    where: LeadMetadataWhereUniqueInput
  }

  /**
   * LeadMetadata findUniqueOrThrow
   */
  export type LeadMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
    /**
     * Filter, which LeadMetadata to fetch.
     */
    where: LeadMetadataWhereUniqueInput
  }

  /**
   * LeadMetadata findFirst
   */
  export type LeadMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
    /**
     * Filter, which LeadMetadata to fetch.
     */
    where?: LeadMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadMetadata to fetch.
     */
    orderBy?: LeadMetadataOrderByWithRelationInput | LeadMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadMetadata.
     */
    cursor?: LeadMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadMetadata.
     */
    distinct?: LeadMetadataScalarFieldEnum | LeadMetadataScalarFieldEnum[]
  }

  /**
   * LeadMetadata findFirstOrThrow
   */
  export type LeadMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
    /**
     * Filter, which LeadMetadata to fetch.
     */
    where?: LeadMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadMetadata to fetch.
     */
    orderBy?: LeadMetadataOrderByWithRelationInput | LeadMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadMetadata.
     */
    cursor?: LeadMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadMetadata.
     */
    distinct?: LeadMetadataScalarFieldEnum | LeadMetadataScalarFieldEnum[]
  }

  /**
   * LeadMetadata findMany
   */
  export type LeadMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
    /**
     * Filter, which LeadMetadata to fetch.
     */
    where?: LeadMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadMetadata to fetch.
     */
    orderBy?: LeadMetadataOrderByWithRelationInput | LeadMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadMetadata.
     */
    cursor?: LeadMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadMetadata.
     */
    skip?: number
    distinct?: LeadMetadataScalarFieldEnum | LeadMetadataScalarFieldEnum[]
  }

  /**
   * LeadMetadata create
   */
  export type LeadMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadMetadata.
     */
    data: XOR<LeadMetadataCreateInput, LeadMetadataUncheckedCreateInput>
  }

  /**
   * LeadMetadata createMany
   */
  export type LeadMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadMetadata.
     */
    data: LeadMetadataCreateManyInput | LeadMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadMetadata createManyAndReturn
   */
  export type LeadMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many LeadMetadata.
     */
    data: LeadMetadataCreateManyInput | LeadMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadMetadata update
   */
  export type LeadMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadMetadata.
     */
    data: XOR<LeadMetadataUpdateInput, LeadMetadataUncheckedUpdateInput>
    /**
     * Choose, which LeadMetadata to update.
     */
    where: LeadMetadataWhereUniqueInput
  }

  /**
   * LeadMetadata updateMany
   */
  export type LeadMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadMetadata.
     */
    data: XOR<LeadMetadataUpdateManyMutationInput, LeadMetadataUncheckedUpdateManyInput>
    /**
     * Filter which LeadMetadata to update
     */
    where?: LeadMetadataWhereInput
    /**
     * Limit how many LeadMetadata to update.
     */
    limit?: number
  }

  /**
   * LeadMetadata updateManyAndReturn
   */
  export type LeadMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * The data used to update LeadMetadata.
     */
    data: XOR<LeadMetadataUpdateManyMutationInput, LeadMetadataUncheckedUpdateManyInput>
    /**
     * Filter which LeadMetadata to update
     */
    where?: LeadMetadataWhereInput
    /**
     * Limit how many LeadMetadata to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadMetadata upsert
   */
  export type LeadMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadMetadata to update in case it exists.
     */
    where: LeadMetadataWhereUniqueInput
    /**
     * In case the LeadMetadata found by the `where` argument doesn't exist, create a new LeadMetadata with this data.
     */
    create: XOR<LeadMetadataCreateInput, LeadMetadataUncheckedCreateInput>
    /**
     * In case the LeadMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadMetadataUpdateInput, LeadMetadataUncheckedUpdateInput>
  }

  /**
   * LeadMetadata delete
   */
  export type LeadMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
    /**
     * Filter which LeadMetadata to delete.
     */
    where: LeadMetadataWhereUniqueInput
  }

  /**
   * LeadMetadata deleteMany
   */
  export type LeadMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadMetadata to delete
     */
    where?: LeadMetadataWhereInput
    /**
     * Limit how many LeadMetadata to delete.
     */
    limit?: number
  }

  /**
   * LeadMetadata without action
   */
  export type LeadMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadMetadata
     */
    select?: LeadMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadMetadata
     */
    omit?: LeadMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadMetadataInclude<ExtArgs> | null
  }


  /**
   * Model LeadLostReason
   */

  export type AggregateLeadLostReason = {
    _count: LeadLostReasonCountAggregateOutputType | null
    _min: LeadLostReasonMinAggregateOutputType | null
    _max: LeadLostReasonMaxAggregateOutputType | null
  }

  export type LeadLostReasonMinAggregateOutputType = {
    id: string | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadLostReasonMaxAggregateOutputType = {
    id: string | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadLostReasonCountAggregateOutputType = {
    id: number
    reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadLostReasonMinAggregateInputType = {
    id?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadLostReasonMaxAggregateInputType = {
    id?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadLostReasonCountAggregateInputType = {
    id?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadLostReasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadLostReason to aggregate.
     */
    where?: LeadLostReasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadLostReasons to fetch.
     */
    orderBy?: LeadLostReasonOrderByWithRelationInput | LeadLostReasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadLostReasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadLostReasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadLostReasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadLostReasons
    **/
    _count?: true | LeadLostReasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadLostReasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadLostReasonMaxAggregateInputType
  }

  export type GetLeadLostReasonAggregateType<T extends LeadLostReasonAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadLostReason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadLostReason[P]>
      : GetScalarType<T[P], AggregateLeadLostReason[P]>
  }




  export type LeadLostReasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadLostReasonWhereInput
    orderBy?: LeadLostReasonOrderByWithAggregationInput | LeadLostReasonOrderByWithAggregationInput[]
    by: LeadLostReasonScalarFieldEnum[] | LeadLostReasonScalarFieldEnum
    having?: LeadLostReasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadLostReasonCountAggregateInputType | true
    _min?: LeadLostReasonMinAggregateInputType
    _max?: LeadLostReasonMaxAggregateInputType
  }

  export type LeadLostReasonGroupByOutputType = {
    id: string
    reason: string
    createdAt: Date
    updatedAt: Date
    _count: LeadLostReasonCountAggregateOutputType | null
    _min: LeadLostReasonMinAggregateOutputType | null
    _max: LeadLostReasonMaxAggregateOutputType | null
  }

  type GetLeadLostReasonGroupByPayload<T extends LeadLostReasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadLostReasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadLostReasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadLostReasonGroupByOutputType[P]>
            : GetScalarType<T[P], LeadLostReasonGroupByOutputType[P]>
        }
      >
    >


  export type LeadLostReasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Leads?: boolean | LeadLostReason$LeadsArgs<ExtArgs>
    _count?: boolean | LeadLostReasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadLostReason"]>

  export type LeadLostReasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["leadLostReason"]>

  export type LeadLostReasonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["leadLostReason"]>

  export type LeadLostReasonSelectScalar = {
    id?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadLostReasonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reason" | "createdAt" | "updatedAt", ExtArgs["result"]["leadLostReason"]>
  export type LeadLostReasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Leads?: boolean | LeadLostReason$LeadsArgs<ExtArgs>
    _count?: boolean | LeadLostReasonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadLostReasonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LeadLostReasonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LeadLostReasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadLostReason"
    objects: {
      Leads: Prisma.$LeadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reason: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leadLostReason"]>
    composites: {}
  }

  type LeadLostReasonGetPayload<S extends boolean | null | undefined | LeadLostReasonDefaultArgs> = $Result.GetResult<Prisma.$LeadLostReasonPayload, S>

  type LeadLostReasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadLostReasonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadLostReasonCountAggregateInputType | true
    }

  export interface LeadLostReasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadLostReason'], meta: { name: 'LeadLostReason' } }
    /**
     * Find zero or one LeadLostReason that matches the filter.
     * @param {LeadLostReasonFindUniqueArgs} args - Arguments to find a LeadLostReason
     * @example
     * // Get one LeadLostReason
     * const leadLostReason = await prisma.leadLostReason.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadLostReasonFindUniqueArgs>(args: SelectSubset<T, LeadLostReasonFindUniqueArgs<ExtArgs>>): Prisma__LeadLostReasonClient<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadLostReason that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadLostReasonFindUniqueOrThrowArgs} args - Arguments to find a LeadLostReason
     * @example
     * // Get one LeadLostReason
     * const leadLostReason = await prisma.leadLostReason.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadLostReasonFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadLostReasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadLostReasonClient<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadLostReason that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadLostReasonFindFirstArgs} args - Arguments to find a LeadLostReason
     * @example
     * // Get one LeadLostReason
     * const leadLostReason = await prisma.leadLostReason.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadLostReasonFindFirstArgs>(args?: SelectSubset<T, LeadLostReasonFindFirstArgs<ExtArgs>>): Prisma__LeadLostReasonClient<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadLostReason that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadLostReasonFindFirstOrThrowArgs} args - Arguments to find a LeadLostReason
     * @example
     * // Get one LeadLostReason
     * const leadLostReason = await prisma.leadLostReason.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadLostReasonFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadLostReasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadLostReasonClient<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadLostReasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadLostReasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadLostReasons
     * const leadLostReasons = await prisma.leadLostReason.findMany()
     * 
     * // Get first 10 LeadLostReasons
     * const leadLostReasons = await prisma.leadLostReason.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadLostReasonWithIdOnly = await prisma.leadLostReason.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadLostReasonFindManyArgs>(args?: SelectSubset<T, LeadLostReasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadLostReason.
     * @param {LeadLostReasonCreateArgs} args - Arguments to create a LeadLostReason.
     * @example
     * // Create one LeadLostReason
     * const LeadLostReason = await prisma.leadLostReason.create({
     *   data: {
     *     // ... data to create a LeadLostReason
     *   }
     * })
     * 
     */
    create<T extends LeadLostReasonCreateArgs>(args: SelectSubset<T, LeadLostReasonCreateArgs<ExtArgs>>): Prisma__LeadLostReasonClient<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadLostReasons.
     * @param {LeadLostReasonCreateManyArgs} args - Arguments to create many LeadLostReasons.
     * @example
     * // Create many LeadLostReasons
     * const leadLostReason = await prisma.leadLostReason.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadLostReasonCreateManyArgs>(args?: SelectSubset<T, LeadLostReasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadLostReasons and returns the data saved in the database.
     * @param {LeadLostReasonCreateManyAndReturnArgs} args - Arguments to create many LeadLostReasons.
     * @example
     * // Create many LeadLostReasons
     * const leadLostReason = await prisma.leadLostReason.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadLostReasons and only return the `id`
     * const leadLostReasonWithIdOnly = await prisma.leadLostReason.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadLostReasonCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadLostReasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadLostReason.
     * @param {LeadLostReasonDeleteArgs} args - Arguments to delete one LeadLostReason.
     * @example
     * // Delete one LeadLostReason
     * const LeadLostReason = await prisma.leadLostReason.delete({
     *   where: {
     *     // ... filter to delete one LeadLostReason
     *   }
     * })
     * 
     */
    delete<T extends LeadLostReasonDeleteArgs>(args: SelectSubset<T, LeadLostReasonDeleteArgs<ExtArgs>>): Prisma__LeadLostReasonClient<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadLostReason.
     * @param {LeadLostReasonUpdateArgs} args - Arguments to update one LeadLostReason.
     * @example
     * // Update one LeadLostReason
     * const leadLostReason = await prisma.leadLostReason.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadLostReasonUpdateArgs>(args: SelectSubset<T, LeadLostReasonUpdateArgs<ExtArgs>>): Prisma__LeadLostReasonClient<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadLostReasons.
     * @param {LeadLostReasonDeleteManyArgs} args - Arguments to filter LeadLostReasons to delete.
     * @example
     * // Delete a few LeadLostReasons
     * const { count } = await prisma.leadLostReason.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadLostReasonDeleteManyArgs>(args?: SelectSubset<T, LeadLostReasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadLostReasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadLostReasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadLostReasons
     * const leadLostReason = await prisma.leadLostReason.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadLostReasonUpdateManyArgs>(args: SelectSubset<T, LeadLostReasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadLostReasons and returns the data updated in the database.
     * @param {LeadLostReasonUpdateManyAndReturnArgs} args - Arguments to update many LeadLostReasons.
     * @example
     * // Update many LeadLostReasons
     * const leadLostReason = await prisma.leadLostReason.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadLostReasons and only return the `id`
     * const leadLostReasonWithIdOnly = await prisma.leadLostReason.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadLostReasonUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadLostReasonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadLostReason.
     * @param {LeadLostReasonUpsertArgs} args - Arguments to update or create a LeadLostReason.
     * @example
     * // Update or create a LeadLostReason
     * const leadLostReason = await prisma.leadLostReason.upsert({
     *   create: {
     *     // ... data to create a LeadLostReason
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadLostReason we want to update
     *   }
     * })
     */
    upsert<T extends LeadLostReasonUpsertArgs>(args: SelectSubset<T, LeadLostReasonUpsertArgs<ExtArgs>>): Prisma__LeadLostReasonClient<$Result.GetResult<Prisma.$LeadLostReasonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadLostReasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadLostReasonCountArgs} args - Arguments to filter LeadLostReasons to count.
     * @example
     * // Count the number of LeadLostReasons
     * const count = await prisma.leadLostReason.count({
     *   where: {
     *     // ... the filter for the LeadLostReasons we want to count
     *   }
     * })
    **/
    count<T extends LeadLostReasonCountArgs>(
      args?: Subset<T, LeadLostReasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadLostReasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadLostReason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadLostReasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadLostReasonAggregateArgs>(args: Subset<T, LeadLostReasonAggregateArgs>): Prisma.PrismaPromise<GetLeadLostReasonAggregateType<T>>

    /**
     * Group by LeadLostReason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadLostReasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadLostReasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadLostReasonGroupByArgs['orderBy'] }
        : { orderBy?: LeadLostReasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadLostReasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadLostReasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadLostReason model
   */
  readonly fields: LeadLostReasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadLostReason.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadLostReasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Leads<T extends LeadLostReason$LeadsArgs<ExtArgs> = {}>(args?: Subset<T, LeadLostReason$LeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadLostReason model
   */
  interface LeadLostReasonFieldRefs {
    readonly id: FieldRef<"LeadLostReason", 'String'>
    readonly reason: FieldRef<"LeadLostReason", 'String'>
    readonly createdAt: FieldRef<"LeadLostReason", 'DateTime'>
    readonly updatedAt: FieldRef<"LeadLostReason", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeadLostReason findUnique
   */
  export type LeadLostReasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
    /**
     * Filter, which LeadLostReason to fetch.
     */
    where: LeadLostReasonWhereUniqueInput
  }

  /**
   * LeadLostReason findUniqueOrThrow
   */
  export type LeadLostReasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
    /**
     * Filter, which LeadLostReason to fetch.
     */
    where: LeadLostReasonWhereUniqueInput
  }

  /**
   * LeadLostReason findFirst
   */
  export type LeadLostReasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
    /**
     * Filter, which LeadLostReason to fetch.
     */
    where?: LeadLostReasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadLostReasons to fetch.
     */
    orderBy?: LeadLostReasonOrderByWithRelationInput | LeadLostReasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadLostReasons.
     */
    cursor?: LeadLostReasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadLostReasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadLostReasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadLostReasons.
     */
    distinct?: LeadLostReasonScalarFieldEnum | LeadLostReasonScalarFieldEnum[]
  }

  /**
   * LeadLostReason findFirstOrThrow
   */
  export type LeadLostReasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
    /**
     * Filter, which LeadLostReason to fetch.
     */
    where?: LeadLostReasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadLostReasons to fetch.
     */
    orderBy?: LeadLostReasonOrderByWithRelationInput | LeadLostReasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadLostReasons.
     */
    cursor?: LeadLostReasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadLostReasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadLostReasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadLostReasons.
     */
    distinct?: LeadLostReasonScalarFieldEnum | LeadLostReasonScalarFieldEnum[]
  }

  /**
   * LeadLostReason findMany
   */
  export type LeadLostReasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
    /**
     * Filter, which LeadLostReasons to fetch.
     */
    where?: LeadLostReasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadLostReasons to fetch.
     */
    orderBy?: LeadLostReasonOrderByWithRelationInput | LeadLostReasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadLostReasons.
     */
    cursor?: LeadLostReasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadLostReasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadLostReasons.
     */
    skip?: number
    distinct?: LeadLostReasonScalarFieldEnum | LeadLostReasonScalarFieldEnum[]
  }

  /**
   * LeadLostReason create
   */
  export type LeadLostReasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadLostReason.
     */
    data: XOR<LeadLostReasonCreateInput, LeadLostReasonUncheckedCreateInput>
  }

  /**
   * LeadLostReason createMany
   */
  export type LeadLostReasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadLostReasons.
     */
    data: LeadLostReasonCreateManyInput | LeadLostReasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadLostReason createManyAndReturn
   */
  export type LeadLostReasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * The data used to create many LeadLostReasons.
     */
    data: LeadLostReasonCreateManyInput | LeadLostReasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadLostReason update
   */
  export type LeadLostReasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadLostReason.
     */
    data: XOR<LeadLostReasonUpdateInput, LeadLostReasonUncheckedUpdateInput>
    /**
     * Choose, which LeadLostReason to update.
     */
    where: LeadLostReasonWhereUniqueInput
  }

  /**
   * LeadLostReason updateMany
   */
  export type LeadLostReasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadLostReasons.
     */
    data: XOR<LeadLostReasonUpdateManyMutationInput, LeadLostReasonUncheckedUpdateManyInput>
    /**
     * Filter which LeadLostReasons to update
     */
    where?: LeadLostReasonWhereInput
    /**
     * Limit how many LeadLostReasons to update.
     */
    limit?: number
  }

  /**
   * LeadLostReason updateManyAndReturn
   */
  export type LeadLostReasonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * The data used to update LeadLostReasons.
     */
    data: XOR<LeadLostReasonUpdateManyMutationInput, LeadLostReasonUncheckedUpdateManyInput>
    /**
     * Filter which LeadLostReasons to update
     */
    where?: LeadLostReasonWhereInput
    /**
     * Limit how many LeadLostReasons to update.
     */
    limit?: number
  }

  /**
   * LeadLostReason upsert
   */
  export type LeadLostReasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadLostReason to update in case it exists.
     */
    where: LeadLostReasonWhereUniqueInput
    /**
     * In case the LeadLostReason found by the `where` argument doesn't exist, create a new LeadLostReason with this data.
     */
    create: XOR<LeadLostReasonCreateInput, LeadLostReasonUncheckedCreateInput>
    /**
     * In case the LeadLostReason was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadLostReasonUpdateInput, LeadLostReasonUncheckedUpdateInput>
  }

  /**
   * LeadLostReason delete
   */
  export type LeadLostReasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
    /**
     * Filter which LeadLostReason to delete.
     */
    where: LeadLostReasonWhereUniqueInput
  }

  /**
   * LeadLostReason deleteMany
   */
  export type LeadLostReasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadLostReasons to delete
     */
    where?: LeadLostReasonWhereInput
    /**
     * Limit how many LeadLostReasons to delete.
     */
    limit?: number
  }

  /**
   * LeadLostReason.Leads
   */
  export type LeadLostReason$LeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * LeadLostReason without action
   */
  export type LeadLostReasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadLostReason
     */
    select?: LeadLostReasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadLostReason
     */
    omit?: LeadLostReasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadLostReasonInclude<ExtArgs> | null
  }


  /**
   * Model LeadComment
   */

  export type AggregateLeadComment = {
    _count: LeadCommentCountAggregateOutputType | null
    _min: LeadCommentMinAggregateOutputType | null
    _max: LeadCommentMaxAggregateOutputType | null
  }

  export type LeadCommentMinAggregateOutputType = {
    id: string | null
    leadId: string | null
    userId: string | null
    content: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadCommentMaxAggregateOutputType = {
    id: string | null
    leadId: string | null
    userId: string | null
    content: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadCommentCountAggregateOutputType = {
    id: number
    leadId: number
    userId: number
    content: number
    deleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadCommentMinAggregateInputType = {
    id?: true
    leadId?: true
    userId?: true
    content?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadCommentMaxAggregateInputType = {
    id?: true
    leadId?: true
    userId?: true
    content?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadCommentCountAggregateInputType = {
    id?: true
    leadId?: true
    userId?: true
    content?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadComment to aggregate.
     */
    where?: LeadCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadComments to fetch.
     */
    orderBy?: LeadCommentOrderByWithRelationInput | LeadCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadComments
    **/
    _count?: true | LeadCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadCommentMaxAggregateInputType
  }

  export type GetLeadCommentAggregateType<T extends LeadCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadComment[P]>
      : GetScalarType<T[P], AggregateLeadComment[P]>
  }




  export type LeadCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadCommentWhereInput
    orderBy?: LeadCommentOrderByWithAggregationInput | LeadCommentOrderByWithAggregationInput[]
    by: LeadCommentScalarFieldEnum[] | LeadCommentScalarFieldEnum
    having?: LeadCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCommentCountAggregateInputType | true
    _min?: LeadCommentMinAggregateInputType
    _max?: LeadCommentMaxAggregateInputType
  }

  export type LeadCommentGroupByOutputType = {
    id: string
    leadId: string
    userId: string
    content: string
    deleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: LeadCommentCountAggregateOutputType | null
    _min: LeadCommentMinAggregateOutputType | null
    _max: LeadCommentMaxAggregateOutputType | null
  }

  type GetLeadCommentGroupByPayload<T extends LeadCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadCommentGroupByOutputType[P]>
            : GetScalarType<T[P], LeadCommentGroupByOutputType[P]>
        }
      >
    >


  export type LeadCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    userId?: boolean
    content?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadComment"]>

  export type LeadCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    userId?: boolean
    content?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadComment"]>

  export type LeadCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    userId?: boolean
    content?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadComment"]>

  export type LeadCommentSelectScalar = {
    id?: boolean
    leadId?: boolean
    userId?: boolean
    content?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leadId" | "userId" | "content" | "deleted" | "createdAt" | "updatedAt", ExtArgs["result"]["leadComment"]>
  export type LeadCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type LeadCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type LeadCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }

  export type $LeadCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadComment"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Lead: Prisma.$LeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leadId: string
      userId: string
      content: string
      deleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leadComment"]>
    composites: {}
  }

  type LeadCommentGetPayload<S extends boolean | null | undefined | LeadCommentDefaultArgs> = $Result.GetResult<Prisma.$LeadCommentPayload, S>

  type LeadCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCommentCountAggregateInputType | true
    }

  export interface LeadCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadComment'], meta: { name: 'LeadComment' } }
    /**
     * Find zero or one LeadComment that matches the filter.
     * @param {LeadCommentFindUniqueArgs} args - Arguments to find a LeadComment
     * @example
     * // Get one LeadComment
     * const leadComment = await prisma.leadComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadCommentFindUniqueArgs>(args: SelectSubset<T, LeadCommentFindUniqueArgs<ExtArgs>>): Prisma__LeadCommentClient<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadCommentFindUniqueOrThrowArgs} args - Arguments to find a LeadComment
     * @example
     * // Get one LeadComment
     * const leadComment = await prisma.leadComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadCommentClient<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCommentFindFirstArgs} args - Arguments to find a LeadComment
     * @example
     * // Get one LeadComment
     * const leadComment = await prisma.leadComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadCommentFindFirstArgs>(args?: SelectSubset<T, LeadCommentFindFirstArgs<ExtArgs>>): Prisma__LeadCommentClient<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCommentFindFirstOrThrowArgs} args - Arguments to find a LeadComment
     * @example
     * // Get one LeadComment
     * const leadComment = await prisma.leadComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadCommentClient<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadComments
     * const leadComments = await prisma.leadComment.findMany()
     * 
     * // Get first 10 LeadComments
     * const leadComments = await prisma.leadComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadCommentWithIdOnly = await prisma.leadComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadCommentFindManyArgs>(args?: SelectSubset<T, LeadCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadComment.
     * @param {LeadCommentCreateArgs} args - Arguments to create a LeadComment.
     * @example
     * // Create one LeadComment
     * const LeadComment = await prisma.leadComment.create({
     *   data: {
     *     // ... data to create a LeadComment
     *   }
     * })
     * 
     */
    create<T extends LeadCommentCreateArgs>(args: SelectSubset<T, LeadCommentCreateArgs<ExtArgs>>): Prisma__LeadCommentClient<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadComments.
     * @param {LeadCommentCreateManyArgs} args - Arguments to create many LeadComments.
     * @example
     * // Create many LeadComments
     * const leadComment = await prisma.leadComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCommentCreateManyArgs>(args?: SelectSubset<T, LeadCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadComments and returns the data saved in the database.
     * @param {LeadCommentCreateManyAndReturnArgs} args - Arguments to create many LeadComments.
     * @example
     * // Create many LeadComments
     * const leadComment = await prisma.leadComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadComments and only return the `id`
     * const leadCommentWithIdOnly = await prisma.leadComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadComment.
     * @param {LeadCommentDeleteArgs} args - Arguments to delete one LeadComment.
     * @example
     * // Delete one LeadComment
     * const LeadComment = await prisma.leadComment.delete({
     *   where: {
     *     // ... filter to delete one LeadComment
     *   }
     * })
     * 
     */
    delete<T extends LeadCommentDeleteArgs>(args: SelectSubset<T, LeadCommentDeleteArgs<ExtArgs>>): Prisma__LeadCommentClient<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadComment.
     * @param {LeadCommentUpdateArgs} args - Arguments to update one LeadComment.
     * @example
     * // Update one LeadComment
     * const leadComment = await prisma.leadComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadCommentUpdateArgs>(args: SelectSubset<T, LeadCommentUpdateArgs<ExtArgs>>): Prisma__LeadCommentClient<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadComments.
     * @param {LeadCommentDeleteManyArgs} args - Arguments to filter LeadComments to delete.
     * @example
     * // Delete a few LeadComments
     * const { count } = await prisma.leadComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadCommentDeleteManyArgs>(args?: SelectSubset<T, LeadCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadComments
     * const leadComment = await prisma.leadComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadCommentUpdateManyArgs>(args: SelectSubset<T, LeadCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadComments and returns the data updated in the database.
     * @param {LeadCommentUpdateManyAndReturnArgs} args - Arguments to update many LeadComments.
     * @example
     * // Update many LeadComments
     * const leadComment = await prisma.leadComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadComments and only return the `id`
     * const leadCommentWithIdOnly = await prisma.leadComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadComment.
     * @param {LeadCommentUpsertArgs} args - Arguments to update or create a LeadComment.
     * @example
     * // Update or create a LeadComment
     * const leadComment = await prisma.leadComment.upsert({
     *   create: {
     *     // ... data to create a LeadComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadComment we want to update
     *   }
     * })
     */
    upsert<T extends LeadCommentUpsertArgs>(args: SelectSubset<T, LeadCommentUpsertArgs<ExtArgs>>): Prisma__LeadCommentClient<$Result.GetResult<Prisma.$LeadCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCommentCountArgs} args - Arguments to filter LeadComments to count.
     * @example
     * // Count the number of LeadComments
     * const count = await prisma.leadComment.count({
     *   where: {
     *     // ... the filter for the LeadComments we want to count
     *   }
     * })
    **/
    count<T extends LeadCommentCountArgs>(
      args?: Subset<T, LeadCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadCommentAggregateArgs>(args: Subset<T, LeadCommentAggregateArgs>): Prisma.PrismaPromise<GetLeadCommentAggregateType<T>>

    /**
     * Group by LeadComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadCommentGroupByArgs['orderBy'] }
        : { orderBy?: LeadCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadComment model
   */
  readonly fields: LeadCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadComment model
   */
  interface LeadCommentFieldRefs {
    readonly id: FieldRef<"LeadComment", 'String'>
    readonly leadId: FieldRef<"LeadComment", 'String'>
    readonly userId: FieldRef<"LeadComment", 'String'>
    readonly content: FieldRef<"LeadComment", 'String'>
    readonly deleted: FieldRef<"LeadComment", 'Boolean'>
    readonly createdAt: FieldRef<"LeadComment", 'DateTime'>
    readonly updatedAt: FieldRef<"LeadComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeadComment findUnique
   */
  export type LeadCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    /**
     * Filter, which LeadComment to fetch.
     */
    where: LeadCommentWhereUniqueInput
  }

  /**
   * LeadComment findUniqueOrThrow
   */
  export type LeadCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    /**
     * Filter, which LeadComment to fetch.
     */
    where: LeadCommentWhereUniqueInput
  }

  /**
   * LeadComment findFirst
   */
  export type LeadCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    /**
     * Filter, which LeadComment to fetch.
     */
    where?: LeadCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadComments to fetch.
     */
    orderBy?: LeadCommentOrderByWithRelationInput | LeadCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadComments.
     */
    cursor?: LeadCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadComments.
     */
    distinct?: LeadCommentScalarFieldEnum | LeadCommentScalarFieldEnum[]
  }

  /**
   * LeadComment findFirstOrThrow
   */
  export type LeadCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    /**
     * Filter, which LeadComment to fetch.
     */
    where?: LeadCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadComments to fetch.
     */
    orderBy?: LeadCommentOrderByWithRelationInput | LeadCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadComments.
     */
    cursor?: LeadCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadComments.
     */
    distinct?: LeadCommentScalarFieldEnum | LeadCommentScalarFieldEnum[]
  }

  /**
   * LeadComment findMany
   */
  export type LeadCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    /**
     * Filter, which LeadComments to fetch.
     */
    where?: LeadCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadComments to fetch.
     */
    orderBy?: LeadCommentOrderByWithRelationInput | LeadCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadComments.
     */
    cursor?: LeadCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadComments.
     */
    skip?: number
    distinct?: LeadCommentScalarFieldEnum | LeadCommentScalarFieldEnum[]
  }

  /**
   * LeadComment create
   */
  export type LeadCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadComment.
     */
    data: XOR<LeadCommentCreateInput, LeadCommentUncheckedCreateInput>
  }

  /**
   * LeadComment createMany
   */
  export type LeadCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadComments.
     */
    data: LeadCommentCreateManyInput | LeadCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadComment createManyAndReturn
   */
  export type LeadCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * The data used to create many LeadComments.
     */
    data: LeadCommentCreateManyInput | LeadCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadComment update
   */
  export type LeadCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadComment.
     */
    data: XOR<LeadCommentUpdateInput, LeadCommentUncheckedUpdateInput>
    /**
     * Choose, which LeadComment to update.
     */
    where: LeadCommentWhereUniqueInput
  }

  /**
   * LeadComment updateMany
   */
  export type LeadCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadComments.
     */
    data: XOR<LeadCommentUpdateManyMutationInput, LeadCommentUncheckedUpdateManyInput>
    /**
     * Filter which LeadComments to update
     */
    where?: LeadCommentWhereInput
    /**
     * Limit how many LeadComments to update.
     */
    limit?: number
  }

  /**
   * LeadComment updateManyAndReturn
   */
  export type LeadCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * The data used to update LeadComments.
     */
    data: XOR<LeadCommentUpdateManyMutationInput, LeadCommentUncheckedUpdateManyInput>
    /**
     * Filter which LeadComments to update
     */
    where?: LeadCommentWhereInput
    /**
     * Limit how many LeadComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadComment upsert
   */
  export type LeadCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadComment to update in case it exists.
     */
    where: LeadCommentWhereUniqueInput
    /**
     * In case the LeadComment found by the `where` argument doesn't exist, create a new LeadComment with this data.
     */
    create: XOR<LeadCommentCreateInput, LeadCommentUncheckedCreateInput>
    /**
     * In case the LeadComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadCommentUpdateInput, LeadCommentUncheckedUpdateInput>
  }

  /**
   * LeadComment delete
   */
  export type LeadCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
    /**
     * Filter which LeadComment to delete.
     */
    where: LeadCommentWhereUniqueInput
  }

  /**
   * LeadComment deleteMany
   */
  export type LeadCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadComments to delete
     */
    where?: LeadCommentWhereInput
    /**
     * Limit how many LeadComments to delete.
     */
    limit?: number
  }

  /**
   * LeadComment without action
   */
  export type LeadCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadComment
     */
    select?: LeadCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadComment
     */
    omit?: LeadCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCommentInclude<ExtArgs> | null
  }


  /**
   * Model LeadChat
   */

  export type AggregateLeadChat = {
    _count: LeadChatCountAggregateOutputType | null
    _min: LeadChatMinAggregateOutputType | null
    _max: LeadChatMaxAggregateOutputType | null
  }

  export type LeadChatMinAggregateOutputType = {
    leadId: string | null
    conversationId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadChatMaxAggregateOutputType = {
    leadId: string | null
    conversationId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadChatCountAggregateOutputType = {
    leadId: number
    conversationId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadChatMinAggregateInputType = {
    leadId?: true
    conversationId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadChatMaxAggregateInputType = {
    leadId?: true
    conversationId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadChatCountAggregateInputType = {
    leadId?: true
    conversationId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadChat to aggregate.
     */
    where?: LeadChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadChats to fetch.
     */
    orderBy?: LeadChatOrderByWithRelationInput | LeadChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadChats
    **/
    _count?: true | LeadChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadChatMaxAggregateInputType
  }

  export type GetLeadChatAggregateType<T extends LeadChatAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadChat[P]>
      : GetScalarType<T[P], AggregateLeadChat[P]>
  }




  export type LeadChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadChatWhereInput
    orderBy?: LeadChatOrderByWithAggregationInput | LeadChatOrderByWithAggregationInput[]
    by: LeadChatScalarFieldEnum[] | LeadChatScalarFieldEnum
    having?: LeadChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadChatCountAggregateInputType | true
    _min?: LeadChatMinAggregateInputType
    _max?: LeadChatMaxAggregateInputType
  }

  export type LeadChatGroupByOutputType = {
    leadId: string
    conversationId: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: LeadChatCountAggregateOutputType | null
    _min: LeadChatMinAggregateOutputType | null
    _max: LeadChatMaxAggregateOutputType | null
  }

  type GetLeadChatGroupByPayload<T extends LeadChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadChatGroupByOutputType[P]>
            : GetScalarType<T[P], LeadChatGroupByOutputType[P]>
        }
      >
    >


  export type LeadChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    conversationId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadChat"]>

  export type LeadChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    conversationId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadChat"]>

  export type LeadChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    conversationId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadChat"]>

  export type LeadChatSelectScalar = {
    leadId?: boolean
    conversationId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"leadId" | "conversationId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["leadChat"]>
  export type LeadChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type LeadChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }
  export type LeadChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
  }

  export type $LeadChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadChat"
    objects: {
      Lead: Prisma.$LeadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      leadId: string
      conversationId: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leadChat"]>
    composites: {}
  }

  type LeadChatGetPayload<S extends boolean | null | undefined | LeadChatDefaultArgs> = $Result.GetResult<Prisma.$LeadChatPayload, S>

  type LeadChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadChatCountAggregateInputType | true
    }

  export interface LeadChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadChat'], meta: { name: 'LeadChat' } }
    /**
     * Find zero or one LeadChat that matches the filter.
     * @param {LeadChatFindUniqueArgs} args - Arguments to find a LeadChat
     * @example
     * // Get one LeadChat
     * const leadChat = await prisma.leadChat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadChatFindUniqueArgs>(args: SelectSubset<T, LeadChatFindUniqueArgs<ExtArgs>>): Prisma__LeadChatClient<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadChat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadChatFindUniqueOrThrowArgs} args - Arguments to find a LeadChat
     * @example
     * // Get one LeadChat
     * const leadChat = await prisma.leadChat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadChatFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadChatClient<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadChat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadChatFindFirstArgs} args - Arguments to find a LeadChat
     * @example
     * // Get one LeadChat
     * const leadChat = await prisma.leadChat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadChatFindFirstArgs>(args?: SelectSubset<T, LeadChatFindFirstArgs<ExtArgs>>): Prisma__LeadChatClient<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadChat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadChatFindFirstOrThrowArgs} args - Arguments to find a LeadChat
     * @example
     * // Get one LeadChat
     * const leadChat = await prisma.leadChat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadChatFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadChatClient<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadChats
     * const leadChats = await prisma.leadChat.findMany()
     * 
     * // Get first 10 LeadChats
     * const leadChats = await prisma.leadChat.findMany({ take: 10 })
     * 
     * // Only select the `leadId`
     * const leadChatWithLeadIdOnly = await prisma.leadChat.findMany({ select: { leadId: true } })
     * 
     */
    findMany<T extends LeadChatFindManyArgs>(args?: SelectSubset<T, LeadChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadChat.
     * @param {LeadChatCreateArgs} args - Arguments to create a LeadChat.
     * @example
     * // Create one LeadChat
     * const LeadChat = await prisma.leadChat.create({
     *   data: {
     *     // ... data to create a LeadChat
     *   }
     * })
     * 
     */
    create<T extends LeadChatCreateArgs>(args: SelectSubset<T, LeadChatCreateArgs<ExtArgs>>): Prisma__LeadChatClient<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadChats.
     * @param {LeadChatCreateManyArgs} args - Arguments to create many LeadChats.
     * @example
     * // Create many LeadChats
     * const leadChat = await prisma.leadChat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadChatCreateManyArgs>(args?: SelectSubset<T, LeadChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadChats and returns the data saved in the database.
     * @param {LeadChatCreateManyAndReturnArgs} args - Arguments to create many LeadChats.
     * @example
     * // Create many LeadChats
     * const leadChat = await prisma.leadChat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadChats and only return the `leadId`
     * const leadChatWithLeadIdOnly = await prisma.leadChat.createManyAndReturn({
     *   select: { leadId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadChatCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadChat.
     * @param {LeadChatDeleteArgs} args - Arguments to delete one LeadChat.
     * @example
     * // Delete one LeadChat
     * const LeadChat = await prisma.leadChat.delete({
     *   where: {
     *     // ... filter to delete one LeadChat
     *   }
     * })
     * 
     */
    delete<T extends LeadChatDeleteArgs>(args: SelectSubset<T, LeadChatDeleteArgs<ExtArgs>>): Prisma__LeadChatClient<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadChat.
     * @param {LeadChatUpdateArgs} args - Arguments to update one LeadChat.
     * @example
     * // Update one LeadChat
     * const leadChat = await prisma.leadChat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadChatUpdateArgs>(args: SelectSubset<T, LeadChatUpdateArgs<ExtArgs>>): Prisma__LeadChatClient<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadChats.
     * @param {LeadChatDeleteManyArgs} args - Arguments to filter LeadChats to delete.
     * @example
     * // Delete a few LeadChats
     * const { count } = await prisma.leadChat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadChatDeleteManyArgs>(args?: SelectSubset<T, LeadChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadChats
     * const leadChat = await prisma.leadChat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadChatUpdateManyArgs>(args: SelectSubset<T, LeadChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadChats and returns the data updated in the database.
     * @param {LeadChatUpdateManyAndReturnArgs} args - Arguments to update many LeadChats.
     * @example
     * // Update many LeadChats
     * const leadChat = await prisma.leadChat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadChats and only return the `leadId`
     * const leadChatWithLeadIdOnly = await prisma.leadChat.updateManyAndReturn({
     *   select: { leadId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadChatUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadChat.
     * @param {LeadChatUpsertArgs} args - Arguments to update or create a LeadChat.
     * @example
     * // Update or create a LeadChat
     * const leadChat = await prisma.leadChat.upsert({
     *   create: {
     *     // ... data to create a LeadChat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadChat we want to update
     *   }
     * })
     */
    upsert<T extends LeadChatUpsertArgs>(args: SelectSubset<T, LeadChatUpsertArgs<ExtArgs>>): Prisma__LeadChatClient<$Result.GetResult<Prisma.$LeadChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadChatCountArgs} args - Arguments to filter LeadChats to count.
     * @example
     * // Count the number of LeadChats
     * const count = await prisma.leadChat.count({
     *   where: {
     *     // ... the filter for the LeadChats we want to count
     *   }
     * })
    **/
    count<T extends LeadChatCountArgs>(
      args?: Subset<T, LeadChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadChatAggregateArgs>(args: Subset<T, LeadChatAggregateArgs>): Prisma.PrismaPromise<GetLeadChatAggregateType<T>>

    /**
     * Group by LeadChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadChatGroupByArgs['orderBy'] }
        : { orderBy?: LeadChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadChat model
   */
  readonly fields: LeadChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadChat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadChat model
   */
  interface LeadChatFieldRefs {
    readonly leadId: FieldRef<"LeadChat", 'String'>
    readonly conversationId: FieldRef<"LeadChat", 'String'>
    readonly status: FieldRef<"LeadChat", 'String'>
    readonly createdAt: FieldRef<"LeadChat", 'DateTime'>
    readonly updatedAt: FieldRef<"LeadChat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeadChat findUnique
   */
  export type LeadChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
    /**
     * Filter, which LeadChat to fetch.
     */
    where: LeadChatWhereUniqueInput
  }

  /**
   * LeadChat findUniqueOrThrow
   */
  export type LeadChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
    /**
     * Filter, which LeadChat to fetch.
     */
    where: LeadChatWhereUniqueInput
  }

  /**
   * LeadChat findFirst
   */
  export type LeadChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
    /**
     * Filter, which LeadChat to fetch.
     */
    where?: LeadChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadChats to fetch.
     */
    orderBy?: LeadChatOrderByWithRelationInput | LeadChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadChats.
     */
    cursor?: LeadChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadChats.
     */
    distinct?: LeadChatScalarFieldEnum | LeadChatScalarFieldEnum[]
  }

  /**
   * LeadChat findFirstOrThrow
   */
  export type LeadChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
    /**
     * Filter, which LeadChat to fetch.
     */
    where?: LeadChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadChats to fetch.
     */
    orderBy?: LeadChatOrderByWithRelationInput | LeadChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadChats.
     */
    cursor?: LeadChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadChats.
     */
    distinct?: LeadChatScalarFieldEnum | LeadChatScalarFieldEnum[]
  }

  /**
   * LeadChat findMany
   */
  export type LeadChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
    /**
     * Filter, which LeadChats to fetch.
     */
    where?: LeadChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadChats to fetch.
     */
    orderBy?: LeadChatOrderByWithRelationInput | LeadChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadChats.
     */
    cursor?: LeadChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadChats.
     */
    skip?: number
    distinct?: LeadChatScalarFieldEnum | LeadChatScalarFieldEnum[]
  }

  /**
   * LeadChat create
   */
  export type LeadChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadChat.
     */
    data: XOR<LeadChatCreateInput, LeadChatUncheckedCreateInput>
  }

  /**
   * LeadChat createMany
   */
  export type LeadChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadChats.
     */
    data: LeadChatCreateManyInput | LeadChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadChat createManyAndReturn
   */
  export type LeadChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * The data used to create many LeadChats.
     */
    data: LeadChatCreateManyInput | LeadChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadChat update
   */
  export type LeadChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadChat.
     */
    data: XOR<LeadChatUpdateInput, LeadChatUncheckedUpdateInput>
    /**
     * Choose, which LeadChat to update.
     */
    where: LeadChatWhereUniqueInput
  }

  /**
   * LeadChat updateMany
   */
  export type LeadChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadChats.
     */
    data: XOR<LeadChatUpdateManyMutationInput, LeadChatUncheckedUpdateManyInput>
    /**
     * Filter which LeadChats to update
     */
    where?: LeadChatWhereInput
    /**
     * Limit how many LeadChats to update.
     */
    limit?: number
  }

  /**
   * LeadChat updateManyAndReturn
   */
  export type LeadChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * The data used to update LeadChats.
     */
    data: XOR<LeadChatUpdateManyMutationInput, LeadChatUncheckedUpdateManyInput>
    /**
     * Filter which LeadChats to update
     */
    where?: LeadChatWhereInput
    /**
     * Limit how many LeadChats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadChat upsert
   */
  export type LeadChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadChat to update in case it exists.
     */
    where: LeadChatWhereUniqueInput
    /**
     * In case the LeadChat found by the `where` argument doesn't exist, create a new LeadChat with this data.
     */
    create: XOR<LeadChatCreateInput, LeadChatUncheckedCreateInput>
    /**
     * In case the LeadChat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadChatUpdateInput, LeadChatUncheckedUpdateInput>
  }

  /**
   * LeadChat delete
   */
  export type LeadChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
    /**
     * Filter which LeadChat to delete.
     */
    where: LeadChatWhereUniqueInput
  }

  /**
   * LeadChat deleteMany
   */
  export type LeadChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadChats to delete
     */
    where?: LeadChatWhereInput
    /**
     * Limit how many LeadChats to delete.
     */
    limit?: number
  }

  /**
   * LeadChat without action
   */
  export type LeadChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadChat
     */
    select?: LeadChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadChat
     */
    omit?: LeadChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadChatInclude<ExtArgs> | null
  }


  /**
   * Model LeadDocument
   */

  export type AggregateLeadDocument = {
    _count: LeadDocumentCountAggregateOutputType | null
    _min: LeadDocumentMinAggregateOutputType | null
    _max: LeadDocumentMaxAggregateOutputType | null
  }

  export type LeadDocumentMinAggregateOutputType = {
    leadId: string | null
    name: string | null
    path: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadDocumentMaxAggregateOutputType = {
    leadId: string | null
    name: string | null
    path: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadDocumentCountAggregateOutputType = {
    leadId: number
    name: number
    path: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadDocumentMinAggregateInputType = {
    leadId?: true
    name?: true
    path?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadDocumentMaxAggregateInputType = {
    leadId?: true
    name?: true
    path?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadDocumentCountAggregateInputType = {
    leadId?: true
    name?: true
    path?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadDocument to aggregate.
     */
    where?: LeadDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadDocuments to fetch.
     */
    orderBy?: LeadDocumentOrderByWithRelationInput | LeadDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadDocuments
    **/
    _count?: true | LeadDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadDocumentMaxAggregateInputType
  }

  export type GetLeadDocumentAggregateType<T extends LeadDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadDocument[P]>
      : GetScalarType<T[P], AggregateLeadDocument[P]>
  }




  export type LeadDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadDocumentWhereInput
    orderBy?: LeadDocumentOrderByWithAggregationInput | LeadDocumentOrderByWithAggregationInput[]
    by: LeadDocumentScalarFieldEnum[] | LeadDocumentScalarFieldEnum
    having?: LeadDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadDocumentCountAggregateInputType | true
    _min?: LeadDocumentMinAggregateInputType
    _max?: LeadDocumentMaxAggregateInputType
  }

  export type LeadDocumentGroupByOutputType = {
    leadId: string
    name: string
    path: string
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeadDocumentCountAggregateOutputType | null
    _min: LeadDocumentMinAggregateOutputType | null
    _max: LeadDocumentMaxAggregateOutputType | null
  }

  type GetLeadDocumentGroupByPayload<T extends LeadDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], LeadDocumentGroupByOutputType[P]>
        }
      >
    >


  export type LeadDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    name?: boolean
    path?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    User?: boolean | LeadDocument$UserArgs<ExtArgs>
  }, ExtArgs["result"]["leadDocument"]>

  export type LeadDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    name?: boolean
    path?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    User?: boolean | LeadDocument$UserArgs<ExtArgs>
  }, ExtArgs["result"]["leadDocument"]>

  export type LeadDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    name?: boolean
    path?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    User?: boolean | LeadDocument$UserArgs<ExtArgs>
  }, ExtArgs["result"]["leadDocument"]>

  export type LeadDocumentSelectScalar = {
    leadId?: boolean
    name?: boolean
    path?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"leadId" | "name" | "path" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["leadDocument"]>
  export type LeadDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    User?: boolean | LeadDocument$UserArgs<ExtArgs>
  }
  export type LeadDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    User?: boolean | LeadDocument$UserArgs<ExtArgs>
  }
  export type LeadDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    User?: boolean | LeadDocument$UserArgs<ExtArgs>
  }

  export type $LeadDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadDocument"
    objects: {
      Lead: Prisma.$LeadPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      leadId: string
      name: string
      path: string
      userId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leadDocument"]>
    composites: {}
  }

  type LeadDocumentGetPayload<S extends boolean | null | undefined | LeadDocumentDefaultArgs> = $Result.GetResult<Prisma.$LeadDocumentPayload, S>

  type LeadDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadDocumentCountAggregateInputType | true
    }

  export interface LeadDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadDocument'], meta: { name: 'LeadDocument' } }
    /**
     * Find zero or one LeadDocument that matches the filter.
     * @param {LeadDocumentFindUniqueArgs} args - Arguments to find a LeadDocument
     * @example
     * // Get one LeadDocument
     * const leadDocument = await prisma.leadDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadDocumentFindUniqueArgs>(args: SelectSubset<T, LeadDocumentFindUniqueArgs<ExtArgs>>): Prisma__LeadDocumentClient<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadDocumentFindUniqueOrThrowArgs} args - Arguments to find a LeadDocument
     * @example
     * // Get one LeadDocument
     * const leadDocument = await prisma.leadDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadDocumentClient<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDocumentFindFirstArgs} args - Arguments to find a LeadDocument
     * @example
     * // Get one LeadDocument
     * const leadDocument = await prisma.leadDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadDocumentFindFirstArgs>(args?: SelectSubset<T, LeadDocumentFindFirstArgs<ExtArgs>>): Prisma__LeadDocumentClient<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDocumentFindFirstOrThrowArgs} args - Arguments to find a LeadDocument
     * @example
     * // Get one LeadDocument
     * const leadDocument = await prisma.leadDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadDocumentClient<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadDocuments
     * const leadDocuments = await prisma.leadDocument.findMany()
     * 
     * // Get first 10 LeadDocuments
     * const leadDocuments = await prisma.leadDocument.findMany({ take: 10 })
     * 
     * // Only select the `leadId`
     * const leadDocumentWithLeadIdOnly = await prisma.leadDocument.findMany({ select: { leadId: true } })
     * 
     */
    findMany<T extends LeadDocumentFindManyArgs>(args?: SelectSubset<T, LeadDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadDocument.
     * @param {LeadDocumentCreateArgs} args - Arguments to create a LeadDocument.
     * @example
     * // Create one LeadDocument
     * const LeadDocument = await prisma.leadDocument.create({
     *   data: {
     *     // ... data to create a LeadDocument
     *   }
     * })
     * 
     */
    create<T extends LeadDocumentCreateArgs>(args: SelectSubset<T, LeadDocumentCreateArgs<ExtArgs>>): Prisma__LeadDocumentClient<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadDocuments.
     * @param {LeadDocumentCreateManyArgs} args - Arguments to create many LeadDocuments.
     * @example
     * // Create many LeadDocuments
     * const leadDocument = await prisma.leadDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadDocumentCreateManyArgs>(args?: SelectSubset<T, LeadDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadDocuments and returns the data saved in the database.
     * @param {LeadDocumentCreateManyAndReturnArgs} args - Arguments to create many LeadDocuments.
     * @example
     * // Create many LeadDocuments
     * const leadDocument = await prisma.leadDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadDocuments and only return the `leadId`
     * const leadDocumentWithLeadIdOnly = await prisma.leadDocument.createManyAndReturn({
     *   select: { leadId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadDocument.
     * @param {LeadDocumentDeleteArgs} args - Arguments to delete one LeadDocument.
     * @example
     * // Delete one LeadDocument
     * const LeadDocument = await prisma.leadDocument.delete({
     *   where: {
     *     // ... filter to delete one LeadDocument
     *   }
     * })
     * 
     */
    delete<T extends LeadDocumentDeleteArgs>(args: SelectSubset<T, LeadDocumentDeleteArgs<ExtArgs>>): Prisma__LeadDocumentClient<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadDocument.
     * @param {LeadDocumentUpdateArgs} args - Arguments to update one LeadDocument.
     * @example
     * // Update one LeadDocument
     * const leadDocument = await prisma.leadDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadDocumentUpdateArgs>(args: SelectSubset<T, LeadDocumentUpdateArgs<ExtArgs>>): Prisma__LeadDocumentClient<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadDocuments.
     * @param {LeadDocumentDeleteManyArgs} args - Arguments to filter LeadDocuments to delete.
     * @example
     * // Delete a few LeadDocuments
     * const { count } = await prisma.leadDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDocumentDeleteManyArgs>(args?: SelectSubset<T, LeadDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadDocuments
     * const leadDocument = await prisma.leadDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadDocumentUpdateManyArgs>(args: SelectSubset<T, LeadDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadDocuments and returns the data updated in the database.
     * @param {LeadDocumentUpdateManyAndReturnArgs} args - Arguments to update many LeadDocuments.
     * @example
     * // Update many LeadDocuments
     * const leadDocument = await prisma.leadDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadDocuments and only return the `leadId`
     * const leadDocumentWithLeadIdOnly = await prisma.leadDocument.updateManyAndReturn({
     *   select: { leadId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadDocument.
     * @param {LeadDocumentUpsertArgs} args - Arguments to update or create a LeadDocument.
     * @example
     * // Update or create a LeadDocument
     * const leadDocument = await prisma.leadDocument.upsert({
     *   create: {
     *     // ... data to create a LeadDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadDocument we want to update
     *   }
     * })
     */
    upsert<T extends LeadDocumentUpsertArgs>(args: SelectSubset<T, LeadDocumentUpsertArgs<ExtArgs>>): Prisma__LeadDocumentClient<$Result.GetResult<Prisma.$LeadDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDocumentCountArgs} args - Arguments to filter LeadDocuments to count.
     * @example
     * // Count the number of LeadDocuments
     * const count = await prisma.leadDocument.count({
     *   where: {
     *     // ... the filter for the LeadDocuments we want to count
     *   }
     * })
    **/
    count<T extends LeadDocumentCountArgs>(
      args?: Subset<T, LeadDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadDocumentAggregateArgs>(args: Subset<T, LeadDocumentAggregateArgs>): Prisma.PrismaPromise<GetLeadDocumentAggregateType<T>>

    /**
     * Group by LeadDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadDocumentGroupByArgs['orderBy'] }
        : { orderBy?: LeadDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadDocument model
   */
  readonly fields: LeadDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends LeadDocument$UserArgs<ExtArgs> = {}>(args?: Subset<T, LeadDocument$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadDocument model
   */
  interface LeadDocumentFieldRefs {
    readonly leadId: FieldRef<"LeadDocument", 'String'>
    readonly name: FieldRef<"LeadDocument", 'String'>
    readonly path: FieldRef<"LeadDocument", 'String'>
    readonly userId: FieldRef<"LeadDocument", 'String'>
    readonly createdAt: FieldRef<"LeadDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"LeadDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeadDocument findUnique
   */
  export type LeadDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeadDocument to fetch.
     */
    where: LeadDocumentWhereUniqueInput
  }

  /**
   * LeadDocument findUniqueOrThrow
   */
  export type LeadDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeadDocument to fetch.
     */
    where: LeadDocumentWhereUniqueInput
  }

  /**
   * LeadDocument findFirst
   */
  export type LeadDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeadDocument to fetch.
     */
    where?: LeadDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadDocuments to fetch.
     */
    orderBy?: LeadDocumentOrderByWithRelationInput | LeadDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadDocuments.
     */
    cursor?: LeadDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadDocuments.
     */
    distinct?: LeadDocumentScalarFieldEnum | LeadDocumentScalarFieldEnum[]
  }

  /**
   * LeadDocument findFirstOrThrow
   */
  export type LeadDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeadDocument to fetch.
     */
    where?: LeadDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadDocuments to fetch.
     */
    orderBy?: LeadDocumentOrderByWithRelationInput | LeadDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadDocuments.
     */
    cursor?: LeadDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadDocuments.
     */
    distinct?: LeadDocumentScalarFieldEnum | LeadDocumentScalarFieldEnum[]
  }

  /**
   * LeadDocument findMany
   */
  export type LeadDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    /**
     * Filter, which LeadDocuments to fetch.
     */
    where?: LeadDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadDocuments to fetch.
     */
    orderBy?: LeadDocumentOrderByWithRelationInput | LeadDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadDocuments.
     */
    cursor?: LeadDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadDocuments.
     */
    skip?: number
    distinct?: LeadDocumentScalarFieldEnum | LeadDocumentScalarFieldEnum[]
  }

  /**
   * LeadDocument create
   */
  export type LeadDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadDocument.
     */
    data: XOR<LeadDocumentCreateInput, LeadDocumentUncheckedCreateInput>
  }

  /**
   * LeadDocument createMany
   */
  export type LeadDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadDocuments.
     */
    data: LeadDocumentCreateManyInput | LeadDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadDocument createManyAndReturn
   */
  export type LeadDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many LeadDocuments.
     */
    data: LeadDocumentCreateManyInput | LeadDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadDocument update
   */
  export type LeadDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadDocument.
     */
    data: XOR<LeadDocumentUpdateInput, LeadDocumentUncheckedUpdateInput>
    /**
     * Choose, which LeadDocument to update.
     */
    where: LeadDocumentWhereUniqueInput
  }

  /**
   * LeadDocument updateMany
   */
  export type LeadDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadDocuments.
     */
    data: XOR<LeadDocumentUpdateManyMutationInput, LeadDocumentUncheckedUpdateManyInput>
    /**
     * Filter which LeadDocuments to update
     */
    where?: LeadDocumentWhereInput
    /**
     * Limit how many LeadDocuments to update.
     */
    limit?: number
  }

  /**
   * LeadDocument updateManyAndReturn
   */
  export type LeadDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * The data used to update LeadDocuments.
     */
    data: XOR<LeadDocumentUpdateManyMutationInput, LeadDocumentUncheckedUpdateManyInput>
    /**
     * Filter which LeadDocuments to update
     */
    where?: LeadDocumentWhereInput
    /**
     * Limit how many LeadDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadDocument upsert
   */
  export type LeadDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadDocument to update in case it exists.
     */
    where: LeadDocumentWhereUniqueInput
    /**
     * In case the LeadDocument found by the `where` argument doesn't exist, create a new LeadDocument with this data.
     */
    create: XOR<LeadDocumentCreateInput, LeadDocumentUncheckedCreateInput>
    /**
     * In case the LeadDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadDocumentUpdateInput, LeadDocumentUncheckedUpdateInput>
  }

  /**
   * LeadDocument delete
   */
  export type LeadDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
    /**
     * Filter which LeadDocument to delete.
     */
    where: LeadDocumentWhereUniqueInput
  }

  /**
   * LeadDocument deleteMany
   */
  export type LeadDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadDocuments to delete
     */
    where?: LeadDocumentWhereInput
    /**
     * Limit how many LeadDocuments to delete.
     */
    limit?: number
  }

  /**
   * LeadDocument.User
   */
  export type LeadDocument$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LeadDocument without action
   */
  export type LeadDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadDocument
     */
    select?: LeadDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadDocument
     */
    omit?: LeadDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Lane
   */

  export type AggregateLane = {
    _count: LaneCountAggregateOutputType | null
    _avg: LaneAvgAggregateOutputType | null
    _sum: LaneSumAggregateOutputType | null
    _min: LaneMinAggregateOutputType | null
    _max: LaneMaxAggregateOutputType | null
  }

  export type LaneAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type LaneSumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type LaneMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    sortOrder: number | null
    principal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaneMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    sortOrder: number | null
    principal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaneCountAggregateOutputType = {
    id: number
    name: number
    color: number
    sortOrder: number
    principal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaneAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type LaneSumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type LaneMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    sortOrder?: true
    principal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaneMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    sortOrder?: true
    principal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaneCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    sortOrder?: true
    principal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lane to aggregate.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lanes
    **/
    _count?: true | LaneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaneMaxAggregateInputType
  }

  export type GetLaneAggregateType<T extends LaneAggregateArgs> = {
        [P in keyof T & keyof AggregateLane]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLane[P]>
      : GetScalarType<T[P], AggregateLane[P]>
  }




  export type LaneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaneWhereInput
    orderBy?: LaneOrderByWithAggregationInput | LaneOrderByWithAggregationInput[]
    by: LaneScalarFieldEnum[] | LaneScalarFieldEnum
    having?: LaneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaneCountAggregateInputType | true
    _avg?: LaneAvgAggregateInputType
    _sum?: LaneSumAggregateInputType
    _min?: LaneMinAggregateInputType
    _max?: LaneMaxAggregateInputType
  }

  export type LaneGroupByOutputType = {
    id: number
    name: string
    color: string
    sortOrder: number
    principal: boolean
    createdAt: Date
    updatedAt: Date
    _count: LaneCountAggregateOutputType | null
    _avg: LaneAvgAggregateOutputType | null
    _sum: LaneSumAggregateOutputType | null
    _min: LaneMinAggregateOutputType | null
    _max: LaneMaxAggregateOutputType | null
  }

  type GetLaneGroupByPayload<T extends LaneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaneGroupByOutputType[P]>
            : GetScalarType<T[P], LaneGroupByOutputType[P]>
        }
      >
    >


  export type LaneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    sortOrder?: boolean
    principal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Leads?: boolean | Lane$LeadsArgs<ExtArgs>
    _count?: boolean | LaneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lane"]>

  export type LaneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    sortOrder?: boolean
    principal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lane"]>

  export type LaneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    sortOrder?: boolean
    principal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lane"]>

  export type LaneSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    sortOrder?: boolean
    principal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LaneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "sortOrder" | "principal" | "createdAt" | "updatedAt", ExtArgs["result"]["lane"]>
  export type LaneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Leads?: boolean | Lane$LeadsArgs<ExtArgs>
    _count?: boolean | LaneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LaneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LaneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lane"
    objects: {
      Leads: Prisma.$LeadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color: string
      sortOrder: number
      principal: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lane"]>
    composites: {}
  }

  type LaneGetPayload<S extends boolean | null | undefined | LaneDefaultArgs> = $Result.GetResult<Prisma.$LanePayload, S>

  type LaneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaneCountAggregateInputType | true
    }

  export interface LaneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lane'], meta: { name: 'Lane' } }
    /**
     * Find zero or one Lane that matches the filter.
     * @param {LaneFindUniqueArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaneFindUniqueArgs>(args: SelectSubset<T, LaneFindUniqueArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lane that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaneFindUniqueOrThrowArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaneFindUniqueOrThrowArgs>(args: SelectSubset<T, LaneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lane that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindFirstArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaneFindFirstArgs>(args?: SelectSubset<T, LaneFindFirstArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lane that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindFirstOrThrowArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaneFindFirstOrThrowArgs>(args?: SelectSubset<T, LaneFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lanes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lanes
     * const lanes = await prisma.lane.findMany()
     * 
     * // Get first 10 Lanes
     * const lanes = await prisma.lane.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laneWithIdOnly = await prisma.lane.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaneFindManyArgs>(args?: SelectSubset<T, LaneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lane.
     * @param {LaneCreateArgs} args - Arguments to create a Lane.
     * @example
     * // Create one Lane
     * const Lane = await prisma.lane.create({
     *   data: {
     *     // ... data to create a Lane
     *   }
     * })
     * 
     */
    create<T extends LaneCreateArgs>(args: SelectSubset<T, LaneCreateArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lanes.
     * @param {LaneCreateManyArgs} args - Arguments to create many Lanes.
     * @example
     * // Create many Lanes
     * const lane = await prisma.lane.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaneCreateManyArgs>(args?: SelectSubset<T, LaneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lanes and returns the data saved in the database.
     * @param {LaneCreateManyAndReturnArgs} args - Arguments to create many Lanes.
     * @example
     * // Create many Lanes
     * const lane = await prisma.lane.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lanes and only return the `id`
     * const laneWithIdOnly = await prisma.lane.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaneCreateManyAndReturnArgs>(args?: SelectSubset<T, LaneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lane.
     * @param {LaneDeleteArgs} args - Arguments to delete one Lane.
     * @example
     * // Delete one Lane
     * const Lane = await prisma.lane.delete({
     *   where: {
     *     // ... filter to delete one Lane
     *   }
     * })
     * 
     */
    delete<T extends LaneDeleteArgs>(args: SelectSubset<T, LaneDeleteArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lane.
     * @param {LaneUpdateArgs} args - Arguments to update one Lane.
     * @example
     * // Update one Lane
     * const lane = await prisma.lane.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaneUpdateArgs>(args: SelectSubset<T, LaneUpdateArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lanes.
     * @param {LaneDeleteManyArgs} args - Arguments to filter Lanes to delete.
     * @example
     * // Delete a few Lanes
     * const { count } = await prisma.lane.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaneDeleteManyArgs>(args?: SelectSubset<T, LaneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lanes
     * const lane = await prisma.lane.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaneUpdateManyArgs>(args: SelectSubset<T, LaneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lanes and returns the data updated in the database.
     * @param {LaneUpdateManyAndReturnArgs} args - Arguments to update many Lanes.
     * @example
     * // Update many Lanes
     * const lane = await prisma.lane.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lanes and only return the `id`
     * const laneWithIdOnly = await prisma.lane.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LaneUpdateManyAndReturnArgs>(args: SelectSubset<T, LaneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lane.
     * @param {LaneUpsertArgs} args - Arguments to update or create a Lane.
     * @example
     * // Update or create a Lane
     * const lane = await prisma.lane.upsert({
     *   create: {
     *     // ... data to create a Lane
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lane we want to update
     *   }
     * })
     */
    upsert<T extends LaneUpsertArgs>(args: SelectSubset<T, LaneUpsertArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneCountArgs} args - Arguments to filter Lanes to count.
     * @example
     * // Count the number of Lanes
     * const count = await prisma.lane.count({
     *   where: {
     *     // ... the filter for the Lanes we want to count
     *   }
     * })
    **/
    count<T extends LaneCountArgs>(
      args?: Subset<T, LaneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaneAggregateArgs>(args: Subset<T, LaneAggregateArgs>): Prisma.PrismaPromise<GetLaneAggregateType<T>>

    /**
     * Group by Lane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaneGroupByArgs['orderBy'] }
        : { orderBy?: LaneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lane model
   */
  readonly fields: LaneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lane.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Leads<T extends Lane$LeadsArgs<ExtArgs> = {}>(args?: Subset<T, Lane$LeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lane model
   */
  interface LaneFieldRefs {
    readonly id: FieldRef<"Lane", 'Int'>
    readonly name: FieldRef<"Lane", 'String'>
    readonly color: FieldRef<"Lane", 'String'>
    readonly sortOrder: FieldRef<"Lane", 'Int'>
    readonly principal: FieldRef<"Lane", 'Boolean'>
    readonly createdAt: FieldRef<"Lane", 'DateTime'>
    readonly updatedAt: FieldRef<"Lane", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lane findUnique
   */
  export type LaneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane findUniqueOrThrow
   */
  export type LaneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane findFirst
   */
  export type LaneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lanes.
     */
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane findFirstOrThrow
   */
  export type LaneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lanes.
     */
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane findMany
   */
  export type LaneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lanes to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane create
   */
  export type LaneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The data needed to create a Lane.
     */
    data: XOR<LaneCreateInput, LaneUncheckedCreateInput>
  }

  /**
   * Lane createMany
   */
  export type LaneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lanes.
     */
    data: LaneCreateManyInput | LaneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lane createManyAndReturn
   */
  export type LaneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * The data used to create many Lanes.
     */
    data: LaneCreateManyInput | LaneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lane update
   */
  export type LaneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The data needed to update a Lane.
     */
    data: XOR<LaneUpdateInput, LaneUncheckedUpdateInput>
    /**
     * Choose, which Lane to update.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane updateMany
   */
  export type LaneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lanes.
     */
    data: XOR<LaneUpdateManyMutationInput, LaneUncheckedUpdateManyInput>
    /**
     * Filter which Lanes to update
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to update.
     */
    limit?: number
  }

  /**
   * Lane updateManyAndReturn
   */
  export type LaneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * The data used to update Lanes.
     */
    data: XOR<LaneUpdateManyMutationInput, LaneUncheckedUpdateManyInput>
    /**
     * Filter which Lanes to update
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to update.
     */
    limit?: number
  }

  /**
   * Lane upsert
   */
  export type LaneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The filter to search for the Lane to update in case it exists.
     */
    where: LaneWhereUniqueInput
    /**
     * In case the Lane found by the `where` argument doesn't exist, create a new Lane with this data.
     */
    create: XOR<LaneCreateInput, LaneUncheckedCreateInput>
    /**
     * In case the Lane was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaneUpdateInput, LaneUncheckedUpdateInput>
  }

  /**
   * Lane delete
   */
  export type LaneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter which Lane to delete.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane deleteMany
   */
  export type LaneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lanes to delete
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to delete.
     */
    limit?: number
  }

  /**
   * Lane.Leads
   */
  export type Lane$LeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lane without action
   */
  export type LaneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
  }


  /**
   * Model ConstructionCompany
   */

  export type AggregateConstructionCompany = {
    _count: ConstructionCompanyCountAggregateOutputType | null
    _min: ConstructionCompanyMinAggregateOutputType | null
    _max: ConstructionCompanyMaxAggregateOutputType | null
  }

  export type ConstructionCompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConstructionCompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConstructionCompanyCountAggregateOutputType = {
    id: number
    name: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConstructionCompanyMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConstructionCompanyMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConstructionCompanyCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConstructionCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionCompany to aggregate.
     */
    where?: ConstructionCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionCompanies to fetch.
     */
    orderBy?: ConstructionCompanyOrderByWithRelationInput | ConstructionCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConstructionCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConstructionCompanies
    **/
    _count?: true | ConstructionCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConstructionCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConstructionCompanyMaxAggregateInputType
  }

  export type GetConstructionCompanyAggregateType<T extends ConstructionCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateConstructionCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConstructionCompany[P]>
      : GetScalarType<T[P], AggregateConstructionCompany[P]>
  }




  export type ConstructionCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConstructionCompanyWhereInput
    orderBy?: ConstructionCompanyOrderByWithAggregationInput | ConstructionCompanyOrderByWithAggregationInput[]
    by: ConstructionCompanyScalarFieldEnum[] | ConstructionCompanyScalarFieldEnum
    having?: ConstructionCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConstructionCompanyCountAggregateInputType | true
    _min?: ConstructionCompanyMinAggregateInputType
    _max?: ConstructionCompanyMaxAggregateInputType
  }

  export type ConstructionCompanyGroupByOutputType = {
    id: string
    name: string
    email: string
    createdAt: Date
    updatedAt: Date
    _count: ConstructionCompanyCountAggregateOutputType | null
    _min: ConstructionCompanyMinAggregateOutputType | null
    _max: ConstructionCompanyMaxAggregateOutputType | null
  }

  type GetConstructionCompanyGroupByPayload<T extends ConstructionCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConstructionCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConstructionCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConstructionCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], ConstructionCompanyGroupByOutputType[P]>
        }
      >
    >


  export type ConstructionCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Projects?: boolean | ConstructionCompany$ProjectsArgs<ExtArgs>
    Contacts?: boolean | ConstructionCompany$ContactsArgs<ExtArgs>
    _count?: boolean | ConstructionCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constructionCompany"]>

  export type ConstructionCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["constructionCompany"]>

  export type ConstructionCompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["constructionCompany"]>

  export type ConstructionCompanySelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConstructionCompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["constructionCompany"]>
  export type ConstructionCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Projects?: boolean | ConstructionCompany$ProjectsArgs<ExtArgs>
    Contacts?: boolean | ConstructionCompany$ContactsArgs<ExtArgs>
    _count?: boolean | ConstructionCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConstructionCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ConstructionCompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConstructionCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConstructionCompany"
    objects: {
      Projects: Prisma.$ProjectPayload<ExtArgs>[]
      Contacts: Prisma.$ContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["constructionCompany"]>
    composites: {}
  }

  type ConstructionCompanyGetPayload<S extends boolean | null | undefined | ConstructionCompanyDefaultArgs> = $Result.GetResult<Prisma.$ConstructionCompanyPayload, S>

  type ConstructionCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConstructionCompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConstructionCompanyCountAggregateInputType | true
    }

  export interface ConstructionCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConstructionCompany'], meta: { name: 'ConstructionCompany' } }
    /**
     * Find zero or one ConstructionCompany that matches the filter.
     * @param {ConstructionCompanyFindUniqueArgs} args - Arguments to find a ConstructionCompany
     * @example
     * // Get one ConstructionCompany
     * const constructionCompany = await prisma.constructionCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConstructionCompanyFindUniqueArgs>(args: SelectSubset<T, ConstructionCompanyFindUniqueArgs<ExtArgs>>): Prisma__ConstructionCompanyClient<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConstructionCompany that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConstructionCompanyFindUniqueOrThrowArgs} args - Arguments to find a ConstructionCompany
     * @example
     * // Get one ConstructionCompany
     * const constructionCompany = await prisma.constructionCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConstructionCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, ConstructionCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConstructionCompanyClient<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConstructionCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionCompanyFindFirstArgs} args - Arguments to find a ConstructionCompany
     * @example
     * // Get one ConstructionCompany
     * const constructionCompany = await prisma.constructionCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConstructionCompanyFindFirstArgs>(args?: SelectSubset<T, ConstructionCompanyFindFirstArgs<ExtArgs>>): Prisma__ConstructionCompanyClient<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConstructionCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionCompanyFindFirstOrThrowArgs} args - Arguments to find a ConstructionCompany
     * @example
     * // Get one ConstructionCompany
     * const constructionCompany = await prisma.constructionCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConstructionCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, ConstructionCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConstructionCompanyClient<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConstructionCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConstructionCompanies
     * const constructionCompanies = await prisma.constructionCompany.findMany()
     * 
     * // Get first 10 ConstructionCompanies
     * const constructionCompanies = await prisma.constructionCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const constructionCompanyWithIdOnly = await prisma.constructionCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConstructionCompanyFindManyArgs>(args?: SelectSubset<T, ConstructionCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConstructionCompany.
     * @param {ConstructionCompanyCreateArgs} args - Arguments to create a ConstructionCompany.
     * @example
     * // Create one ConstructionCompany
     * const ConstructionCompany = await prisma.constructionCompany.create({
     *   data: {
     *     // ... data to create a ConstructionCompany
     *   }
     * })
     * 
     */
    create<T extends ConstructionCompanyCreateArgs>(args: SelectSubset<T, ConstructionCompanyCreateArgs<ExtArgs>>): Prisma__ConstructionCompanyClient<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConstructionCompanies.
     * @param {ConstructionCompanyCreateManyArgs} args - Arguments to create many ConstructionCompanies.
     * @example
     * // Create many ConstructionCompanies
     * const constructionCompany = await prisma.constructionCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConstructionCompanyCreateManyArgs>(args?: SelectSubset<T, ConstructionCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConstructionCompanies and returns the data saved in the database.
     * @param {ConstructionCompanyCreateManyAndReturnArgs} args - Arguments to create many ConstructionCompanies.
     * @example
     * // Create many ConstructionCompanies
     * const constructionCompany = await prisma.constructionCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConstructionCompanies and only return the `id`
     * const constructionCompanyWithIdOnly = await prisma.constructionCompany.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConstructionCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, ConstructionCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConstructionCompany.
     * @param {ConstructionCompanyDeleteArgs} args - Arguments to delete one ConstructionCompany.
     * @example
     * // Delete one ConstructionCompany
     * const ConstructionCompany = await prisma.constructionCompany.delete({
     *   where: {
     *     // ... filter to delete one ConstructionCompany
     *   }
     * })
     * 
     */
    delete<T extends ConstructionCompanyDeleteArgs>(args: SelectSubset<T, ConstructionCompanyDeleteArgs<ExtArgs>>): Prisma__ConstructionCompanyClient<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConstructionCompany.
     * @param {ConstructionCompanyUpdateArgs} args - Arguments to update one ConstructionCompany.
     * @example
     * // Update one ConstructionCompany
     * const constructionCompany = await prisma.constructionCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConstructionCompanyUpdateArgs>(args: SelectSubset<T, ConstructionCompanyUpdateArgs<ExtArgs>>): Prisma__ConstructionCompanyClient<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConstructionCompanies.
     * @param {ConstructionCompanyDeleteManyArgs} args - Arguments to filter ConstructionCompanies to delete.
     * @example
     * // Delete a few ConstructionCompanies
     * const { count } = await prisma.constructionCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConstructionCompanyDeleteManyArgs>(args?: SelectSubset<T, ConstructionCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConstructionCompanies
     * const constructionCompany = await prisma.constructionCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConstructionCompanyUpdateManyArgs>(args: SelectSubset<T, ConstructionCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConstructionCompanies and returns the data updated in the database.
     * @param {ConstructionCompanyUpdateManyAndReturnArgs} args - Arguments to update many ConstructionCompanies.
     * @example
     * // Update many ConstructionCompanies
     * const constructionCompany = await prisma.constructionCompany.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConstructionCompanies and only return the `id`
     * const constructionCompanyWithIdOnly = await prisma.constructionCompany.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConstructionCompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, ConstructionCompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConstructionCompany.
     * @param {ConstructionCompanyUpsertArgs} args - Arguments to update or create a ConstructionCompany.
     * @example
     * // Update or create a ConstructionCompany
     * const constructionCompany = await prisma.constructionCompany.upsert({
     *   create: {
     *     // ... data to create a ConstructionCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConstructionCompany we want to update
     *   }
     * })
     */
    upsert<T extends ConstructionCompanyUpsertArgs>(args: SelectSubset<T, ConstructionCompanyUpsertArgs<ExtArgs>>): Prisma__ConstructionCompanyClient<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConstructionCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionCompanyCountArgs} args - Arguments to filter ConstructionCompanies to count.
     * @example
     * // Count the number of ConstructionCompanies
     * const count = await prisma.constructionCompany.count({
     *   where: {
     *     // ... the filter for the ConstructionCompanies we want to count
     *   }
     * })
    **/
    count<T extends ConstructionCompanyCountArgs>(
      args?: Subset<T, ConstructionCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConstructionCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConstructionCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConstructionCompanyAggregateArgs>(args: Subset<T, ConstructionCompanyAggregateArgs>): Prisma.PrismaPromise<GetConstructionCompanyAggregateType<T>>

    /**
     * Group by ConstructionCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstructionCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConstructionCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConstructionCompanyGroupByArgs['orderBy'] }
        : { orderBy?: ConstructionCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConstructionCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConstructionCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConstructionCompany model
   */
  readonly fields: ConstructionCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConstructionCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConstructionCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Projects<T extends ConstructionCompany$ProjectsArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionCompany$ProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Contacts<T extends ConstructionCompany$ContactsArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionCompany$ContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConstructionCompany model
   */
  interface ConstructionCompanyFieldRefs {
    readonly id: FieldRef<"ConstructionCompany", 'String'>
    readonly name: FieldRef<"ConstructionCompany", 'String'>
    readonly email: FieldRef<"ConstructionCompany", 'String'>
    readonly createdAt: FieldRef<"ConstructionCompany", 'DateTime'>
    readonly updatedAt: FieldRef<"ConstructionCompany", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConstructionCompany findUnique
   */
  export type ConstructionCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionCompany to fetch.
     */
    where: ConstructionCompanyWhereUniqueInput
  }

  /**
   * ConstructionCompany findUniqueOrThrow
   */
  export type ConstructionCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionCompany to fetch.
     */
    where: ConstructionCompanyWhereUniqueInput
  }

  /**
   * ConstructionCompany findFirst
   */
  export type ConstructionCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionCompany to fetch.
     */
    where?: ConstructionCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionCompanies to fetch.
     */
    orderBy?: ConstructionCompanyOrderByWithRelationInput | ConstructionCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionCompanies.
     */
    cursor?: ConstructionCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionCompanies.
     */
    distinct?: ConstructionCompanyScalarFieldEnum | ConstructionCompanyScalarFieldEnum[]
  }

  /**
   * ConstructionCompany findFirstOrThrow
   */
  export type ConstructionCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionCompany to fetch.
     */
    where?: ConstructionCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionCompanies to fetch.
     */
    orderBy?: ConstructionCompanyOrderByWithRelationInput | ConstructionCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConstructionCompanies.
     */
    cursor?: ConstructionCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConstructionCompanies.
     */
    distinct?: ConstructionCompanyScalarFieldEnum | ConstructionCompanyScalarFieldEnum[]
  }

  /**
   * ConstructionCompany findMany
   */
  export type ConstructionCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ConstructionCompanies to fetch.
     */
    where?: ConstructionCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConstructionCompanies to fetch.
     */
    orderBy?: ConstructionCompanyOrderByWithRelationInput | ConstructionCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConstructionCompanies.
     */
    cursor?: ConstructionCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConstructionCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConstructionCompanies.
     */
    skip?: number
    distinct?: ConstructionCompanyScalarFieldEnum | ConstructionCompanyScalarFieldEnum[]
  }

  /**
   * ConstructionCompany create
   */
  export type ConstructionCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a ConstructionCompany.
     */
    data: XOR<ConstructionCompanyCreateInput, ConstructionCompanyUncheckedCreateInput>
  }

  /**
   * ConstructionCompany createMany
   */
  export type ConstructionCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConstructionCompanies.
     */
    data: ConstructionCompanyCreateManyInput | ConstructionCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionCompany createManyAndReturn
   */
  export type ConstructionCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * The data used to create many ConstructionCompanies.
     */
    data: ConstructionCompanyCreateManyInput | ConstructionCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConstructionCompany update
   */
  export type ConstructionCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a ConstructionCompany.
     */
    data: XOR<ConstructionCompanyUpdateInput, ConstructionCompanyUncheckedUpdateInput>
    /**
     * Choose, which ConstructionCompany to update.
     */
    where: ConstructionCompanyWhereUniqueInput
  }

  /**
   * ConstructionCompany updateMany
   */
  export type ConstructionCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConstructionCompanies.
     */
    data: XOR<ConstructionCompanyUpdateManyMutationInput, ConstructionCompanyUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionCompanies to update
     */
    where?: ConstructionCompanyWhereInput
    /**
     * Limit how many ConstructionCompanies to update.
     */
    limit?: number
  }

  /**
   * ConstructionCompany updateManyAndReturn
   */
  export type ConstructionCompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * The data used to update ConstructionCompanies.
     */
    data: XOR<ConstructionCompanyUpdateManyMutationInput, ConstructionCompanyUncheckedUpdateManyInput>
    /**
     * Filter which ConstructionCompanies to update
     */
    where?: ConstructionCompanyWhereInput
    /**
     * Limit how many ConstructionCompanies to update.
     */
    limit?: number
  }

  /**
   * ConstructionCompany upsert
   */
  export type ConstructionCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the ConstructionCompany to update in case it exists.
     */
    where: ConstructionCompanyWhereUniqueInput
    /**
     * In case the ConstructionCompany found by the `where` argument doesn't exist, create a new ConstructionCompany with this data.
     */
    create: XOR<ConstructionCompanyCreateInput, ConstructionCompanyUncheckedCreateInput>
    /**
     * In case the ConstructionCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConstructionCompanyUpdateInput, ConstructionCompanyUncheckedUpdateInput>
  }

  /**
   * ConstructionCompany delete
   */
  export type ConstructionCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionCompanyInclude<ExtArgs> | null
    /**
     * Filter which ConstructionCompany to delete.
     */
    where: ConstructionCompanyWhereUniqueInput
  }

  /**
   * ConstructionCompany deleteMany
   */
  export type ConstructionCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConstructionCompanies to delete
     */
    where?: ConstructionCompanyWhereInput
    /**
     * Limit how many ConstructionCompanies to delete.
     */
    limit?: number
  }

  /**
   * ConstructionCompany.Projects
   */
  export type ConstructionCompany$ProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * ConstructionCompany.Contacts
   */
  export type ConstructionCompany$ContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * ConstructionCompany without action
   */
  export type ConstructionCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConstructionCompany
     */
    select?: ConstructionCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConstructionCompany
     */
    omit?: ConstructionCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConstructionCompanyInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    title: string | null
    url: string | null
    constructionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    title: string | null
    url: string | null
    constructionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    title: number
    url: number
    constructionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    title?: true
    url?: true
    constructionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    title?: true
    url?: true
    constructionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    title?: true
    url?: true
    constructionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    title: string
    url: string
    constructionId: string
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    constructionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Campaigns?: boolean | Project$CampaignsArgs<ExtArgs>
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    constructionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    constructionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    title?: boolean
    url?: boolean
    constructionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "url" | "constructionId" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaigns?: boolean | Project$CampaignsArgs<ExtArgs>
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      Campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      ConstructionCompany: Prisma.$ConstructionCompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      url: string
      constructionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Campaigns<T extends Project$CampaignsArgs<ExtArgs> = {}>(args?: Subset<T, Project$CampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConstructionCompany<T extends ConstructionCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionCompanyDefaultArgs<ExtArgs>>): Prisma__ConstructionCompanyClient<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly title: FieldRef<"Project", 'String'>
    readonly url: FieldRef<"Project", 'String'>
    readonly constructionId: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.Campaigns
   */
  export type Project$CampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    title: string | null
    sourceId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    title: string | null
    sourceId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    title: number
    sourceId: number
    projectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignMinAggregateInputType = {
    id?: true
    title?: true
    sourceId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    title?: true
    sourceId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    title?: true
    sourceId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    title: string
    sourceId: string | null
    projectId: string
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    sourceId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Leads?: boolean | Campaign$LeadsArgs<ExtArgs>
    Source?: boolean | Campaign$SourceArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    sourceId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Source?: boolean | Campaign$SourceArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    sourceId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Source?: boolean | Campaign$SourceArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    title?: boolean
    sourceId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "sourceId" | "projectId" | "createdAt" | "updatedAt", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Leads?: boolean | Campaign$LeadsArgs<ExtArgs>
    Source?: boolean | Campaign$SourceArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Source?: boolean | Campaign$SourceArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Source?: boolean | Campaign$SourceArgs<ExtArgs>
    Project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      Leads: Prisma.$LeadCampaignPayload<ExtArgs>[]
      Source: Prisma.$CampaignSourcePayload<ExtArgs> | null
      Project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      sourceId: string | null
      projectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {CampaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Leads<T extends Campaign$LeadsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$LeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Source<T extends Campaign$SourceArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$SourceArgs<ExtArgs>>): Prisma__CampaignSourceClient<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly title: FieldRef<"Campaign", 'String'>
    readonly sourceId: FieldRef<"Campaign", 'String'>
    readonly projectId: FieldRef<"Campaign", 'String'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign updateManyAndReturn
   */
  export type CampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.Leads
   */
  export type Campaign$LeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    where?: LeadCampaignWhereInput
    orderBy?: LeadCampaignOrderByWithRelationInput | LeadCampaignOrderByWithRelationInput[]
    cursor?: LeadCampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadCampaignScalarFieldEnum | LeadCampaignScalarFieldEnum[]
  }

  /**
   * Campaign.Source
   */
  export type Campaign$SourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
    where?: CampaignSourceWhereInput
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model LeadCampaign
   */

  export type AggregateLeadCampaign = {
    _count: LeadCampaignCountAggregateOutputType | null
    _min: LeadCampaignMinAggregateOutputType | null
    _max: LeadCampaignMaxAggregateOutputType | null
  }

  export type LeadCampaignMinAggregateOutputType = {
    leadId: string | null
    campaignId: string | null
  }

  export type LeadCampaignMaxAggregateOutputType = {
    leadId: string | null
    campaignId: string | null
  }

  export type LeadCampaignCountAggregateOutputType = {
    leadId: number
    campaignId: number
    _all: number
  }


  export type LeadCampaignMinAggregateInputType = {
    leadId?: true
    campaignId?: true
  }

  export type LeadCampaignMaxAggregateInputType = {
    leadId?: true
    campaignId?: true
  }

  export type LeadCampaignCountAggregateInputType = {
    leadId?: true
    campaignId?: true
    _all?: true
  }

  export type LeadCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadCampaign to aggregate.
     */
    where?: LeadCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadCampaigns to fetch.
     */
    orderBy?: LeadCampaignOrderByWithRelationInput | LeadCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadCampaigns
    **/
    _count?: true | LeadCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadCampaignMaxAggregateInputType
  }

  export type GetLeadCampaignAggregateType<T extends LeadCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadCampaign[P]>
      : GetScalarType<T[P], AggregateLeadCampaign[P]>
  }




  export type LeadCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadCampaignWhereInput
    orderBy?: LeadCampaignOrderByWithAggregationInput | LeadCampaignOrderByWithAggregationInput[]
    by: LeadCampaignScalarFieldEnum[] | LeadCampaignScalarFieldEnum
    having?: LeadCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCampaignCountAggregateInputType | true
    _min?: LeadCampaignMinAggregateInputType
    _max?: LeadCampaignMaxAggregateInputType
  }

  export type LeadCampaignGroupByOutputType = {
    leadId: string
    campaignId: string
    _count: LeadCampaignCountAggregateOutputType | null
    _min: LeadCampaignMinAggregateOutputType | null
    _max: LeadCampaignMaxAggregateOutputType | null
  }

  type GetLeadCampaignGroupByPayload<T extends LeadCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], LeadCampaignGroupByOutputType[P]>
        }
      >
    >


  export type LeadCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    campaignId?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadCampaign"]>

  export type LeadCampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    campaignId?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadCampaign"]>

  export type LeadCampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    campaignId?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadCampaign"]>

  export type LeadCampaignSelectScalar = {
    leadId?: boolean
    campaignId?: boolean
  }

  export type LeadCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"leadId" | "campaignId", ExtArgs["result"]["leadCampaign"]>
  export type LeadCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type LeadCampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type LeadCampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $LeadCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadCampaign"
    objects: {
      Lead: Prisma.$LeadPayload<ExtArgs>
      Campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      leadId: string
      campaignId: string
    }, ExtArgs["result"]["leadCampaign"]>
    composites: {}
  }

  type LeadCampaignGetPayload<S extends boolean | null | undefined | LeadCampaignDefaultArgs> = $Result.GetResult<Prisma.$LeadCampaignPayload, S>

  type LeadCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCampaignCountAggregateInputType | true
    }

  export interface LeadCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadCampaign'], meta: { name: 'LeadCampaign' } }
    /**
     * Find zero or one LeadCampaign that matches the filter.
     * @param {LeadCampaignFindUniqueArgs} args - Arguments to find a LeadCampaign
     * @example
     * // Get one LeadCampaign
     * const leadCampaign = await prisma.leadCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadCampaignFindUniqueArgs>(args: SelectSubset<T, LeadCampaignFindUniqueArgs<ExtArgs>>): Prisma__LeadCampaignClient<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadCampaignFindUniqueOrThrowArgs} args - Arguments to find a LeadCampaign
     * @example
     * // Get one LeadCampaign
     * const leadCampaign = await prisma.leadCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadCampaignClient<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCampaignFindFirstArgs} args - Arguments to find a LeadCampaign
     * @example
     * // Get one LeadCampaign
     * const leadCampaign = await prisma.leadCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadCampaignFindFirstArgs>(args?: SelectSubset<T, LeadCampaignFindFirstArgs<ExtArgs>>): Prisma__LeadCampaignClient<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCampaignFindFirstOrThrowArgs} args - Arguments to find a LeadCampaign
     * @example
     * // Get one LeadCampaign
     * const leadCampaign = await prisma.leadCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadCampaignClient<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadCampaigns
     * const leadCampaigns = await prisma.leadCampaign.findMany()
     * 
     * // Get first 10 LeadCampaigns
     * const leadCampaigns = await prisma.leadCampaign.findMany({ take: 10 })
     * 
     * // Only select the `leadId`
     * const leadCampaignWithLeadIdOnly = await prisma.leadCampaign.findMany({ select: { leadId: true } })
     * 
     */
    findMany<T extends LeadCampaignFindManyArgs>(args?: SelectSubset<T, LeadCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadCampaign.
     * @param {LeadCampaignCreateArgs} args - Arguments to create a LeadCampaign.
     * @example
     * // Create one LeadCampaign
     * const LeadCampaign = await prisma.leadCampaign.create({
     *   data: {
     *     // ... data to create a LeadCampaign
     *   }
     * })
     * 
     */
    create<T extends LeadCampaignCreateArgs>(args: SelectSubset<T, LeadCampaignCreateArgs<ExtArgs>>): Prisma__LeadCampaignClient<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadCampaigns.
     * @param {LeadCampaignCreateManyArgs} args - Arguments to create many LeadCampaigns.
     * @example
     * // Create many LeadCampaigns
     * const leadCampaign = await prisma.leadCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCampaignCreateManyArgs>(args?: SelectSubset<T, LeadCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadCampaigns and returns the data saved in the database.
     * @param {LeadCampaignCreateManyAndReturnArgs} args - Arguments to create many LeadCampaigns.
     * @example
     * // Create many LeadCampaigns
     * const leadCampaign = await prisma.leadCampaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadCampaigns and only return the `leadId`
     * const leadCampaignWithLeadIdOnly = await prisma.leadCampaign.createManyAndReturn({
     *   select: { leadId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadCampaign.
     * @param {LeadCampaignDeleteArgs} args - Arguments to delete one LeadCampaign.
     * @example
     * // Delete one LeadCampaign
     * const LeadCampaign = await prisma.leadCampaign.delete({
     *   where: {
     *     // ... filter to delete one LeadCampaign
     *   }
     * })
     * 
     */
    delete<T extends LeadCampaignDeleteArgs>(args: SelectSubset<T, LeadCampaignDeleteArgs<ExtArgs>>): Prisma__LeadCampaignClient<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadCampaign.
     * @param {LeadCampaignUpdateArgs} args - Arguments to update one LeadCampaign.
     * @example
     * // Update one LeadCampaign
     * const leadCampaign = await prisma.leadCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadCampaignUpdateArgs>(args: SelectSubset<T, LeadCampaignUpdateArgs<ExtArgs>>): Prisma__LeadCampaignClient<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadCampaigns.
     * @param {LeadCampaignDeleteManyArgs} args - Arguments to filter LeadCampaigns to delete.
     * @example
     * // Delete a few LeadCampaigns
     * const { count } = await prisma.leadCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadCampaignDeleteManyArgs>(args?: SelectSubset<T, LeadCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadCampaigns
     * const leadCampaign = await prisma.leadCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadCampaignUpdateManyArgs>(args: SelectSubset<T, LeadCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadCampaigns and returns the data updated in the database.
     * @param {LeadCampaignUpdateManyAndReturnArgs} args - Arguments to update many LeadCampaigns.
     * @example
     * // Update many LeadCampaigns
     * const leadCampaign = await prisma.leadCampaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadCampaigns and only return the `leadId`
     * const leadCampaignWithLeadIdOnly = await prisma.leadCampaign.updateManyAndReturn({
     *   select: { leadId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadCampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadCampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadCampaign.
     * @param {LeadCampaignUpsertArgs} args - Arguments to update or create a LeadCampaign.
     * @example
     * // Update or create a LeadCampaign
     * const leadCampaign = await prisma.leadCampaign.upsert({
     *   create: {
     *     // ... data to create a LeadCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadCampaign we want to update
     *   }
     * })
     */
    upsert<T extends LeadCampaignUpsertArgs>(args: SelectSubset<T, LeadCampaignUpsertArgs<ExtArgs>>): Prisma__LeadCampaignClient<$Result.GetResult<Prisma.$LeadCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCampaignCountArgs} args - Arguments to filter LeadCampaigns to count.
     * @example
     * // Count the number of LeadCampaigns
     * const count = await prisma.leadCampaign.count({
     *   where: {
     *     // ... the filter for the LeadCampaigns we want to count
     *   }
     * })
    **/
    count<T extends LeadCampaignCountArgs>(
      args?: Subset<T, LeadCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadCampaignAggregateArgs>(args: Subset<T, LeadCampaignAggregateArgs>): Prisma.PrismaPromise<GetLeadCampaignAggregateType<T>>

    /**
     * Group by LeadCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadCampaignGroupByArgs['orderBy'] }
        : { orderBy?: LeadCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadCampaign model
   */
  readonly fields: LeadCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadCampaign model
   */
  interface LeadCampaignFieldRefs {
    readonly leadId: FieldRef<"LeadCampaign", 'String'>
    readonly campaignId: FieldRef<"LeadCampaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LeadCampaign findUnique
   */
  export type LeadCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    /**
     * Filter, which LeadCampaign to fetch.
     */
    where: LeadCampaignWhereUniqueInput
  }

  /**
   * LeadCampaign findUniqueOrThrow
   */
  export type LeadCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    /**
     * Filter, which LeadCampaign to fetch.
     */
    where: LeadCampaignWhereUniqueInput
  }

  /**
   * LeadCampaign findFirst
   */
  export type LeadCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    /**
     * Filter, which LeadCampaign to fetch.
     */
    where?: LeadCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadCampaigns to fetch.
     */
    orderBy?: LeadCampaignOrderByWithRelationInput | LeadCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadCampaigns.
     */
    cursor?: LeadCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadCampaigns.
     */
    distinct?: LeadCampaignScalarFieldEnum | LeadCampaignScalarFieldEnum[]
  }

  /**
   * LeadCampaign findFirstOrThrow
   */
  export type LeadCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    /**
     * Filter, which LeadCampaign to fetch.
     */
    where?: LeadCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadCampaigns to fetch.
     */
    orderBy?: LeadCampaignOrderByWithRelationInput | LeadCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadCampaigns.
     */
    cursor?: LeadCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadCampaigns.
     */
    distinct?: LeadCampaignScalarFieldEnum | LeadCampaignScalarFieldEnum[]
  }

  /**
   * LeadCampaign findMany
   */
  export type LeadCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    /**
     * Filter, which LeadCampaigns to fetch.
     */
    where?: LeadCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadCampaigns to fetch.
     */
    orderBy?: LeadCampaignOrderByWithRelationInput | LeadCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadCampaigns.
     */
    cursor?: LeadCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadCampaigns.
     */
    skip?: number
    distinct?: LeadCampaignScalarFieldEnum | LeadCampaignScalarFieldEnum[]
  }

  /**
   * LeadCampaign create
   */
  export type LeadCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadCampaign.
     */
    data: XOR<LeadCampaignCreateInput, LeadCampaignUncheckedCreateInput>
  }

  /**
   * LeadCampaign createMany
   */
  export type LeadCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadCampaigns.
     */
    data: LeadCampaignCreateManyInput | LeadCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadCampaign createManyAndReturn
   */
  export type LeadCampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * The data used to create many LeadCampaigns.
     */
    data: LeadCampaignCreateManyInput | LeadCampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadCampaign update
   */
  export type LeadCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadCampaign.
     */
    data: XOR<LeadCampaignUpdateInput, LeadCampaignUncheckedUpdateInput>
    /**
     * Choose, which LeadCampaign to update.
     */
    where: LeadCampaignWhereUniqueInput
  }

  /**
   * LeadCampaign updateMany
   */
  export type LeadCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadCampaigns.
     */
    data: XOR<LeadCampaignUpdateManyMutationInput, LeadCampaignUncheckedUpdateManyInput>
    /**
     * Filter which LeadCampaigns to update
     */
    where?: LeadCampaignWhereInput
    /**
     * Limit how many LeadCampaigns to update.
     */
    limit?: number
  }

  /**
   * LeadCampaign updateManyAndReturn
   */
  export type LeadCampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * The data used to update LeadCampaigns.
     */
    data: XOR<LeadCampaignUpdateManyMutationInput, LeadCampaignUncheckedUpdateManyInput>
    /**
     * Filter which LeadCampaigns to update
     */
    where?: LeadCampaignWhereInput
    /**
     * Limit how many LeadCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadCampaign upsert
   */
  export type LeadCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadCampaign to update in case it exists.
     */
    where: LeadCampaignWhereUniqueInput
    /**
     * In case the LeadCampaign found by the `where` argument doesn't exist, create a new LeadCampaign with this data.
     */
    create: XOR<LeadCampaignCreateInput, LeadCampaignUncheckedCreateInput>
    /**
     * In case the LeadCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadCampaignUpdateInput, LeadCampaignUncheckedUpdateInput>
  }

  /**
   * LeadCampaign delete
   */
  export type LeadCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
    /**
     * Filter which LeadCampaign to delete.
     */
    where: LeadCampaignWhereUniqueInput
  }

  /**
   * LeadCampaign deleteMany
   */
  export type LeadCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadCampaigns to delete
     */
    where?: LeadCampaignWhereInput
    /**
     * Limit how many LeadCampaigns to delete.
     */
    limit?: number
  }

  /**
   * LeadCampaign without action
   */
  export type LeadCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCampaign
     */
    select?: LeadCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadCampaign
     */
    omit?: LeadCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadCampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignSource
   */

  export type AggregateCampaignSource = {
    _count: CampaignSourceCountAggregateOutputType | null
    _min: CampaignSourceMinAggregateOutputType | null
    _max: CampaignSourceMaxAggregateOutputType | null
  }

  export type CampaignSourceMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignSourceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignSourceCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignSourceMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignSourceMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignSourceCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignSource to aggregate.
     */
    where?: CampaignSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSources to fetch.
     */
    orderBy?: CampaignSourceOrderByWithRelationInput | CampaignSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignSources
    **/
    _count?: true | CampaignSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignSourceMaxAggregateInputType
  }

  export type GetCampaignSourceAggregateType<T extends CampaignSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignSource[P]>
      : GetScalarType<T[P], AggregateCampaignSource[P]>
  }




  export type CampaignSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignSourceWhereInput
    orderBy?: CampaignSourceOrderByWithAggregationInput | CampaignSourceOrderByWithAggregationInput[]
    by: CampaignSourceScalarFieldEnum[] | CampaignSourceScalarFieldEnum
    having?: CampaignSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignSourceCountAggregateInputType | true
    _min?: CampaignSourceMinAggregateInputType
    _max?: CampaignSourceMaxAggregateInputType
  }

  export type CampaignSourceGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: CampaignSourceCountAggregateOutputType | null
    _min: CampaignSourceMinAggregateOutputType | null
    _max: CampaignSourceMaxAggregateOutputType | null
  }

  type GetCampaignSourceGroupByPayload<T extends CampaignSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignSourceGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignSourceGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Campaigns?: boolean | CampaignSource$CampaignsArgs<ExtArgs>
    _count?: boolean | CampaignSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignSource"]>

  export type CampaignSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["campaignSource"]>

  export type CampaignSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["campaignSource"]>

  export type CampaignSourceSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["campaignSource"]>
  export type CampaignSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaigns?: boolean | CampaignSource$CampaignsArgs<ExtArgs>
    _count?: boolean | CampaignSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CampaignSourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CampaignSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignSource"
    objects: {
      Campaigns: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignSource"]>
    composites: {}
  }

  type CampaignSourceGetPayload<S extends boolean | null | undefined | CampaignSourceDefaultArgs> = $Result.GetResult<Prisma.$CampaignSourcePayload, S>

  type CampaignSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignSourceCountAggregateInputType | true
    }

  export interface CampaignSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignSource'], meta: { name: 'CampaignSource' } }
    /**
     * Find zero or one CampaignSource that matches the filter.
     * @param {CampaignSourceFindUniqueArgs} args - Arguments to find a CampaignSource
     * @example
     * // Get one CampaignSource
     * const campaignSource = await prisma.campaignSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignSourceFindUniqueArgs>(args: SelectSubset<T, CampaignSourceFindUniqueArgs<ExtArgs>>): Prisma__CampaignSourceClient<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignSourceFindUniqueOrThrowArgs} args - Arguments to find a CampaignSource
     * @example
     * // Get one CampaignSource
     * const campaignSource = await prisma.campaignSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignSourceClient<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSourceFindFirstArgs} args - Arguments to find a CampaignSource
     * @example
     * // Get one CampaignSource
     * const campaignSource = await prisma.campaignSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignSourceFindFirstArgs>(args?: SelectSubset<T, CampaignSourceFindFirstArgs<ExtArgs>>): Prisma__CampaignSourceClient<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSourceFindFirstOrThrowArgs} args - Arguments to find a CampaignSource
     * @example
     * // Get one CampaignSource
     * const campaignSource = await prisma.campaignSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignSourceClient<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignSources
     * const campaignSources = await prisma.campaignSource.findMany()
     * 
     * // Get first 10 CampaignSources
     * const campaignSources = await prisma.campaignSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignSourceWithIdOnly = await prisma.campaignSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignSourceFindManyArgs>(args?: SelectSubset<T, CampaignSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignSource.
     * @param {CampaignSourceCreateArgs} args - Arguments to create a CampaignSource.
     * @example
     * // Create one CampaignSource
     * const CampaignSource = await prisma.campaignSource.create({
     *   data: {
     *     // ... data to create a CampaignSource
     *   }
     * })
     * 
     */
    create<T extends CampaignSourceCreateArgs>(args: SelectSubset<T, CampaignSourceCreateArgs<ExtArgs>>): Prisma__CampaignSourceClient<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignSources.
     * @param {CampaignSourceCreateManyArgs} args - Arguments to create many CampaignSources.
     * @example
     * // Create many CampaignSources
     * const campaignSource = await prisma.campaignSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignSourceCreateManyArgs>(args?: SelectSubset<T, CampaignSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignSources and returns the data saved in the database.
     * @param {CampaignSourceCreateManyAndReturnArgs} args - Arguments to create many CampaignSources.
     * @example
     * // Create many CampaignSources
     * const campaignSource = await prisma.campaignSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignSources and only return the `id`
     * const campaignSourceWithIdOnly = await prisma.campaignSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignSource.
     * @param {CampaignSourceDeleteArgs} args - Arguments to delete one CampaignSource.
     * @example
     * // Delete one CampaignSource
     * const CampaignSource = await prisma.campaignSource.delete({
     *   where: {
     *     // ... filter to delete one CampaignSource
     *   }
     * })
     * 
     */
    delete<T extends CampaignSourceDeleteArgs>(args: SelectSubset<T, CampaignSourceDeleteArgs<ExtArgs>>): Prisma__CampaignSourceClient<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignSource.
     * @param {CampaignSourceUpdateArgs} args - Arguments to update one CampaignSource.
     * @example
     * // Update one CampaignSource
     * const campaignSource = await prisma.campaignSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignSourceUpdateArgs>(args: SelectSubset<T, CampaignSourceUpdateArgs<ExtArgs>>): Prisma__CampaignSourceClient<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignSources.
     * @param {CampaignSourceDeleteManyArgs} args - Arguments to filter CampaignSources to delete.
     * @example
     * // Delete a few CampaignSources
     * const { count } = await prisma.campaignSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignSourceDeleteManyArgs>(args?: SelectSubset<T, CampaignSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignSources
     * const campaignSource = await prisma.campaignSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignSourceUpdateManyArgs>(args: SelectSubset<T, CampaignSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignSources and returns the data updated in the database.
     * @param {CampaignSourceUpdateManyAndReturnArgs} args - Arguments to update many CampaignSources.
     * @example
     * // Update many CampaignSources
     * const campaignSource = await prisma.campaignSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignSources and only return the `id`
     * const campaignSourceWithIdOnly = await prisma.campaignSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignSource.
     * @param {CampaignSourceUpsertArgs} args - Arguments to update or create a CampaignSource.
     * @example
     * // Update or create a CampaignSource
     * const campaignSource = await prisma.campaignSource.upsert({
     *   create: {
     *     // ... data to create a CampaignSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignSource we want to update
     *   }
     * })
     */
    upsert<T extends CampaignSourceUpsertArgs>(args: SelectSubset<T, CampaignSourceUpsertArgs<ExtArgs>>): Prisma__CampaignSourceClient<$Result.GetResult<Prisma.$CampaignSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSourceCountArgs} args - Arguments to filter CampaignSources to count.
     * @example
     * // Count the number of CampaignSources
     * const count = await prisma.campaignSource.count({
     *   where: {
     *     // ... the filter for the CampaignSources we want to count
     *   }
     * })
    **/
    count<T extends CampaignSourceCountArgs>(
      args?: Subset<T, CampaignSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignSourceAggregateArgs>(args: Subset<T, CampaignSourceAggregateArgs>): Prisma.PrismaPromise<GetCampaignSourceAggregateType<T>>

    /**
     * Group by CampaignSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignSourceGroupByArgs['orderBy'] }
        : { orderBy?: CampaignSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignSource model
   */
  readonly fields: CampaignSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Campaigns<T extends CampaignSource$CampaignsArgs<ExtArgs> = {}>(args?: Subset<T, CampaignSource$CampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignSource model
   */
  interface CampaignSourceFieldRefs {
    readonly id: FieldRef<"CampaignSource", 'String'>
    readonly title: FieldRef<"CampaignSource", 'String'>
    readonly createdAt: FieldRef<"CampaignSource", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignSource findUnique
   */
  export type CampaignSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSource to fetch.
     */
    where: CampaignSourceWhereUniqueInput
  }

  /**
   * CampaignSource findUniqueOrThrow
   */
  export type CampaignSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSource to fetch.
     */
    where: CampaignSourceWhereUniqueInput
  }

  /**
   * CampaignSource findFirst
   */
  export type CampaignSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSource to fetch.
     */
    where?: CampaignSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSources to fetch.
     */
    orderBy?: CampaignSourceOrderByWithRelationInput | CampaignSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignSources.
     */
    cursor?: CampaignSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignSources.
     */
    distinct?: CampaignSourceScalarFieldEnum | CampaignSourceScalarFieldEnum[]
  }

  /**
   * CampaignSource findFirstOrThrow
   */
  export type CampaignSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSource to fetch.
     */
    where?: CampaignSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSources to fetch.
     */
    orderBy?: CampaignSourceOrderByWithRelationInput | CampaignSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignSources.
     */
    cursor?: CampaignSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignSources.
     */
    distinct?: CampaignSourceScalarFieldEnum | CampaignSourceScalarFieldEnum[]
  }

  /**
   * CampaignSource findMany
   */
  export type CampaignSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
    /**
     * Filter, which CampaignSources to fetch.
     */
    where?: CampaignSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignSources to fetch.
     */
    orderBy?: CampaignSourceOrderByWithRelationInput | CampaignSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignSources.
     */
    cursor?: CampaignSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignSources.
     */
    skip?: number
    distinct?: CampaignSourceScalarFieldEnum | CampaignSourceScalarFieldEnum[]
  }

  /**
   * CampaignSource create
   */
  export type CampaignSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignSource.
     */
    data: XOR<CampaignSourceCreateInput, CampaignSourceUncheckedCreateInput>
  }

  /**
   * CampaignSource createMany
   */
  export type CampaignSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignSources.
     */
    data: CampaignSourceCreateManyInput | CampaignSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignSource createManyAndReturn
   */
  export type CampaignSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignSources.
     */
    data: CampaignSourceCreateManyInput | CampaignSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignSource update
   */
  export type CampaignSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignSource.
     */
    data: XOR<CampaignSourceUpdateInput, CampaignSourceUncheckedUpdateInput>
    /**
     * Choose, which CampaignSource to update.
     */
    where: CampaignSourceWhereUniqueInput
  }

  /**
   * CampaignSource updateMany
   */
  export type CampaignSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignSources.
     */
    data: XOR<CampaignSourceUpdateManyMutationInput, CampaignSourceUncheckedUpdateManyInput>
    /**
     * Filter which CampaignSources to update
     */
    where?: CampaignSourceWhereInput
    /**
     * Limit how many CampaignSources to update.
     */
    limit?: number
  }

  /**
   * CampaignSource updateManyAndReturn
   */
  export type CampaignSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * The data used to update CampaignSources.
     */
    data: XOR<CampaignSourceUpdateManyMutationInput, CampaignSourceUncheckedUpdateManyInput>
    /**
     * Filter which CampaignSources to update
     */
    where?: CampaignSourceWhereInput
    /**
     * Limit how many CampaignSources to update.
     */
    limit?: number
  }

  /**
   * CampaignSource upsert
   */
  export type CampaignSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignSource to update in case it exists.
     */
    where: CampaignSourceWhereUniqueInput
    /**
     * In case the CampaignSource found by the `where` argument doesn't exist, create a new CampaignSource with this data.
     */
    create: XOR<CampaignSourceCreateInput, CampaignSourceUncheckedCreateInput>
    /**
     * In case the CampaignSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignSourceUpdateInput, CampaignSourceUncheckedUpdateInput>
  }

  /**
   * CampaignSource delete
   */
  export type CampaignSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
    /**
     * Filter which CampaignSource to delete.
     */
    where: CampaignSourceWhereUniqueInput
  }

  /**
   * CampaignSource deleteMany
   */
  export type CampaignSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignSources to delete
     */
    where?: CampaignSourceWhereInput
    /**
     * Limit how many CampaignSources to delete.
     */
    limit?: number
  }

  /**
   * CampaignSource.Campaigns
   */
  export type CampaignSource$CampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * CampaignSource without action
   */
  export type CampaignSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignSource
     */
    select?: CampaignSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignSource
     */
    omit?: CampaignSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignSourceInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    description: string
    color: string
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Leads?: boolean | Tag$LeadsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Leads?: boolean | Tag$LeadsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      Leads: Prisma.$LeadTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      color: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Leads<T extends Tag$LeadsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$LeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.Leads
   */
  export type Tag$LeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    where?: LeadTagWhereInput
    orderBy?: LeadTagOrderByWithRelationInput | LeadTagOrderByWithRelationInput[]
    cursor?: LeadTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadTagScalarFieldEnum | LeadTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model LeadTag
   */

  export type AggregateLeadTag = {
    _count: LeadTagCountAggregateOutputType | null
    _min: LeadTagMinAggregateOutputType | null
    _max: LeadTagMaxAggregateOutputType | null
  }

  export type LeadTagMinAggregateOutputType = {
    leadId: string | null
    tagId: string | null
  }

  export type LeadTagMaxAggregateOutputType = {
    leadId: string | null
    tagId: string | null
  }

  export type LeadTagCountAggregateOutputType = {
    leadId: number
    tagId: number
    _all: number
  }


  export type LeadTagMinAggregateInputType = {
    leadId?: true
    tagId?: true
  }

  export type LeadTagMaxAggregateInputType = {
    leadId?: true
    tagId?: true
  }

  export type LeadTagCountAggregateInputType = {
    leadId?: true
    tagId?: true
    _all?: true
  }

  export type LeadTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadTag to aggregate.
     */
    where?: LeadTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadTags to fetch.
     */
    orderBy?: LeadTagOrderByWithRelationInput | LeadTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadTags
    **/
    _count?: true | LeadTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadTagMaxAggregateInputType
  }

  export type GetLeadTagAggregateType<T extends LeadTagAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadTag[P]>
      : GetScalarType<T[P], AggregateLeadTag[P]>
  }




  export type LeadTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadTagWhereInput
    orderBy?: LeadTagOrderByWithAggregationInput | LeadTagOrderByWithAggregationInput[]
    by: LeadTagScalarFieldEnum[] | LeadTagScalarFieldEnum
    having?: LeadTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadTagCountAggregateInputType | true
    _min?: LeadTagMinAggregateInputType
    _max?: LeadTagMaxAggregateInputType
  }

  export type LeadTagGroupByOutputType = {
    leadId: string
    tagId: string
    _count: LeadTagCountAggregateOutputType | null
    _min: LeadTagMinAggregateOutputType | null
    _max: LeadTagMaxAggregateOutputType | null
  }

  type GetLeadTagGroupByPayload<T extends LeadTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadTagGroupByOutputType[P]>
            : GetScalarType<T[P], LeadTagGroupByOutputType[P]>
        }
      >
    >


  export type LeadTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    tagId?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadTag"]>

  export type LeadTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    tagId?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadTag"]>

  export type LeadTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    tagId?: boolean
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leadTag"]>

  export type LeadTagSelectScalar = {
    leadId?: boolean
    tagId?: boolean
  }

  export type LeadTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"leadId" | "tagId", ExtArgs["result"]["leadTag"]>
  export type LeadTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type LeadTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type LeadTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lead?: boolean | LeadDefaultArgs<ExtArgs>
    Tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $LeadTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadTag"
    objects: {
      Lead: Prisma.$LeadPayload<ExtArgs>
      Tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      leadId: string
      tagId: string
    }, ExtArgs["result"]["leadTag"]>
    composites: {}
  }

  type LeadTagGetPayload<S extends boolean | null | undefined | LeadTagDefaultArgs> = $Result.GetResult<Prisma.$LeadTagPayload, S>

  type LeadTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadTagCountAggregateInputType | true
    }

  export interface LeadTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadTag'], meta: { name: 'LeadTag' } }
    /**
     * Find zero or one LeadTag that matches the filter.
     * @param {LeadTagFindUniqueArgs} args - Arguments to find a LeadTag
     * @example
     * // Get one LeadTag
     * const leadTag = await prisma.leadTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadTagFindUniqueArgs>(args: SelectSubset<T, LeadTagFindUniqueArgs<ExtArgs>>): Prisma__LeadTagClient<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeadTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadTagFindUniqueOrThrowArgs} args - Arguments to find a LeadTag
     * @example
     * // Get one LeadTag
     * const leadTag = await prisma.leadTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadTagFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadTagClient<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTagFindFirstArgs} args - Arguments to find a LeadTag
     * @example
     * // Get one LeadTag
     * const leadTag = await prisma.leadTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadTagFindFirstArgs>(args?: SelectSubset<T, LeadTagFindFirstArgs<ExtArgs>>): Prisma__LeadTagClient<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeadTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTagFindFirstOrThrowArgs} args - Arguments to find a LeadTag
     * @example
     * // Get one LeadTag
     * const leadTag = await prisma.leadTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadTagFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadTagClient<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeadTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadTags
     * const leadTags = await prisma.leadTag.findMany()
     * 
     * // Get first 10 LeadTags
     * const leadTags = await prisma.leadTag.findMany({ take: 10 })
     * 
     * // Only select the `leadId`
     * const leadTagWithLeadIdOnly = await prisma.leadTag.findMany({ select: { leadId: true } })
     * 
     */
    findMany<T extends LeadTagFindManyArgs>(args?: SelectSubset<T, LeadTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeadTag.
     * @param {LeadTagCreateArgs} args - Arguments to create a LeadTag.
     * @example
     * // Create one LeadTag
     * const LeadTag = await prisma.leadTag.create({
     *   data: {
     *     // ... data to create a LeadTag
     *   }
     * })
     * 
     */
    create<T extends LeadTagCreateArgs>(args: SelectSubset<T, LeadTagCreateArgs<ExtArgs>>): Prisma__LeadTagClient<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeadTags.
     * @param {LeadTagCreateManyArgs} args - Arguments to create many LeadTags.
     * @example
     * // Create many LeadTags
     * const leadTag = await prisma.leadTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadTagCreateManyArgs>(args?: SelectSubset<T, LeadTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadTags and returns the data saved in the database.
     * @param {LeadTagCreateManyAndReturnArgs} args - Arguments to create many LeadTags.
     * @example
     * // Create many LeadTags
     * const leadTag = await prisma.leadTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadTags and only return the `leadId`
     * const leadTagWithLeadIdOnly = await prisma.leadTag.createManyAndReturn({
     *   select: { leadId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadTagCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeadTag.
     * @param {LeadTagDeleteArgs} args - Arguments to delete one LeadTag.
     * @example
     * // Delete one LeadTag
     * const LeadTag = await prisma.leadTag.delete({
     *   where: {
     *     // ... filter to delete one LeadTag
     *   }
     * })
     * 
     */
    delete<T extends LeadTagDeleteArgs>(args: SelectSubset<T, LeadTagDeleteArgs<ExtArgs>>): Prisma__LeadTagClient<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeadTag.
     * @param {LeadTagUpdateArgs} args - Arguments to update one LeadTag.
     * @example
     * // Update one LeadTag
     * const leadTag = await prisma.leadTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadTagUpdateArgs>(args: SelectSubset<T, LeadTagUpdateArgs<ExtArgs>>): Prisma__LeadTagClient<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeadTags.
     * @param {LeadTagDeleteManyArgs} args - Arguments to filter LeadTags to delete.
     * @example
     * // Delete a few LeadTags
     * const { count } = await prisma.leadTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadTagDeleteManyArgs>(args?: SelectSubset<T, LeadTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadTags
     * const leadTag = await prisma.leadTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadTagUpdateManyArgs>(args: SelectSubset<T, LeadTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadTags and returns the data updated in the database.
     * @param {LeadTagUpdateManyAndReturnArgs} args - Arguments to update many LeadTags.
     * @example
     * // Update many LeadTags
     * const leadTag = await prisma.leadTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeadTags and only return the `leadId`
     * const leadTagWithLeadIdOnly = await prisma.leadTag.updateManyAndReturn({
     *   select: { leadId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadTagUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeadTag.
     * @param {LeadTagUpsertArgs} args - Arguments to update or create a LeadTag.
     * @example
     * // Update or create a LeadTag
     * const leadTag = await prisma.leadTag.upsert({
     *   create: {
     *     // ... data to create a LeadTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadTag we want to update
     *   }
     * })
     */
    upsert<T extends LeadTagUpsertArgs>(args: SelectSubset<T, LeadTagUpsertArgs<ExtArgs>>): Prisma__LeadTagClient<$Result.GetResult<Prisma.$LeadTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeadTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTagCountArgs} args - Arguments to filter LeadTags to count.
     * @example
     * // Count the number of LeadTags
     * const count = await prisma.leadTag.count({
     *   where: {
     *     // ... the filter for the LeadTags we want to count
     *   }
     * })
    **/
    count<T extends LeadTagCountArgs>(
      args?: Subset<T, LeadTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadTagAggregateArgs>(args: Subset<T, LeadTagAggregateArgs>): Prisma.PrismaPromise<GetLeadTagAggregateType<T>>

    /**
     * Group by LeadTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadTagGroupByArgs['orderBy'] }
        : { orderBy?: LeadTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadTag model
   */
  readonly fields: LeadTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadTag model
   */
  interface LeadTagFieldRefs {
    readonly leadId: FieldRef<"LeadTag", 'String'>
    readonly tagId: FieldRef<"LeadTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LeadTag findUnique
   */
  export type LeadTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    /**
     * Filter, which LeadTag to fetch.
     */
    where: LeadTagWhereUniqueInput
  }

  /**
   * LeadTag findUniqueOrThrow
   */
  export type LeadTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    /**
     * Filter, which LeadTag to fetch.
     */
    where: LeadTagWhereUniqueInput
  }

  /**
   * LeadTag findFirst
   */
  export type LeadTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    /**
     * Filter, which LeadTag to fetch.
     */
    where?: LeadTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadTags to fetch.
     */
    orderBy?: LeadTagOrderByWithRelationInput | LeadTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadTags.
     */
    cursor?: LeadTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadTags.
     */
    distinct?: LeadTagScalarFieldEnum | LeadTagScalarFieldEnum[]
  }

  /**
   * LeadTag findFirstOrThrow
   */
  export type LeadTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    /**
     * Filter, which LeadTag to fetch.
     */
    where?: LeadTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadTags to fetch.
     */
    orderBy?: LeadTagOrderByWithRelationInput | LeadTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadTags.
     */
    cursor?: LeadTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadTags.
     */
    distinct?: LeadTagScalarFieldEnum | LeadTagScalarFieldEnum[]
  }

  /**
   * LeadTag findMany
   */
  export type LeadTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    /**
     * Filter, which LeadTags to fetch.
     */
    where?: LeadTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadTags to fetch.
     */
    orderBy?: LeadTagOrderByWithRelationInput | LeadTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadTags.
     */
    cursor?: LeadTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadTags.
     */
    skip?: number
    distinct?: LeadTagScalarFieldEnum | LeadTagScalarFieldEnum[]
  }

  /**
   * LeadTag create
   */
  export type LeadTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    /**
     * The data needed to create a LeadTag.
     */
    data: XOR<LeadTagCreateInput, LeadTagUncheckedCreateInput>
  }

  /**
   * LeadTag createMany
   */
  export type LeadTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadTags.
     */
    data: LeadTagCreateManyInput | LeadTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadTag createManyAndReturn
   */
  export type LeadTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * The data used to create many LeadTags.
     */
    data: LeadTagCreateManyInput | LeadTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadTag update
   */
  export type LeadTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    /**
     * The data needed to update a LeadTag.
     */
    data: XOR<LeadTagUpdateInput, LeadTagUncheckedUpdateInput>
    /**
     * Choose, which LeadTag to update.
     */
    where: LeadTagWhereUniqueInput
  }

  /**
   * LeadTag updateMany
   */
  export type LeadTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadTags.
     */
    data: XOR<LeadTagUpdateManyMutationInput, LeadTagUncheckedUpdateManyInput>
    /**
     * Filter which LeadTags to update
     */
    where?: LeadTagWhereInput
    /**
     * Limit how many LeadTags to update.
     */
    limit?: number
  }

  /**
   * LeadTag updateManyAndReturn
   */
  export type LeadTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * The data used to update LeadTags.
     */
    data: XOR<LeadTagUpdateManyMutationInput, LeadTagUncheckedUpdateManyInput>
    /**
     * Filter which LeadTags to update
     */
    where?: LeadTagWhereInput
    /**
     * Limit how many LeadTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeadTag upsert
   */
  export type LeadTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    /**
     * The filter to search for the LeadTag to update in case it exists.
     */
    where: LeadTagWhereUniqueInput
    /**
     * In case the LeadTag found by the `where` argument doesn't exist, create a new LeadTag with this data.
     */
    create: XOR<LeadTagCreateInput, LeadTagUncheckedCreateInput>
    /**
     * In case the LeadTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadTagUpdateInput, LeadTagUncheckedUpdateInput>
  }

  /**
   * LeadTag delete
   */
  export type LeadTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
    /**
     * Filter which LeadTag to delete.
     */
    where: LeadTagWhereUniqueInput
  }

  /**
   * LeadTag deleteMany
   */
  export type LeadTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadTags to delete
     */
    where?: LeadTagWhereInput
    /**
     * Limit how many LeadTags to delete.
     */
    limit?: number
  }

  /**
   * LeadTag without action
   */
  export type LeadTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadTag
     */
    select?: LeadTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeadTag
     */
    omit?: LeadTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadTagInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    constructionCompanyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    constructionCompanyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    constructionCompanyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    constructionCompanyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    constructionCompanyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    constructionCompanyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string
    constructionCompanyId: string
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    constructionCompanyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    constructionCompanyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    constructionCompanyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    constructionCompanyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "constructionCompanyId" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ConstructionCompany?: boolean | ConstructionCompanyDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      ConstructionCompany: Prisma.$ConstructionCompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string
      constructionCompanyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ConstructionCompany<T extends ConstructionCompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConstructionCompanyDefaultArgs<ExtArgs>>): Prisma__ConstructionCompanyClient<$Result.GetResult<Prisma.$ConstructionCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly constructionCompanyId: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    master: 'master',
    status: 'status',
    chatwootAgentId: 'chatwootAgentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    description: 'description'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const UserPermissionScalarFieldEnum: {
    userId: 'userId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type UserPermissionScalarFieldEnum = (typeof UserPermissionScalarFieldEnum)[keyof typeof UserPermissionScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    picture: 'picture',
    name: 'name',
    phone: 'phone',
    email: 'email',
    chatwootContactId: 'chatwootContactId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    leadId: 'leadId',
    date: 'date',
    address: 'address',
    nextNotificationAt: 'nextNotificationAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const ScheduleParticipantScalarFieldEnum: {
    scheduleId: 'scheduleId',
    userId: 'userId'
  };

  export type ScheduleParticipantScalarFieldEnum = (typeof ScheduleParticipantScalarFieldEnum)[keyof typeof ScheduleParticipantScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    title: 'title',
    customerId: 'customerId',
    userId: 'userId',
    laneId: 'laneId',
    value: 'value',
    status: 'status',
    lostedLeadReasonId: 'lostedLeadReasonId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const LeadMetadataScalarFieldEnum: {
    id: 'id',
    leadId: 'leadId',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadMetadataScalarFieldEnum = (typeof LeadMetadataScalarFieldEnum)[keyof typeof LeadMetadataScalarFieldEnum]


  export const LeadLostReasonScalarFieldEnum: {
    id: 'id',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadLostReasonScalarFieldEnum = (typeof LeadLostReasonScalarFieldEnum)[keyof typeof LeadLostReasonScalarFieldEnum]


  export const LeadCommentScalarFieldEnum: {
    id: 'id',
    leadId: 'leadId',
    userId: 'userId',
    content: 'content',
    deleted: 'deleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadCommentScalarFieldEnum = (typeof LeadCommentScalarFieldEnum)[keyof typeof LeadCommentScalarFieldEnum]


  export const LeadChatScalarFieldEnum: {
    leadId: 'leadId',
    conversationId: 'conversationId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadChatScalarFieldEnum = (typeof LeadChatScalarFieldEnum)[keyof typeof LeadChatScalarFieldEnum]


  export const LeadDocumentScalarFieldEnum: {
    leadId: 'leadId',
    name: 'name',
    path: 'path',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadDocumentScalarFieldEnum = (typeof LeadDocumentScalarFieldEnum)[keyof typeof LeadDocumentScalarFieldEnum]


  export const LaneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    sortOrder: 'sortOrder',
    principal: 'principal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaneScalarFieldEnum = (typeof LaneScalarFieldEnum)[keyof typeof LaneScalarFieldEnum]


  export const ConstructionCompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConstructionCompanyScalarFieldEnum = (typeof ConstructionCompanyScalarFieldEnum)[keyof typeof ConstructionCompanyScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    url: 'url',
    constructionId: 'constructionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    title: 'title',
    sourceId: 'sourceId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const LeadCampaignScalarFieldEnum: {
    leadId: 'leadId',
    campaignId: 'campaignId'
  };

  export type LeadCampaignScalarFieldEnum = (typeof LeadCampaignScalarFieldEnum)[keyof typeof LeadCampaignScalarFieldEnum]


  export const CampaignSourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignSourceScalarFieldEnum = (typeof CampaignSourceScalarFieldEnum)[keyof typeof CampaignSourceScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const LeadTagScalarFieldEnum: {
    leadId: 'leadId',
    tagId: 'tagId'
  };

  export type LeadTagScalarFieldEnum = (typeof LeadTagScalarFieldEnum)[keyof typeof LeadTagScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    constructionCompanyId: 'constructionCompanyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ScheduleStatus'
   */
  export type EnumScheduleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleStatus'>
    


  /**
   * Reference to a field of type 'ScheduleStatus[]'
   */
  export type ListEnumScheduleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleStatus[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    master?: BoolFilter<"User"> | boolean
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    chatwootAgentId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    Permissions?: UserPermissionListRelationFilter
    Leads?: LeadListRelationFilter
    LeadComments?: LeadCommentListRelationFilter
    LeadDocuments?: LeadDocumentListRelationFilter
    Schedules?: ScheduleListRelationFilter
    ScheduleParticipating?: ScheduleParticipantListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    master?: SortOrder
    status?: SortOrder
    chatwootAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    Permissions?: UserPermissionOrderByRelationAggregateInput
    Leads?: LeadOrderByRelationAggregateInput
    LeadComments?: LeadCommentOrderByRelationAggregateInput
    LeadDocuments?: LeadDocumentOrderByRelationAggregateInput
    Schedules?: ScheduleOrderByRelationAggregateInput
    ScheduleParticipating?: ScheduleParticipantOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    master?: BoolFilter<"User"> | boolean
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    chatwootAgentId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    Permissions?: UserPermissionListRelationFilter
    Leads?: LeadListRelationFilter
    LeadComments?: LeadCommentListRelationFilter
    LeadDocuments?: LeadDocumentListRelationFilter
    Schedules?: ScheduleListRelationFilter
    ScheduleParticipating?: ScheduleParticipantListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    master?: SortOrder
    status?: SortOrder
    chatwootAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    master?: BoolWithAggregatesFilter<"User"> | boolean
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    chatwootAgentId?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    slug?: StringFilter<"Permission"> | string
    description?: StringFilter<"Permission"> | string
    Users?: UserPermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    Users?: UserPermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringFilter<"Permission"> | string
    Users?: UserPermissionListRelationFilter
  }, "id" | "slug">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    slug?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringWithAggregatesFilter<"Permission"> | string
  }

  export type UserPermissionWhereInput = {
    AND?: UserPermissionWhereInput | UserPermissionWhereInput[]
    OR?: UserPermissionWhereInput[]
    NOT?: UserPermissionWhereInput | UserPermissionWhereInput[]
    userId?: StringFilter<"UserPermission"> | string
    permissionId?: StringFilter<"UserPermission"> | string
    createdAt?: DateTimeFilter<"UserPermission"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type UserPermissionOrderByWithRelationInput = {
    userId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Permission?: PermissionOrderByWithRelationInput
  }

  export type UserPermissionWhereUniqueInput = Prisma.AtLeast<{
    userId_permissionId?: UserPermissionUserIdPermissionIdCompoundUniqueInput
    AND?: UserPermissionWhereInput | UserPermissionWhereInput[]
    OR?: UserPermissionWhereInput[]
    NOT?: UserPermissionWhereInput | UserPermissionWhereInput[]
    userId?: StringFilter<"UserPermission"> | string
    permissionId?: StringFilter<"UserPermission"> | string
    createdAt?: DateTimeFilter<"UserPermission"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "userId_permissionId">

  export type UserPermissionOrderByWithAggregationInput = {
    userId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: UserPermissionCountOrderByAggregateInput
    _max?: UserPermissionMaxOrderByAggregateInput
    _min?: UserPermissionMinOrderByAggregateInput
  }

  export type UserPermissionScalarWhereWithAggregatesInput = {
    AND?: UserPermissionScalarWhereWithAggregatesInput | UserPermissionScalarWhereWithAggregatesInput[]
    OR?: UserPermissionScalarWhereWithAggregatesInput[]
    NOT?: UserPermissionScalarWhereWithAggregatesInput | UserPermissionScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserPermission"> | string
    permissionId?: StringWithAggregatesFilter<"UserPermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserPermission"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    picture?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    email?: StringFilter<"Customer"> | string
    chatwootContactId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    Leads?: LeadListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    picture?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    chatwootContactId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Leads?: LeadOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    picture?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    email?: StringFilter<"Customer"> | string
    chatwootContactId?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    Leads?: LeadListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    picture?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    chatwootContactId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    picture?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringWithAggregatesFilter<"Customer"> | string
    chatwootContactId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    userId?: StringFilter<"Schedule"> | string
    leadId?: StringFilter<"Schedule"> | string
    date?: DateTimeFilter<"Schedule"> | Date | string
    address?: StringFilter<"Schedule"> | string
    nextNotificationAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    status?: EnumScheduleStatusFilter<"Schedule"> | $Enums.ScheduleStatus
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    Participants?: ScheduleParticipantListRelationFilter
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    leadId?: SortOrder
    date?: SortOrder
    address?: SortOrder
    nextNotificationAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Lead?: LeadOrderByWithRelationInput
    Participants?: ScheduleParticipantOrderByRelationAggregateInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    userId?: StringFilter<"Schedule"> | string
    leadId?: StringFilter<"Schedule"> | string
    date?: DateTimeFilter<"Schedule"> | Date | string
    address?: StringFilter<"Schedule"> | string
    nextNotificationAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    status?: EnumScheduleStatusFilter<"Schedule"> | $Enums.ScheduleStatus
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    Participants?: ScheduleParticipantListRelationFilter
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    leadId?: SortOrder
    date?: SortOrder
    address?: SortOrder
    nextNotificationAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    userId?: StringWithAggregatesFilter<"Schedule"> | string
    leadId?: StringWithAggregatesFilter<"Schedule"> | string
    date?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    address?: StringWithAggregatesFilter<"Schedule"> | string
    nextNotificationAt?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    status?: EnumScheduleStatusWithAggregatesFilter<"Schedule"> | $Enums.ScheduleStatus
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
  }

  export type ScheduleParticipantWhereInput = {
    AND?: ScheduleParticipantWhereInput | ScheduleParticipantWhereInput[]
    OR?: ScheduleParticipantWhereInput[]
    NOT?: ScheduleParticipantWhereInput | ScheduleParticipantWhereInput[]
    scheduleId?: StringFilter<"ScheduleParticipant"> | string
    userId?: StringFilter<"ScheduleParticipant"> | string
    Schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>
    Participant?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ScheduleParticipantOrderByWithRelationInput = {
    scheduleId?: SortOrder
    userId?: SortOrder
    Schedule?: ScheduleOrderByWithRelationInput
    Participant?: UserOrderByWithRelationInput
  }

  export type ScheduleParticipantWhereUniqueInput = Prisma.AtLeast<{
    scheduleId_userId?: ScheduleParticipantScheduleIdUserIdCompoundUniqueInput
    AND?: ScheduleParticipantWhereInput | ScheduleParticipantWhereInput[]
    OR?: ScheduleParticipantWhereInput[]
    NOT?: ScheduleParticipantWhereInput | ScheduleParticipantWhereInput[]
    scheduleId?: StringFilter<"ScheduleParticipant"> | string
    userId?: StringFilter<"ScheduleParticipant"> | string
    Schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>
    Participant?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "scheduleId_userId">

  export type ScheduleParticipantOrderByWithAggregationInput = {
    scheduleId?: SortOrder
    userId?: SortOrder
    _count?: ScheduleParticipantCountOrderByAggregateInput
    _max?: ScheduleParticipantMaxOrderByAggregateInput
    _min?: ScheduleParticipantMinOrderByAggregateInput
  }

  export type ScheduleParticipantScalarWhereWithAggregatesInput = {
    AND?: ScheduleParticipantScalarWhereWithAggregatesInput | ScheduleParticipantScalarWhereWithAggregatesInput[]
    OR?: ScheduleParticipantScalarWhereWithAggregatesInput[]
    NOT?: ScheduleParticipantScalarWhereWithAggregatesInput | ScheduleParticipantScalarWhereWithAggregatesInput[]
    scheduleId?: StringWithAggregatesFilter<"ScheduleParticipant"> | string
    userId?: StringWithAggregatesFilter<"ScheduleParticipant"> | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    title?: StringFilter<"Lead"> | string
    customerId?: StringFilter<"Lead"> | string
    userId?: StringNullableFilter<"Lead"> | string | null
    laneId?: IntFilter<"Lead"> | number
    value?: IntFilter<"Lead"> | number
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    lostedLeadReasonId?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    Campaigns?: LeadCampaignListRelationFilter
    Customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    Broker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Tags?: LeadTagListRelationFilter
    Documents?: LeadDocumentListRelationFilter
    Comments?: LeadCommentListRelationFilter
    Metadata?: LeadMetadataListRelationFilter
    Chats?: LeadChatListRelationFilter
    Schedules?: ScheduleListRelationFilter
    Lane?: XOR<LaneScalarRelationFilter, LaneWhereInput>
    LostedReason?: XOR<LeadLostReasonNullableScalarRelationFilter, LeadLostReasonWhereInput> | null
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    customerId?: SortOrder
    userId?: SortOrderInput | SortOrder
    laneId?: SortOrder
    value?: SortOrder
    status?: SortOrder
    lostedLeadReasonId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Campaigns?: LeadCampaignOrderByRelationAggregateInput
    Customer?: CustomerOrderByWithRelationInput
    Broker?: UserOrderByWithRelationInput
    Tags?: LeadTagOrderByRelationAggregateInput
    Documents?: LeadDocumentOrderByRelationAggregateInput
    Comments?: LeadCommentOrderByRelationAggregateInput
    Metadata?: LeadMetadataOrderByRelationAggregateInput
    Chats?: LeadChatOrderByRelationAggregateInput
    Schedules?: ScheduleOrderByRelationAggregateInput
    Lane?: LaneOrderByWithRelationInput
    LostedReason?: LeadLostReasonOrderByWithRelationInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    title?: StringFilter<"Lead"> | string
    customerId?: StringFilter<"Lead"> | string
    userId?: StringNullableFilter<"Lead"> | string | null
    laneId?: IntFilter<"Lead"> | number
    value?: IntFilter<"Lead"> | number
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    lostedLeadReasonId?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    Campaigns?: LeadCampaignListRelationFilter
    Customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    Broker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Tags?: LeadTagListRelationFilter
    Documents?: LeadDocumentListRelationFilter
    Comments?: LeadCommentListRelationFilter
    Metadata?: LeadMetadataListRelationFilter
    Chats?: LeadChatListRelationFilter
    Schedules?: ScheduleListRelationFilter
    Lane?: XOR<LaneScalarRelationFilter, LaneWhereInput>
    LostedReason?: XOR<LeadLostReasonNullableScalarRelationFilter, LeadLostReasonWhereInput> | null
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    customerId?: SortOrder
    userId?: SortOrderInput | SortOrder
    laneId?: SortOrder
    value?: SortOrder
    status?: SortOrder
    lostedLeadReasonId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    title?: StringWithAggregatesFilter<"Lead"> | string
    customerId?: StringWithAggregatesFilter<"Lead"> | string
    userId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    laneId?: IntWithAggregatesFilter<"Lead"> | number
    value?: IntWithAggregatesFilter<"Lead"> | number
    status?: EnumLeadStatusWithAggregatesFilter<"Lead"> | $Enums.LeadStatus
    lostedLeadReasonId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
  }

  export type LeadMetadataWhereInput = {
    AND?: LeadMetadataWhereInput | LeadMetadataWhereInput[]
    OR?: LeadMetadataWhereInput[]
    NOT?: LeadMetadataWhereInput | LeadMetadataWhereInput[]
    id?: StringFilter<"LeadMetadata"> | string
    leadId?: StringFilter<"LeadMetadata"> | string
    key?: StringFilter<"LeadMetadata"> | string
    value?: StringFilter<"LeadMetadata"> | string
    createdAt?: DateTimeFilter<"LeadMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"LeadMetadata"> | Date | string
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
  }

  export type LeadMetadataOrderByWithRelationInput = {
    id?: SortOrder
    leadId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Lead?: LeadOrderByWithRelationInput
  }

  export type LeadMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadMetadataWhereInput | LeadMetadataWhereInput[]
    OR?: LeadMetadataWhereInput[]
    NOT?: LeadMetadataWhereInput | LeadMetadataWhereInput[]
    leadId?: StringFilter<"LeadMetadata"> | string
    key?: StringFilter<"LeadMetadata"> | string
    value?: StringFilter<"LeadMetadata"> | string
    createdAt?: DateTimeFilter<"LeadMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"LeadMetadata"> | Date | string
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
  }, "id">

  export type LeadMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    leadId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadMetadataCountOrderByAggregateInput
    _max?: LeadMetadataMaxOrderByAggregateInput
    _min?: LeadMetadataMinOrderByAggregateInput
  }

  export type LeadMetadataScalarWhereWithAggregatesInput = {
    AND?: LeadMetadataScalarWhereWithAggregatesInput | LeadMetadataScalarWhereWithAggregatesInput[]
    OR?: LeadMetadataScalarWhereWithAggregatesInput[]
    NOT?: LeadMetadataScalarWhereWithAggregatesInput | LeadMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadMetadata"> | string
    leadId?: StringWithAggregatesFilter<"LeadMetadata"> | string
    key?: StringWithAggregatesFilter<"LeadMetadata"> | string
    value?: StringWithAggregatesFilter<"LeadMetadata"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeadMetadata"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeadMetadata"> | Date | string
  }

  export type LeadLostReasonWhereInput = {
    AND?: LeadLostReasonWhereInput | LeadLostReasonWhereInput[]
    OR?: LeadLostReasonWhereInput[]
    NOT?: LeadLostReasonWhereInput | LeadLostReasonWhereInput[]
    id?: StringFilter<"LeadLostReason"> | string
    reason?: StringFilter<"LeadLostReason"> | string
    createdAt?: DateTimeFilter<"LeadLostReason"> | Date | string
    updatedAt?: DateTimeFilter<"LeadLostReason"> | Date | string
    Leads?: LeadListRelationFilter
  }

  export type LeadLostReasonOrderByWithRelationInput = {
    id?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Leads?: LeadOrderByRelationAggregateInput
  }

  export type LeadLostReasonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadLostReasonWhereInput | LeadLostReasonWhereInput[]
    OR?: LeadLostReasonWhereInput[]
    NOT?: LeadLostReasonWhereInput | LeadLostReasonWhereInput[]
    reason?: StringFilter<"LeadLostReason"> | string
    createdAt?: DateTimeFilter<"LeadLostReason"> | Date | string
    updatedAt?: DateTimeFilter<"LeadLostReason"> | Date | string
    Leads?: LeadListRelationFilter
  }, "id">

  export type LeadLostReasonOrderByWithAggregationInput = {
    id?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadLostReasonCountOrderByAggregateInput
    _max?: LeadLostReasonMaxOrderByAggregateInput
    _min?: LeadLostReasonMinOrderByAggregateInput
  }

  export type LeadLostReasonScalarWhereWithAggregatesInput = {
    AND?: LeadLostReasonScalarWhereWithAggregatesInput | LeadLostReasonScalarWhereWithAggregatesInput[]
    OR?: LeadLostReasonScalarWhereWithAggregatesInput[]
    NOT?: LeadLostReasonScalarWhereWithAggregatesInput | LeadLostReasonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadLostReason"> | string
    reason?: StringWithAggregatesFilter<"LeadLostReason"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeadLostReason"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeadLostReason"> | Date | string
  }

  export type LeadCommentWhereInput = {
    AND?: LeadCommentWhereInput | LeadCommentWhereInput[]
    OR?: LeadCommentWhereInput[]
    NOT?: LeadCommentWhereInput | LeadCommentWhereInput[]
    id?: StringFilter<"LeadComment"> | string
    leadId?: StringFilter<"LeadComment"> | string
    userId?: StringFilter<"LeadComment"> | string
    content?: StringFilter<"LeadComment"> | string
    deleted?: BoolFilter<"LeadComment"> | boolean
    createdAt?: DateTimeFilter<"LeadComment"> | Date | string
    updatedAt?: DateTimeFilter<"LeadComment"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
  }

  export type LeadCommentOrderByWithRelationInput = {
    id?: SortOrder
    leadId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Lead?: LeadOrderByWithRelationInput
  }

  export type LeadCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadCommentWhereInput | LeadCommentWhereInput[]
    OR?: LeadCommentWhereInput[]
    NOT?: LeadCommentWhereInput | LeadCommentWhereInput[]
    leadId?: StringFilter<"LeadComment"> | string
    userId?: StringFilter<"LeadComment"> | string
    content?: StringFilter<"LeadComment"> | string
    deleted?: BoolFilter<"LeadComment"> | boolean
    createdAt?: DateTimeFilter<"LeadComment"> | Date | string
    updatedAt?: DateTimeFilter<"LeadComment"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
  }, "id">

  export type LeadCommentOrderByWithAggregationInput = {
    id?: SortOrder
    leadId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadCommentCountOrderByAggregateInput
    _max?: LeadCommentMaxOrderByAggregateInput
    _min?: LeadCommentMinOrderByAggregateInput
  }

  export type LeadCommentScalarWhereWithAggregatesInput = {
    AND?: LeadCommentScalarWhereWithAggregatesInput | LeadCommentScalarWhereWithAggregatesInput[]
    OR?: LeadCommentScalarWhereWithAggregatesInput[]
    NOT?: LeadCommentScalarWhereWithAggregatesInput | LeadCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeadComment"> | string
    leadId?: StringWithAggregatesFilter<"LeadComment"> | string
    userId?: StringWithAggregatesFilter<"LeadComment"> | string
    content?: StringWithAggregatesFilter<"LeadComment"> | string
    deleted?: BoolWithAggregatesFilter<"LeadComment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LeadComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeadComment"> | Date | string
  }

  export type LeadChatWhereInput = {
    AND?: LeadChatWhereInput | LeadChatWhereInput[]
    OR?: LeadChatWhereInput[]
    NOT?: LeadChatWhereInput | LeadChatWhereInput[]
    leadId?: StringFilter<"LeadChat"> | string
    conversationId?: StringFilter<"LeadChat"> | string
    status?: StringFilter<"LeadChat"> | string
    createdAt?: DateTimeFilter<"LeadChat"> | Date | string
    updatedAt?: DateTimeFilter<"LeadChat"> | Date | string
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
  }

  export type LeadChatOrderByWithRelationInput = {
    leadId?: SortOrder
    conversationId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Lead?: LeadOrderByWithRelationInput
  }

  export type LeadChatWhereUniqueInput = Prisma.AtLeast<{
    leadId_conversationId?: LeadChatLeadIdConversationIdCompoundUniqueInput
    AND?: LeadChatWhereInput | LeadChatWhereInput[]
    OR?: LeadChatWhereInput[]
    NOT?: LeadChatWhereInput | LeadChatWhereInput[]
    leadId?: StringFilter<"LeadChat"> | string
    conversationId?: StringFilter<"LeadChat"> | string
    status?: StringFilter<"LeadChat"> | string
    createdAt?: DateTimeFilter<"LeadChat"> | Date | string
    updatedAt?: DateTimeFilter<"LeadChat"> | Date | string
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
  }, "leadId_conversationId">

  export type LeadChatOrderByWithAggregationInput = {
    leadId?: SortOrder
    conversationId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadChatCountOrderByAggregateInput
    _max?: LeadChatMaxOrderByAggregateInput
    _min?: LeadChatMinOrderByAggregateInput
  }

  export type LeadChatScalarWhereWithAggregatesInput = {
    AND?: LeadChatScalarWhereWithAggregatesInput | LeadChatScalarWhereWithAggregatesInput[]
    OR?: LeadChatScalarWhereWithAggregatesInput[]
    NOT?: LeadChatScalarWhereWithAggregatesInput | LeadChatScalarWhereWithAggregatesInput[]
    leadId?: StringWithAggregatesFilter<"LeadChat"> | string
    conversationId?: StringWithAggregatesFilter<"LeadChat"> | string
    status?: StringWithAggregatesFilter<"LeadChat"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeadChat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeadChat"> | Date | string
  }

  export type LeadDocumentWhereInput = {
    AND?: LeadDocumentWhereInput | LeadDocumentWhereInput[]
    OR?: LeadDocumentWhereInput[]
    NOT?: LeadDocumentWhereInput | LeadDocumentWhereInput[]
    leadId?: StringFilter<"LeadDocument"> | string
    name?: StringFilter<"LeadDocument"> | string
    path?: StringFilter<"LeadDocument"> | string
    userId?: StringNullableFilter<"LeadDocument"> | string | null
    createdAt?: DateTimeFilter<"LeadDocument"> | Date | string
    updatedAt?: DateTimeFilter<"LeadDocument"> | Date | string
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LeadDocumentOrderByWithRelationInput = {
    leadId?: SortOrder
    name?: SortOrder
    path?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Lead?: LeadOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type LeadDocumentWhereUniqueInput = Prisma.AtLeast<{
    leadId_path?: LeadDocumentLeadIdPathCompoundUniqueInput
    AND?: LeadDocumentWhereInput | LeadDocumentWhereInput[]
    OR?: LeadDocumentWhereInput[]
    NOT?: LeadDocumentWhereInput | LeadDocumentWhereInput[]
    leadId?: StringFilter<"LeadDocument"> | string
    name?: StringFilter<"LeadDocument"> | string
    path?: StringFilter<"LeadDocument"> | string
    userId?: StringNullableFilter<"LeadDocument"> | string | null
    createdAt?: DateTimeFilter<"LeadDocument"> | Date | string
    updatedAt?: DateTimeFilter<"LeadDocument"> | Date | string
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "leadId_path">

  export type LeadDocumentOrderByWithAggregationInput = {
    leadId?: SortOrder
    name?: SortOrder
    path?: SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadDocumentCountOrderByAggregateInput
    _max?: LeadDocumentMaxOrderByAggregateInput
    _min?: LeadDocumentMinOrderByAggregateInput
  }

  export type LeadDocumentScalarWhereWithAggregatesInput = {
    AND?: LeadDocumentScalarWhereWithAggregatesInput | LeadDocumentScalarWhereWithAggregatesInput[]
    OR?: LeadDocumentScalarWhereWithAggregatesInput[]
    NOT?: LeadDocumentScalarWhereWithAggregatesInput | LeadDocumentScalarWhereWithAggregatesInput[]
    leadId?: StringWithAggregatesFilter<"LeadDocument"> | string
    name?: StringWithAggregatesFilter<"LeadDocument"> | string
    path?: StringWithAggregatesFilter<"LeadDocument"> | string
    userId?: StringNullableWithAggregatesFilter<"LeadDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LeadDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeadDocument"> | Date | string
  }

  export type LaneWhereInput = {
    AND?: LaneWhereInput | LaneWhereInput[]
    OR?: LaneWhereInput[]
    NOT?: LaneWhereInput | LaneWhereInput[]
    id?: IntFilter<"Lane"> | number
    name?: StringFilter<"Lane"> | string
    color?: StringFilter<"Lane"> | string
    sortOrder?: IntFilter<"Lane"> | number
    principal?: BoolFilter<"Lane"> | boolean
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    Leads?: LeadListRelationFilter
  }

  export type LaneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    principal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Leads?: LeadOrderByRelationAggregateInput
  }

  export type LaneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LaneWhereInput | LaneWhereInput[]
    OR?: LaneWhereInput[]
    NOT?: LaneWhereInput | LaneWhereInput[]
    name?: StringFilter<"Lane"> | string
    color?: StringFilter<"Lane"> | string
    sortOrder?: IntFilter<"Lane"> | number
    principal?: BoolFilter<"Lane"> | boolean
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    Leads?: LeadListRelationFilter
  }, "id">

  export type LaneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    principal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaneCountOrderByAggregateInput
    _avg?: LaneAvgOrderByAggregateInput
    _max?: LaneMaxOrderByAggregateInput
    _min?: LaneMinOrderByAggregateInput
    _sum?: LaneSumOrderByAggregateInput
  }

  export type LaneScalarWhereWithAggregatesInput = {
    AND?: LaneScalarWhereWithAggregatesInput | LaneScalarWhereWithAggregatesInput[]
    OR?: LaneScalarWhereWithAggregatesInput[]
    NOT?: LaneScalarWhereWithAggregatesInput | LaneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lane"> | number
    name?: StringWithAggregatesFilter<"Lane"> | string
    color?: StringWithAggregatesFilter<"Lane"> | string
    sortOrder?: IntWithAggregatesFilter<"Lane"> | number
    principal?: BoolWithAggregatesFilter<"Lane"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Lane"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lane"> | Date | string
  }

  export type ConstructionCompanyWhereInput = {
    AND?: ConstructionCompanyWhereInput | ConstructionCompanyWhereInput[]
    OR?: ConstructionCompanyWhereInput[]
    NOT?: ConstructionCompanyWhereInput | ConstructionCompanyWhereInput[]
    id?: StringFilter<"ConstructionCompany"> | string
    name?: StringFilter<"ConstructionCompany"> | string
    email?: StringFilter<"ConstructionCompany"> | string
    createdAt?: DateTimeFilter<"ConstructionCompany"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionCompany"> | Date | string
    Projects?: ProjectListRelationFilter
    Contacts?: ContactListRelationFilter
  }

  export type ConstructionCompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Projects?: ProjectOrderByRelationAggregateInput
    Contacts?: ContactOrderByRelationAggregateInput
  }

  export type ConstructionCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConstructionCompanyWhereInput | ConstructionCompanyWhereInput[]
    OR?: ConstructionCompanyWhereInput[]
    NOT?: ConstructionCompanyWhereInput | ConstructionCompanyWhereInput[]
    name?: StringFilter<"ConstructionCompany"> | string
    email?: StringFilter<"ConstructionCompany"> | string
    createdAt?: DateTimeFilter<"ConstructionCompany"> | Date | string
    updatedAt?: DateTimeFilter<"ConstructionCompany"> | Date | string
    Projects?: ProjectListRelationFilter
    Contacts?: ContactListRelationFilter
  }, "id">

  export type ConstructionCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConstructionCompanyCountOrderByAggregateInput
    _max?: ConstructionCompanyMaxOrderByAggregateInput
    _min?: ConstructionCompanyMinOrderByAggregateInput
  }

  export type ConstructionCompanyScalarWhereWithAggregatesInput = {
    AND?: ConstructionCompanyScalarWhereWithAggregatesInput | ConstructionCompanyScalarWhereWithAggregatesInput[]
    OR?: ConstructionCompanyScalarWhereWithAggregatesInput[]
    NOT?: ConstructionCompanyScalarWhereWithAggregatesInput | ConstructionCompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConstructionCompany"> | string
    name?: StringWithAggregatesFilter<"ConstructionCompany"> | string
    email?: StringWithAggregatesFilter<"ConstructionCompany"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConstructionCompany"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConstructionCompany"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    url?: StringFilter<"Project"> | string
    constructionId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    Campaigns?: CampaignListRelationFilter
    ConstructionCompany?: XOR<ConstructionCompanyScalarRelationFilter, ConstructionCompanyWhereInput>
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    constructionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Campaigns?: CampaignOrderByRelationAggregateInput
    ConstructionCompany?: ConstructionCompanyOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    title?: StringFilter<"Project"> | string
    url?: StringFilter<"Project"> | string
    constructionId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    Campaigns?: CampaignListRelationFilter
    ConstructionCompany?: XOR<ConstructionCompanyScalarRelationFilter, ConstructionCompanyWhereInput>
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    constructionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    title?: StringWithAggregatesFilter<"Project"> | string
    url?: StringWithAggregatesFilter<"Project"> | string
    constructionId?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    title?: StringFilter<"Campaign"> | string
    sourceId?: StringNullableFilter<"Campaign"> | string | null
    projectId?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    Leads?: LeadCampaignListRelationFilter
    Source?: XOR<CampaignSourceNullableScalarRelationFilter, CampaignSourceWhereInput> | null
    Project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Leads?: LeadCampaignOrderByRelationAggregateInput
    Source?: CampaignSourceOrderByWithRelationInput
    Project?: ProjectOrderByWithRelationInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    title?: StringFilter<"Campaign"> | string
    sourceId?: StringNullableFilter<"Campaign"> | string | null
    projectId?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    Leads?: LeadCampaignListRelationFilter
    Source?: XOR<CampaignSourceNullableScalarRelationFilter, CampaignSourceWhereInput> | null
    Project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    title?: StringWithAggregatesFilter<"Campaign"> | string
    sourceId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    projectId?: StringWithAggregatesFilter<"Campaign"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type LeadCampaignWhereInput = {
    AND?: LeadCampaignWhereInput | LeadCampaignWhereInput[]
    OR?: LeadCampaignWhereInput[]
    NOT?: LeadCampaignWhereInput | LeadCampaignWhereInput[]
    leadId?: StringFilter<"LeadCampaign"> | string
    campaignId?: StringFilter<"LeadCampaign"> | string
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type LeadCampaignOrderByWithRelationInput = {
    leadId?: SortOrder
    campaignId?: SortOrder
    Lead?: LeadOrderByWithRelationInput
    Campaign?: CampaignOrderByWithRelationInput
  }

  export type LeadCampaignWhereUniqueInput = Prisma.AtLeast<{
    leadId_campaignId?: LeadCampaignLeadIdCampaignIdCompoundUniqueInput
    AND?: LeadCampaignWhereInput | LeadCampaignWhereInput[]
    OR?: LeadCampaignWhereInput[]
    NOT?: LeadCampaignWhereInput | LeadCampaignWhereInput[]
    leadId?: StringFilter<"LeadCampaign"> | string
    campaignId?: StringFilter<"LeadCampaign"> | string
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "leadId_campaignId">

  export type LeadCampaignOrderByWithAggregationInput = {
    leadId?: SortOrder
    campaignId?: SortOrder
    _count?: LeadCampaignCountOrderByAggregateInput
    _max?: LeadCampaignMaxOrderByAggregateInput
    _min?: LeadCampaignMinOrderByAggregateInput
  }

  export type LeadCampaignScalarWhereWithAggregatesInput = {
    AND?: LeadCampaignScalarWhereWithAggregatesInput | LeadCampaignScalarWhereWithAggregatesInput[]
    OR?: LeadCampaignScalarWhereWithAggregatesInput[]
    NOT?: LeadCampaignScalarWhereWithAggregatesInput | LeadCampaignScalarWhereWithAggregatesInput[]
    leadId?: StringWithAggregatesFilter<"LeadCampaign"> | string
    campaignId?: StringWithAggregatesFilter<"LeadCampaign"> | string
  }

  export type CampaignSourceWhereInput = {
    AND?: CampaignSourceWhereInput | CampaignSourceWhereInput[]
    OR?: CampaignSourceWhereInput[]
    NOT?: CampaignSourceWhereInput | CampaignSourceWhereInput[]
    id?: StringFilter<"CampaignSource"> | string
    title?: StringFilter<"CampaignSource"> | string
    createdAt?: DateTimeFilter<"CampaignSource"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignSource"> | Date | string
    Campaigns?: CampaignListRelationFilter
  }

  export type CampaignSourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type CampaignSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignSourceWhereInput | CampaignSourceWhereInput[]
    OR?: CampaignSourceWhereInput[]
    NOT?: CampaignSourceWhereInput | CampaignSourceWhereInput[]
    title?: StringFilter<"CampaignSource"> | string
    createdAt?: DateTimeFilter<"CampaignSource"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignSource"> | Date | string
    Campaigns?: CampaignListRelationFilter
  }, "id">

  export type CampaignSourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignSourceCountOrderByAggregateInput
    _max?: CampaignSourceMaxOrderByAggregateInput
    _min?: CampaignSourceMinOrderByAggregateInput
  }

  export type CampaignSourceScalarWhereWithAggregatesInput = {
    AND?: CampaignSourceScalarWhereWithAggregatesInput | CampaignSourceScalarWhereWithAggregatesInput[]
    OR?: CampaignSourceScalarWhereWithAggregatesInput[]
    NOT?: CampaignSourceScalarWhereWithAggregatesInput | CampaignSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignSource"> | string
    title?: StringWithAggregatesFilter<"CampaignSource"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CampaignSource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignSource"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    description?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    Leads?: LeadTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Leads?: LeadTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    description?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    Leads?: LeadTagListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type LeadTagWhereInput = {
    AND?: LeadTagWhereInput | LeadTagWhereInput[]
    OR?: LeadTagWhereInput[]
    NOT?: LeadTagWhereInput | LeadTagWhereInput[]
    leadId?: StringFilter<"LeadTag"> | string
    tagId?: StringFilter<"LeadTag"> | string
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    Tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type LeadTagOrderByWithRelationInput = {
    leadId?: SortOrder
    tagId?: SortOrder
    Lead?: LeadOrderByWithRelationInput
    Tag?: TagOrderByWithRelationInput
  }

  export type LeadTagWhereUniqueInput = Prisma.AtLeast<{
    tagId_leadId?: LeadTagTagIdLeadIdCompoundUniqueInput
    AND?: LeadTagWhereInput | LeadTagWhereInput[]
    OR?: LeadTagWhereInput[]
    NOT?: LeadTagWhereInput | LeadTagWhereInput[]
    leadId?: StringFilter<"LeadTag"> | string
    tagId?: StringFilter<"LeadTag"> | string
    Lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    Tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "tagId_leadId">

  export type LeadTagOrderByWithAggregationInput = {
    leadId?: SortOrder
    tagId?: SortOrder
    _count?: LeadTagCountOrderByAggregateInput
    _max?: LeadTagMaxOrderByAggregateInput
    _min?: LeadTagMinOrderByAggregateInput
  }

  export type LeadTagScalarWhereWithAggregatesInput = {
    AND?: LeadTagScalarWhereWithAggregatesInput | LeadTagScalarWhereWithAggregatesInput[]
    OR?: LeadTagScalarWhereWithAggregatesInput[]
    NOT?: LeadTagScalarWhereWithAggregatesInput | LeadTagScalarWhereWithAggregatesInput[]
    leadId?: StringWithAggregatesFilter<"LeadTag"> | string
    tagId?: StringWithAggregatesFilter<"LeadTag"> | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringFilter<"Contact"> | string
    constructionCompanyId?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    ConstructionCompany?: XOR<ConstructionCompanyScalarRelationFilter, ConstructionCompanyWhereInput>
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    constructionCompanyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ConstructionCompany?: ConstructionCompanyOrderByWithRelationInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringFilter<"Contact"> | string
    constructionCompanyId?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    ConstructionCompany?: XOR<ConstructionCompanyScalarRelationFilter, ConstructionCompanyWhereInput>
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    constructionCompanyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    phone?: StringWithAggregatesFilter<"Contact"> | string
    constructionCompanyId?: StringWithAggregatesFilter<"Contact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionCreateNestedManyWithoutUserInput
    Leads?: LeadCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentCreateNestedManyWithoutUserInput
    Schedules?: ScheduleCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantCreateNestedManyWithoutParticipantInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    Leads?: LeadUncheckedCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentUncheckedCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentUncheckedCreateNestedManyWithoutUserInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    Leads?: LeadUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUpdateManyWithoutParticipantNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    Leads?: LeadUncheckedUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUncheckedUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUncheckedUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    slug: string
    description: string
    Users?: UserPermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    slug: string
    description: string
    Users?: UserPermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    Users?: UserPermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    Users?: UserPermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    slug: string
    description: string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type UserPermissionCreateInput = {
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutPermissionsInput
    Permission: PermissionCreateNestedOneWithoutUsersInput
  }

  export type UserPermissionUncheckedCreateInput = {
    userId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type UserPermissionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutPermissionsNestedInput
    Permission?: PermissionUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserPermissionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPermissionCreateManyInput = {
    userId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type UserPermissionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPermissionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    picture: string
    name: string
    phone: string
    email: string
    chatwootContactId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    picture: string
    name: string
    phone: string
    email: string
    chatwootContactId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    chatwootContactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    chatwootContactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    picture: string
    name: string
    phone: string
    email: string
    chatwootContactId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    chatwootContactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    chatwootContactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateInput = {
    id?: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutSchedulesInput
    Lead: LeadCreateNestedOneWithoutSchedulesInput
    Participants?: ScheduleParticipantCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    userId: string
    leadId: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Participants?: ScheduleParticipantUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutSchedulesNestedInput
    Lead?: LeadUpdateOneRequiredWithoutSchedulesNestedInput
    Participants?: ScheduleParticipantUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Participants?: ScheduleParticipantUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleCreateManyInput = {
    id?: string
    userId: string
    leadId: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleParticipantCreateInput = {
    Schedule: ScheduleCreateNestedOneWithoutParticipantsInput
    Participant: UserCreateNestedOneWithoutScheduleParticipatingInput
  }

  export type ScheduleParticipantUncheckedCreateInput = {
    scheduleId: string
    userId: string
  }

  export type ScheduleParticipantUpdateInput = {
    Schedule?: ScheduleUpdateOneRequiredWithoutParticipantsNestedInput
    Participant?: UserUpdateOneRequiredWithoutScheduleParticipatingNestedInput
  }

  export type ScheduleParticipantUncheckedUpdateInput = {
    scheduleId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleParticipantCreateManyInput = {
    scheduleId: string
    userId: string
  }

  export type ScheduleParticipantUpdateManyMutationInput = {

  }

  export type ScheduleParticipantUncheckedUpdateManyInput = {
    scheduleId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCreateInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadMetadataCreateInput = {
    id?: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Lead: LeadCreateNestedOneWithoutMetadataInput
  }

  export type LeadMetadataUncheckedCreateInput = {
    id?: string
    leadId: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lead?: LeadUpdateOneRequiredWithoutMetadataNestedInput
  }

  export type LeadMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadMetadataCreateManyInput = {
    id?: string
    leadId: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadLostReasonCreateInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadCreateNestedManyWithoutLostedReasonInput
  }

  export type LeadLostReasonUncheckedCreateInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadUncheckedCreateNestedManyWithoutLostedReasonInput
  }

  export type LeadLostReasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadUpdateManyWithoutLostedReasonNestedInput
  }

  export type LeadLostReasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadUncheckedUpdateManyWithoutLostedReasonNestedInput
  }

  export type LeadLostReasonCreateManyInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadLostReasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadLostReasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCommentCreateInput = {
    id?: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutLeadCommentsInput
    Lead: LeadCreateNestedOneWithoutCommentsInput
  }

  export type LeadCommentUncheckedCreateInput = {
    id?: string
    leadId: string
    userId: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutLeadCommentsNestedInput
    Lead?: LeadUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type LeadCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCommentCreateManyInput = {
    id?: string
    leadId: string
    userId: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadChatCreateInput = {
    conversationId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Lead: LeadCreateNestedOneWithoutChatsInput
  }

  export type LeadChatUncheckedCreateInput = {
    leadId: string
    conversationId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadChatUpdateInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lead?: LeadUpdateOneRequiredWithoutChatsNestedInput
  }

  export type LeadChatUncheckedUpdateInput = {
    leadId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadChatCreateManyInput = {
    leadId: string
    conversationId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadChatUpdateManyMutationInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadChatUncheckedUpdateManyInput = {
    leadId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadDocumentCreateInput = {
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Lead: LeadCreateNestedOneWithoutDocumentsInput
    User?: UserCreateNestedOneWithoutLeadDocumentsInput
  }

  export type LeadDocumentUncheckedCreateInput = {
    leadId: string
    name: string
    path: string
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadDocumentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lead?: LeadUpdateOneRequiredWithoutDocumentsNestedInput
    User?: UserUpdateOneWithoutLeadDocumentsNestedInput
  }

  export type LeadDocumentUncheckedUpdateInput = {
    leadId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadDocumentCreateManyInput = {
    leadId: string
    name: string
    path: string
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadDocumentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadDocumentUncheckedUpdateManyInput = {
    leadId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaneCreateInput = {
    name: string
    color: string
    sortOrder: number
    principal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadCreateNestedManyWithoutLaneInput
  }

  export type LaneUncheckedCreateInput = {
    id?: number
    name: string
    color: string
    sortOrder: number
    principal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadUncheckedCreateNestedManyWithoutLaneInput
  }

  export type LaneUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadUpdateManyWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadUncheckedUpdateManyWithoutLaneNestedInput
  }

  export type LaneCreateManyInput = {
    id?: number
    name: string
    color: string
    sortOrder: number
    principal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaneUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionCompanyCreateInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Projects?: ProjectCreateNestedManyWithoutConstructionCompanyInput
    Contacts?: ContactCreateNestedManyWithoutConstructionCompanyInput
  }

  export type ConstructionCompanyUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Projects?: ProjectUncheckedCreateNestedManyWithoutConstructionCompanyInput
    Contacts?: ContactUncheckedCreateNestedManyWithoutConstructionCompanyInput
  }

  export type ConstructionCompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Projects?: ProjectUpdateManyWithoutConstructionCompanyNestedInput
    Contacts?: ContactUpdateManyWithoutConstructionCompanyNestedInput
  }

  export type ConstructionCompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Projects?: ProjectUncheckedUpdateManyWithoutConstructionCompanyNestedInput
    Contacts?: ContactUncheckedUpdateManyWithoutConstructionCompanyNestedInput
  }

  export type ConstructionCompanyCreateManyInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConstructionCompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionCompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    title: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: CampaignCreateNestedManyWithoutProjectInput
    ConstructionCompany: ConstructionCompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    title: string
    url: string
    constructionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: CampaignUpdateManyWithoutProjectNestedInput
    ConstructionCompany?: ConstructionCompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    constructionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: CampaignUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    title: string
    url: string
    constructionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    constructionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadCampaignCreateNestedManyWithoutCampaignInput
    Source?: CampaignSourceCreateNestedOneWithoutCampaignsInput
    Project: ProjectCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    title: string
    sourceId?: string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadCampaignUpdateManyWithoutCampaignNestedInput
    Source?: CampaignSourceUpdateOneWithoutCampaignsNestedInput
    Project?: ProjectUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    title: string
    sourceId?: string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCampaignCreateInput = {
    Lead: LeadCreateNestedOneWithoutCampaignsInput
    Campaign: CampaignCreateNestedOneWithoutLeadsInput
  }

  export type LeadCampaignUncheckedCreateInput = {
    leadId: string
    campaignId: string
  }

  export type LeadCampaignUpdateInput = {
    Lead?: LeadUpdateOneRequiredWithoutCampaignsNestedInput
    Campaign?: CampaignUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadCampaignUncheckedUpdateInput = {
    leadId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCampaignCreateManyInput = {
    leadId: string
    campaignId: string
  }

  export type LeadCampaignUpdateManyMutationInput = {

  }

  export type LeadCampaignUncheckedUpdateManyInput = {
    leadId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignSourceCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: CampaignCreateNestedManyWithoutSourceInput
  }

  export type CampaignSourceUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutSourceInput
  }

  export type CampaignSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: CampaignUpdateManyWithoutSourceNestedInput
  }

  export type CampaignSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: CampaignUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type CampaignSourceCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    description: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    description: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadTagCreateInput = {
    Lead: LeadCreateNestedOneWithoutTagsInput
    Tag: TagCreateNestedOneWithoutLeadsInput
  }

  export type LeadTagUncheckedCreateInput = {
    leadId: string
    tagId: string
  }

  export type LeadTagUpdateInput = {
    Lead?: LeadUpdateOneRequiredWithoutTagsNestedInput
    Tag?: TagUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadTagUncheckedUpdateInput = {
    leadId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadTagCreateManyInput = {
    leadId: string
    tagId: string
  }

  export type LeadTagUpdateManyMutationInput = {

  }

  export type LeadTagUncheckedUpdateManyInput = {
    leadId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ConstructionCompany: ConstructionCompanyCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    constructionCompanyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConstructionCompany?: ConstructionCompanyUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    constructionCompanyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyInput = {
    id?: string
    name: string
    email: string
    phone: string
    constructionCompanyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    constructionCompanyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UserPermissionListRelationFilter = {
    every?: UserPermissionWhereInput
    some?: UserPermissionWhereInput
    none?: UserPermissionWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type LeadCommentListRelationFilter = {
    every?: LeadCommentWhereInput
    some?: LeadCommentWhereInput
    none?: LeadCommentWhereInput
  }

  export type LeadDocumentListRelationFilter = {
    every?: LeadDocumentWhereInput
    some?: LeadDocumentWhereInput
    none?: LeadDocumentWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type ScheduleParticipantListRelationFilter = {
    every?: ScheduleParticipantWhereInput
    some?: ScheduleParticipantWhereInput
    none?: ScheduleParticipantWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    master?: SortOrder
    status?: SortOrder
    chatwootAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    master?: SortOrder
    status?: SortOrder
    chatwootAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    master?: SortOrder
    status?: SortOrder
    chatwootAgentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    description?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    description?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    description?: SortOrder
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type UserPermissionUserIdPermissionIdCompoundUniqueInput = {
    userId: string
    permissionId: string
  }

  export type UserPermissionCountOrderByAggregateInput = {
    userId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPermissionMaxOrderByAggregateInput = {
    userId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPermissionMinOrderByAggregateInput = {
    userId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    chatwootContactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    chatwootContactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    chatwootContactId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumScheduleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusFilter<$PrismaModel> | $Enums.ScheduleStatus
  }

  export type LeadScalarRelationFilter = {
    is?: LeadWhereInput
    isNot?: LeadWhereInput
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leadId?: SortOrder
    date?: SortOrder
    address?: SortOrder
    nextNotificationAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leadId?: SortOrder
    date?: SortOrder
    address?: SortOrder
    nextNotificationAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leadId?: SortOrder
    date?: SortOrder
    address?: SortOrder
    nextNotificationAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumScheduleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduleStatusFilter<$PrismaModel>
  }

  export type ScheduleScalarRelationFilter = {
    is?: ScheduleWhereInput
    isNot?: ScheduleWhereInput
  }

  export type ScheduleParticipantScheduleIdUserIdCompoundUniqueInput = {
    scheduleId: string
    userId: string
  }

  export type ScheduleParticipantCountOrderByAggregateInput = {
    scheduleId?: SortOrder
    userId?: SortOrder
  }

  export type ScheduleParticipantMaxOrderByAggregateInput = {
    scheduleId?: SortOrder
    userId?: SortOrder
  }

  export type ScheduleParticipantMinOrderByAggregateInput = {
    scheduleId?: SortOrder
    userId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type LeadCampaignListRelationFilter = {
    every?: LeadCampaignWhereInput
    some?: LeadCampaignWhereInput
    none?: LeadCampaignWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LeadTagListRelationFilter = {
    every?: LeadTagWhereInput
    some?: LeadTagWhereInput
    none?: LeadTagWhereInput
  }

  export type LeadMetadataListRelationFilter = {
    every?: LeadMetadataWhereInput
    some?: LeadMetadataWhereInput
    none?: LeadMetadataWhereInput
  }

  export type LeadChatListRelationFilter = {
    every?: LeadChatWhereInput
    some?: LeadChatWhereInput
    none?: LeadChatWhereInput
  }

  export type LaneScalarRelationFilter = {
    is?: LaneWhereInput
    isNot?: LaneWhereInput
  }

  export type LeadLostReasonNullableScalarRelationFilter = {
    is?: LeadLostReasonWhereInput | null
    isNot?: LeadLostReasonWhereInput | null
  }

  export type LeadCampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadMetadataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    laneId?: SortOrder
    value?: SortOrder
    status?: SortOrder
    lostedLeadReasonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    laneId?: SortOrder
    value?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    laneId?: SortOrder
    value?: SortOrder
    status?: SortOrder
    lostedLeadReasonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    laneId?: SortOrder
    value?: SortOrder
    status?: SortOrder
    lostedLeadReasonId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    laneId?: SortOrder
    value?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type LeadMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadLostReasonCountOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadLostReasonMaxOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadLostReasonMinOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadCommentCountOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadCommentMinOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadChatLeadIdConversationIdCompoundUniqueInput = {
    leadId: string
    conversationId: string
  }

  export type LeadChatCountOrderByAggregateInput = {
    leadId?: SortOrder
    conversationId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadChatMaxOrderByAggregateInput = {
    leadId?: SortOrder
    conversationId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadChatMinOrderByAggregateInput = {
    leadId?: SortOrder
    conversationId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadDocumentLeadIdPathCompoundUniqueInput = {
    leadId: string
    path: string
  }

  export type LeadDocumentCountOrderByAggregateInput = {
    leadId?: SortOrder
    name?: SortOrder
    path?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadDocumentMaxOrderByAggregateInput = {
    leadId?: SortOrder
    name?: SortOrder
    path?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadDocumentMinOrderByAggregateInput = {
    leadId?: SortOrder
    name?: SortOrder
    path?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    principal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaneAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type LaneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    principal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    principal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaneSumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConstructionCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConstructionCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type ConstructionCompanyScalarRelationFilter = {
    is?: ConstructionCompanyWhereInput
    isNot?: ConstructionCompanyWhereInput
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    constructionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    constructionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    constructionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSourceNullableScalarRelationFilter = {
    is?: CampaignSourceWhereInput | null
    isNot?: CampaignSourceWhereInput | null
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    sourceId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    sourceId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    sourceId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type LeadCampaignLeadIdCampaignIdCompoundUniqueInput = {
    leadId: string
    campaignId: string
  }

  export type LeadCampaignCountOrderByAggregateInput = {
    leadId?: SortOrder
    campaignId?: SortOrder
  }

  export type LeadCampaignMaxOrderByAggregateInput = {
    leadId?: SortOrder
    campaignId?: SortOrder
  }

  export type LeadCampaignMinOrderByAggregateInput = {
    leadId?: SortOrder
    campaignId?: SortOrder
  }

  export type CampaignSourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type LeadTagTagIdLeadIdCompoundUniqueInput = {
    tagId: string
    leadId: string
  }

  export type LeadTagCountOrderByAggregateInput = {
    leadId?: SortOrder
    tagId?: SortOrder
  }

  export type LeadTagMaxOrderByAggregateInput = {
    leadId?: SortOrder
    tagId?: SortOrder
  }

  export type LeadTagMinOrderByAggregateInput = {
    leadId?: SortOrder
    tagId?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    constructionCompanyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    constructionCompanyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    constructionCompanyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserPermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutBrokerInput = {
    create?: XOR<LeadCreateWithoutBrokerInput, LeadUncheckedCreateWithoutBrokerInput> | LeadCreateWithoutBrokerInput[] | LeadUncheckedCreateWithoutBrokerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutBrokerInput | LeadCreateOrConnectWithoutBrokerInput[]
    createMany?: LeadCreateManyBrokerInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<LeadCommentCreateWithoutUserInput, LeadCommentUncheckedCreateWithoutUserInput> | LeadCommentCreateWithoutUserInput[] | LeadCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadCommentCreateOrConnectWithoutUserInput | LeadCommentCreateOrConnectWithoutUserInput[]
    createMany?: LeadCommentCreateManyUserInputEnvelope
    connect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
  }

  export type LeadDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<LeadDocumentCreateWithoutUserInput, LeadDocumentUncheckedCreateWithoutUserInput> | LeadDocumentCreateWithoutUserInput[] | LeadDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadDocumentCreateOrConnectWithoutUserInput | LeadDocumentCreateOrConnectWithoutUserInput[]
    createMany?: LeadDocumentCreateManyUserInputEnvelope
    connect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type ScheduleParticipantCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ScheduleParticipantCreateWithoutParticipantInput, ScheduleParticipantUncheckedCreateWithoutParticipantInput> | ScheduleParticipantCreateWithoutParticipantInput[] | ScheduleParticipantUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ScheduleParticipantCreateOrConnectWithoutParticipantInput | ScheduleParticipantCreateOrConnectWithoutParticipantInput[]
    createMany?: ScheduleParticipantCreateManyParticipantInputEnvelope
    connect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserPermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutBrokerInput = {
    create?: XOR<LeadCreateWithoutBrokerInput, LeadUncheckedCreateWithoutBrokerInput> | LeadCreateWithoutBrokerInput[] | LeadUncheckedCreateWithoutBrokerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutBrokerInput | LeadCreateOrConnectWithoutBrokerInput[]
    createMany?: LeadCreateManyBrokerInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeadCommentCreateWithoutUserInput, LeadCommentUncheckedCreateWithoutUserInput> | LeadCommentCreateWithoutUserInput[] | LeadCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadCommentCreateOrConnectWithoutUserInput | LeadCommentCreateOrConnectWithoutUserInput[]
    createMany?: LeadCommentCreateManyUserInputEnvelope
    connect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
  }

  export type LeadDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeadDocumentCreateWithoutUserInput, LeadDocumentUncheckedCreateWithoutUserInput> | LeadDocumentCreateWithoutUserInput[] | LeadDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadDocumentCreateOrConnectWithoutUserInput | LeadDocumentCreateOrConnectWithoutUserInput[]
    createMany?: LeadDocumentCreateManyUserInputEnvelope
    connect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type ScheduleParticipantUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ScheduleParticipantCreateWithoutParticipantInput, ScheduleParticipantUncheckedCreateWithoutParticipantInput> | ScheduleParticipantCreateWithoutParticipantInput[] | ScheduleParticipantUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ScheduleParticipantCreateOrConnectWithoutParticipantInput | ScheduleParticipantCreateOrConnectWithoutParticipantInput[]
    createMany?: ScheduleParticipantCreateManyParticipantInputEnvelope
    connect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserPermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    upsert?: UserPermissionUpsertWithWhereUniqueWithoutUserInput | UserPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    set?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    disconnect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    delete?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    update?: UserPermissionUpdateWithWhereUniqueWithoutUserInput | UserPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPermissionUpdateManyWithWhereWithoutUserInput | UserPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutBrokerNestedInput = {
    create?: XOR<LeadCreateWithoutBrokerInput, LeadUncheckedCreateWithoutBrokerInput> | LeadCreateWithoutBrokerInput[] | LeadUncheckedCreateWithoutBrokerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutBrokerInput | LeadCreateOrConnectWithoutBrokerInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutBrokerInput | LeadUpsertWithWhereUniqueWithoutBrokerInput[]
    createMany?: LeadCreateManyBrokerInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutBrokerInput | LeadUpdateWithWhereUniqueWithoutBrokerInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutBrokerInput | LeadUpdateManyWithWhereWithoutBrokerInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type LeadCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeadCommentCreateWithoutUserInput, LeadCommentUncheckedCreateWithoutUserInput> | LeadCommentCreateWithoutUserInput[] | LeadCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadCommentCreateOrConnectWithoutUserInput | LeadCommentCreateOrConnectWithoutUserInput[]
    upsert?: LeadCommentUpsertWithWhereUniqueWithoutUserInput | LeadCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeadCommentCreateManyUserInputEnvelope
    set?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    disconnect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    delete?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    connect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    update?: LeadCommentUpdateWithWhereUniqueWithoutUserInput | LeadCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeadCommentUpdateManyWithWhereWithoutUserInput | LeadCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeadCommentScalarWhereInput | LeadCommentScalarWhereInput[]
  }

  export type LeadDocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeadDocumentCreateWithoutUserInput, LeadDocumentUncheckedCreateWithoutUserInput> | LeadDocumentCreateWithoutUserInput[] | LeadDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadDocumentCreateOrConnectWithoutUserInput | LeadDocumentCreateOrConnectWithoutUserInput[]
    upsert?: LeadDocumentUpsertWithWhereUniqueWithoutUserInput | LeadDocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeadDocumentCreateManyUserInputEnvelope
    set?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    disconnect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    delete?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    connect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    update?: LeadDocumentUpdateWithWhereUniqueWithoutUserInput | LeadDocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeadDocumentUpdateManyWithWhereWithoutUserInput | LeadDocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeadDocumentScalarWhereInput | LeadDocumentScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutUserInput | ScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutUserInput | ScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutUserInput | ScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type ScheduleParticipantUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ScheduleParticipantCreateWithoutParticipantInput, ScheduleParticipantUncheckedCreateWithoutParticipantInput> | ScheduleParticipantCreateWithoutParticipantInput[] | ScheduleParticipantUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ScheduleParticipantCreateOrConnectWithoutParticipantInput | ScheduleParticipantCreateOrConnectWithoutParticipantInput[]
    upsert?: ScheduleParticipantUpsertWithWhereUniqueWithoutParticipantInput | ScheduleParticipantUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ScheduleParticipantCreateManyParticipantInputEnvelope
    set?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    disconnect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    delete?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    connect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    update?: ScheduleParticipantUpdateWithWhereUniqueWithoutParticipantInput | ScheduleParticipantUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ScheduleParticipantUpdateManyWithWhereWithoutParticipantInput | ScheduleParticipantUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ScheduleParticipantScalarWhereInput | ScheduleParticipantScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserPermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput> | UserPermissionCreateWithoutUserInput[] | UserPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutUserInput | UserPermissionCreateOrConnectWithoutUserInput[]
    upsert?: UserPermissionUpsertWithWhereUniqueWithoutUserInput | UserPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPermissionCreateManyUserInputEnvelope
    set?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    disconnect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    delete?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    update?: UserPermissionUpdateWithWhereUniqueWithoutUserInput | UserPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPermissionUpdateManyWithWhereWithoutUserInput | UserPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutBrokerNestedInput = {
    create?: XOR<LeadCreateWithoutBrokerInput, LeadUncheckedCreateWithoutBrokerInput> | LeadCreateWithoutBrokerInput[] | LeadUncheckedCreateWithoutBrokerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutBrokerInput | LeadCreateOrConnectWithoutBrokerInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutBrokerInput | LeadUpsertWithWhereUniqueWithoutBrokerInput[]
    createMany?: LeadCreateManyBrokerInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutBrokerInput | LeadUpdateWithWhereUniqueWithoutBrokerInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutBrokerInput | LeadUpdateManyWithWhereWithoutBrokerInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type LeadCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeadCommentCreateWithoutUserInput, LeadCommentUncheckedCreateWithoutUserInput> | LeadCommentCreateWithoutUserInput[] | LeadCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadCommentCreateOrConnectWithoutUserInput | LeadCommentCreateOrConnectWithoutUserInput[]
    upsert?: LeadCommentUpsertWithWhereUniqueWithoutUserInput | LeadCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeadCommentCreateManyUserInputEnvelope
    set?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    disconnect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    delete?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    connect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    update?: LeadCommentUpdateWithWhereUniqueWithoutUserInput | LeadCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeadCommentUpdateManyWithWhereWithoutUserInput | LeadCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeadCommentScalarWhereInput | LeadCommentScalarWhereInput[]
  }

  export type LeadDocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeadDocumentCreateWithoutUserInput, LeadDocumentUncheckedCreateWithoutUserInput> | LeadDocumentCreateWithoutUserInput[] | LeadDocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeadDocumentCreateOrConnectWithoutUserInput | LeadDocumentCreateOrConnectWithoutUserInput[]
    upsert?: LeadDocumentUpsertWithWhereUniqueWithoutUserInput | LeadDocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeadDocumentCreateManyUserInputEnvelope
    set?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    disconnect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    delete?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    connect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    update?: LeadDocumentUpdateWithWhereUniqueWithoutUserInput | LeadDocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeadDocumentUpdateManyWithWhereWithoutUserInput | LeadDocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeadDocumentScalarWhereInput | LeadDocumentScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutUserInput | ScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutUserInput | ScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutUserInput | ScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type ScheduleParticipantUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ScheduleParticipantCreateWithoutParticipantInput, ScheduleParticipantUncheckedCreateWithoutParticipantInput> | ScheduleParticipantCreateWithoutParticipantInput[] | ScheduleParticipantUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ScheduleParticipantCreateOrConnectWithoutParticipantInput | ScheduleParticipantCreateOrConnectWithoutParticipantInput[]
    upsert?: ScheduleParticipantUpsertWithWhereUniqueWithoutParticipantInput | ScheduleParticipantUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ScheduleParticipantCreateManyParticipantInputEnvelope
    set?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    disconnect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    delete?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    connect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    update?: ScheduleParticipantUpdateWithWhereUniqueWithoutParticipantInput | ScheduleParticipantUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ScheduleParticipantUpdateManyWithWhereWithoutParticipantInput | ScheduleParticipantUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ScheduleParticipantScalarWhereInput | ScheduleParticipantScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserPermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<UserPermissionCreateWithoutPermissionInput, UserPermissionUncheckedCreateWithoutPermissionInput> | UserPermissionCreateWithoutPermissionInput[] | UserPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutPermissionInput | UserPermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: UserPermissionCreateManyPermissionInputEnvelope
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
  }

  export type UserPermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<UserPermissionCreateWithoutPermissionInput, UserPermissionUncheckedCreateWithoutPermissionInput> | UserPermissionCreateWithoutPermissionInput[] | UserPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutPermissionInput | UserPermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: UserPermissionCreateManyPermissionInputEnvelope
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
  }

  export type UserPermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<UserPermissionCreateWithoutPermissionInput, UserPermissionUncheckedCreateWithoutPermissionInput> | UserPermissionCreateWithoutPermissionInput[] | UserPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutPermissionInput | UserPermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: UserPermissionUpsertWithWhereUniqueWithoutPermissionInput | UserPermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: UserPermissionCreateManyPermissionInputEnvelope
    set?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    disconnect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    delete?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    update?: UserPermissionUpdateWithWhereUniqueWithoutPermissionInput | UserPermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: UserPermissionUpdateManyWithWhereWithoutPermissionInput | UserPermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
  }

  export type UserPermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<UserPermissionCreateWithoutPermissionInput, UserPermissionUncheckedCreateWithoutPermissionInput> | UserPermissionCreateWithoutPermissionInput[] | UserPermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: UserPermissionCreateOrConnectWithoutPermissionInput | UserPermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: UserPermissionUpsertWithWhereUniqueWithoutPermissionInput | UserPermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: UserPermissionCreateManyPermissionInputEnvelope
    set?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    disconnect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    delete?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    connect?: UserPermissionWhereUniqueInput | UserPermissionWhereUniqueInput[]
    update?: UserPermissionUpdateWithWhereUniqueWithoutPermissionInput | UserPermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: UserPermissionUpdateManyWithWhereWithoutPermissionInput | UserPermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutUsersInput = {
    create?: XOR<PermissionCreateWithoutUsersInput, PermissionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutUsersInput
    connect?: PermissionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    upsert?: UserUpsertWithoutPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPermissionsInput, UserUpdateWithoutPermissionsInput>, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<PermissionCreateWithoutUsersInput, PermissionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutUsersInput
    upsert?: PermissionUpsertWithoutUsersInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutUsersInput, PermissionUpdateWithoutUsersInput>, PermissionUncheckedUpdateWithoutUsersInput>
  }

  export type LeadCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LeadCreateWithoutCustomerInput, LeadUncheckedCreateWithoutCustomerInput> | LeadCreateWithoutCustomerInput[] | LeadUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutCustomerInput | LeadCreateOrConnectWithoutCustomerInput[]
    createMany?: LeadCreateManyCustomerInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LeadCreateWithoutCustomerInput, LeadUncheckedCreateWithoutCustomerInput> | LeadCreateWithoutCustomerInput[] | LeadUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutCustomerInput | LeadCreateOrConnectWithoutCustomerInput[]
    createMany?: LeadCreateManyCustomerInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LeadCreateWithoutCustomerInput, LeadUncheckedCreateWithoutCustomerInput> | LeadCreateWithoutCustomerInput[] | LeadUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutCustomerInput | LeadCreateOrConnectWithoutCustomerInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutCustomerInput | LeadUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LeadCreateManyCustomerInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutCustomerInput | LeadUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutCustomerInput | LeadUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LeadCreateWithoutCustomerInput, LeadUncheckedCreateWithoutCustomerInput> | LeadCreateWithoutCustomerInput[] | LeadUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutCustomerInput | LeadCreateOrConnectWithoutCustomerInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutCustomerInput | LeadUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LeadCreateManyCustomerInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutCustomerInput | LeadUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutCustomerInput | LeadUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<UserCreateWithoutSchedulesInput, UserUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<LeadCreateWithoutSchedulesInput, LeadUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutSchedulesInput
    connect?: LeadWhereUniqueInput
  }

  export type ScheduleParticipantCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ScheduleParticipantCreateWithoutScheduleInput, ScheduleParticipantUncheckedCreateWithoutScheduleInput> | ScheduleParticipantCreateWithoutScheduleInput[] | ScheduleParticipantUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleParticipantCreateOrConnectWithoutScheduleInput | ScheduleParticipantCreateOrConnectWithoutScheduleInput[]
    createMany?: ScheduleParticipantCreateManyScheduleInputEnvelope
    connect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
  }

  export type ScheduleParticipantUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ScheduleParticipantCreateWithoutScheduleInput, ScheduleParticipantUncheckedCreateWithoutScheduleInput> | ScheduleParticipantCreateWithoutScheduleInput[] | ScheduleParticipantUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleParticipantCreateOrConnectWithoutScheduleInput | ScheduleParticipantCreateOrConnectWithoutScheduleInput[]
    createMany?: ScheduleParticipantCreateManyScheduleInputEnvelope
    connect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
  }

  export type EnumScheduleStatusFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleStatus
  }

  export type UserUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutSchedulesInput, UserUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchedulesInput
    upsert?: UserUpsertWithoutSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSchedulesInput, UserUpdateWithoutSchedulesInput>, UserUncheckedUpdateWithoutSchedulesInput>
  }

  export type LeadUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<LeadCreateWithoutSchedulesInput, LeadUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutSchedulesInput
    upsert?: LeadUpsertWithoutSchedulesInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutSchedulesInput, LeadUpdateWithoutSchedulesInput>, LeadUncheckedUpdateWithoutSchedulesInput>
  }

  export type ScheduleParticipantUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ScheduleParticipantCreateWithoutScheduleInput, ScheduleParticipantUncheckedCreateWithoutScheduleInput> | ScheduleParticipantCreateWithoutScheduleInput[] | ScheduleParticipantUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleParticipantCreateOrConnectWithoutScheduleInput | ScheduleParticipantCreateOrConnectWithoutScheduleInput[]
    upsert?: ScheduleParticipantUpsertWithWhereUniqueWithoutScheduleInput | ScheduleParticipantUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ScheduleParticipantCreateManyScheduleInputEnvelope
    set?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    disconnect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    delete?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    connect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    update?: ScheduleParticipantUpdateWithWhereUniqueWithoutScheduleInput | ScheduleParticipantUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ScheduleParticipantUpdateManyWithWhereWithoutScheduleInput | ScheduleParticipantUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ScheduleParticipantScalarWhereInput | ScheduleParticipantScalarWhereInput[]
  }

  export type ScheduleParticipantUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ScheduleParticipantCreateWithoutScheduleInput, ScheduleParticipantUncheckedCreateWithoutScheduleInput> | ScheduleParticipantCreateWithoutScheduleInput[] | ScheduleParticipantUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleParticipantCreateOrConnectWithoutScheduleInput | ScheduleParticipantCreateOrConnectWithoutScheduleInput[]
    upsert?: ScheduleParticipantUpsertWithWhereUniqueWithoutScheduleInput | ScheduleParticipantUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ScheduleParticipantCreateManyScheduleInputEnvelope
    set?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    disconnect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    delete?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    connect?: ScheduleParticipantWhereUniqueInput | ScheduleParticipantWhereUniqueInput[]
    update?: ScheduleParticipantUpdateWithWhereUniqueWithoutScheduleInput | ScheduleParticipantUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ScheduleParticipantUpdateManyWithWhereWithoutScheduleInput | ScheduleParticipantUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ScheduleParticipantScalarWhereInput | ScheduleParticipantScalarWhereInput[]
  }

  export type ScheduleCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ScheduleCreateWithoutParticipantsInput, ScheduleUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutParticipantsInput
    connect?: ScheduleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutScheduleParticipatingInput = {
    create?: XOR<UserCreateWithoutScheduleParticipatingInput, UserUncheckedCreateWithoutScheduleParticipatingInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduleParticipatingInput
    connect?: UserWhereUniqueInput
  }

  export type ScheduleUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ScheduleCreateWithoutParticipantsInput, ScheduleUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutParticipantsInput
    upsert?: ScheduleUpsertWithoutParticipantsInput
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutParticipantsInput, ScheduleUpdateWithoutParticipantsInput>, ScheduleUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutScheduleParticipatingNestedInput = {
    create?: XOR<UserCreateWithoutScheduleParticipatingInput, UserUncheckedCreateWithoutScheduleParticipatingInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduleParticipatingInput
    upsert?: UserUpsertWithoutScheduleParticipatingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScheduleParticipatingInput, UserUpdateWithoutScheduleParticipatingInput>, UserUncheckedUpdateWithoutScheduleParticipatingInput>
  }

  export type LeadCampaignCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadCampaignCreateWithoutLeadInput, LeadCampaignUncheckedCreateWithoutLeadInput> | LeadCampaignCreateWithoutLeadInput[] | LeadCampaignUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadCampaignCreateOrConnectWithoutLeadInput | LeadCampaignCreateOrConnectWithoutLeadInput[]
    createMany?: LeadCampaignCreateManyLeadInputEnvelope
    connect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutLeadsInput = {
    create?: XOR<CustomerCreateWithoutLeadsInput, CustomerUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLeadsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeadsInput = {
    create?: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type LeadTagCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadTagCreateWithoutLeadInput, LeadTagUncheckedCreateWithoutLeadInput> | LeadTagCreateWithoutLeadInput[] | LeadTagUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadTagCreateOrConnectWithoutLeadInput | LeadTagCreateOrConnectWithoutLeadInput[]
    createMany?: LeadTagCreateManyLeadInputEnvelope
    connect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
  }

  export type LeadDocumentCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadDocumentCreateWithoutLeadInput, LeadDocumentUncheckedCreateWithoutLeadInput> | LeadDocumentCreateWithoutLeadInput[] | LeadDocumentUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadDocumentCreateOrConnectWithoutLeadInput | LeadDocumentCreateOrConnectWithoutLeadInput[]
    createMany?: LeadDocumentCreateManyLeadInputEnvelope
    connect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
  }

  export type LeadCommentCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadCommentCreateWithoutLeadInput, LeadCommentUncheckedCreateWithoutLeadInput> | LeadCommentCreateWithoutLeadInput[] | LeadCommentUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadCommentCreateOrConnectWithoutLeadInput | LeadCommentCreateOrConnectWithoutLeadInput[]
    createMany?: LeadCommentCreateManyLeadInputEnvelope
    connect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
  }

  export type LeadMetadataCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadMetadataCreateWithoutLeadInput, LeadMetadataUncheckedCreateWithoutLeadInput> | LeadMetadataCreateWithoutLeadInput[] | LeadMetadataUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadMetadataCreateOrConnectWithoutLeadInput | LeadMetadataCreateOrConnectWithoutLeadInput[]
    createMany?: LeadMetadataCreateManyLeadInputEnvelope
    connect?: LeadMetadataWhereUniqueInput | LeadMetadataWhereUniqueInput[]
  }

  export type LeadChatCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadChatCreateWithoutLeadInput, LeadChatUncheckedCreateWithoutLeadInput> | LeadChatCreateWithoutLeadInput[] | LeadChatUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadChatCreateOrConnectWithoutLeadInput | LeadChatCreateOrConnectWithoutLeadInput[]
    createMany?: LeadChatCreateManyLeadInputEnvelope
    connect?: LeadChatWhereUniqueInput | LeadChatWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutLeadInput = {
    create?: XOR<ScheduleCreateWithoutLeadInput, ScheduleUncheckedCreateWithoutLeadInput> | ScheduleCreateWithoutLeadInput[] | ScheduleUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutLeadInput | ScheduleCreateOrConnectWithoutLeadInput[]
    createMany?: ScheduleCreateManyLeadInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type LaneCreateNestedOneWithoutLeadsInput = {
    create?: XOR<LaneCreateWithoutLeadsInput, LaneUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: LaneCreateOrConnectWithoutLeadsInput
    connect?: LaneWhereUniqueInput
  }

  export type LeadLostReasonCreateNestedOneWithoutLeadsInput = {
    create?: XOR<LeadLostReasonCreateWithoutLeadsInput, LeadLostReasonUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: LeadLostReasonCreateOrConnectWithoutLeadsInput
    connect?: LeadLostReasonWhereUniqueInput
  }

  export type LeadCampaignUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadCampaignCreateWithoutLeadInput, LeadCampaignUncheckedCreateWithoutLeadInput> | LeadCampaignCreateWithoutLeadInput[] | LeadCampaignUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadCampaignCreateOrConnectWithoutLeadInput | LeadCampaignCreateOrConnectWithoutLeadInput[]
    createMany?: LeadCampaignCreateManyLeadInputEnvelope
    connect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
  }

  export type LeadTagUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadTagCreateWithoutLeadInput, LeadTagUncheckedCreateWithoutLeadInput> | LeadTagCreateWithoutLeadInput[] | LeadTagUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadTagCreateOrConnectWithoutLeadInput | LeadTagCreateOrConnectWithoutLeadInput[]
    createMany?: LeadTagCreateManyLeadInputEnvelope
    connect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
  }

  export type LeadDocumentUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadDocumentCreateWithoutLeadInput, LeadDocumentUncheckedCreateWithoutLeadInput> | LeadDocumentCreateWithoutLeadInput[] | LeadDocumentUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadDocumentCreateOrConnectWithoutLeadInput | LeadDocumentCreateOrConnectWithoutLeadInput[]
    createMany?: LeadDocumentCreateManyLeadInputEnvelope
    connect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
  }

  export type LeadCommentUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadCommentCreateWithoutLeadInput, LeadCommentUncheckedCreateWithoutLeadInput> | LeadCommentCreateWithoutLeadInput[] | LeadCommentUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadCommentCreateOrConnectWithoutLeadInput | LeadCommentCreateOrConnectWithoutLeadInput[]
    createMany?: LeadCommentCreateManyLeadInputEnvelope
    connect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
  }

  export type LeadMetadataUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadMetadataCreateWithoutLeadInput, LeadMetadataUncheckedCreateWithoutLeadInput> | LeadMetadataCreateWithoutLeadInput[] | LeadMetadataUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadMetadataCreateOrConnectWithoutLeadInput | LeadMetadataCreateOrConnectWithoutLeadInput[]
    createMany?: LeadMetadataCreateManyLeadInputEnvelope
    connect?: LeadMetadataWhereUniqueInput | LeadMetadataWhereUniqueInput[]
  }

  export type LeadChatUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<LeadChatCreateWithoutLeadInput, LeadChatUncheckedCreateWithoutLeadInput> | LeadChatCreateWithoutLeadInput[] | LeadChatUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadChatCreateOrConnectWithoutLeadInput | LeadChatCreateOrConnectWithoutLeadInput[]
    createMany?: LeadChatCreateManyLeadInputEnvelope
    connect?: LeadChatWhereUniqueInput | LeadChatWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<ScheduleCreateWithoutLeadInput, ScheduleUncheckedCreateWithoutLeadInput> | ScheduleCreateWithoutLeadInput[] | ScheduleUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutLeadInput | ScheduleCreateOrConnectWithoutLeadInput[]
    createMany?: ScheduleCreateManyLeadInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type LeadCampaignUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadCampaignCreateWithoutLeadInput, LeadCampaignUncheckedCreateWithoutLeadInput> | LeadCampaignCreateWithoutLeadInput[] | LeadCampaignUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadCampaignCreateOrConnectWithoutLeadInput | LeadCampaignCreateOrConnectWithoutLeadInput[]
    upsert?: LeadCampaignUpsertWithWhereUniqueWithoutLeadInput | LeadCampaignUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadCampaignCreateManyLeadInputEnvelope
    set?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    disconnect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    delete?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    connect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    update?: LeadCampaignUpdateWithWhereUniqueWithoutLeadInput | LeadCampaignUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadCampaignUpdateManyWithWhereWithoutLeadInput | LeadCampaignUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadCampaignScalarWhereInput | LeadCampaignScalarWhereInput[]
  }

  export type CustomerUpdateOneWithoutLeadsNestedInput = {
    create?: XOR<CustomerCreateWithoutLeadsInput, CustomerUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLeadsInput
    upsert?: CustomerUpsertWithoutLeadsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutLeadsInput, CustomerUpdateWithoutLeadsInput>, CustomerUncheckedUpdateWithoutLeadsInput>
  }

  export type UserUpdateOneWithoutLeadsNestedInput = {
    create?: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadsInput
    upsert?: UserUpsertWithoutLeadsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeadsInput, UserUpdateWithoutLeadsInput>, UserUncheckedUpdateWithoutLeadsInput>
  }

  export type LeadTagUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadTagCreateWithoutLeadInput, LeadTagUncheckedCreateWithoutLeadInput> | LeadTagCreateWithoutLeadInput[] | LeadTagUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadTagCreateOrConnectWithoutLeadInput | LeadTagCreateOrConnectWithoutLeadInput[]
    upsert?: LeadTagUpsertWithWhereUniqueWithoutLeadInput | LeadTagUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadTagCreateManyLeadInputEnvelope
    set?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    disconnect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    delete?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    connect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    update?: LeadTagUpdateWithWhereUniqueWithoutLeadInput | LeadTagUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadTagUpdateManyWithWhereWithoutLeadInput | LeadTagUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadTagScalarWhereInput | LeadTagScalarWhereInput[]
  }

  export type LeadDocumentUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadDocumentCreateWithoutLeadInput, LeadDocumentUncheckedCreateWithoutLeadInput> | LeadDocumentCreateWithoutLeadInput[] | LeadDocumentUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadDocumentCreateOrConnectWithoutLeadInput | LeadDocumentCreateOrConnectWithoutLeadInput[]
    upsert?: LeadDocumentUpsertWithWhereUniqueWithoutLeadInput | LeadDocumentUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadDocumentCreateManyLeadInputEnvelope
    set?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    disconnect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    delete?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    connect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    update?: LeadDocumentUpdateWithWhereUniqueWithoutLeadInput | LeadDocumentUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadDocumentUpdateManyWithWhereWithoutLeadInput | LeadDocumentUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadDocumentScalarWhereInput | LeadDocumentScalarWhereInput[]
  }

  export type LeadCommentUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadCommentCreateWithoutLeadInput, LeadCommentUncheckedCreateWithoutLeadInput> | LeadCommentCreateWithoutLeadInput[] | LeadCommentUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadCommentCreateOrConnectWithoutLeadInput | LeadCommentCreateOrConnectWithoutLeadInput[]
    upsert?: LeadCommentUpsertWithWhereUniqueWithoutLeadInput | LeadCommentUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadCommentCreateManyLeadInputEnvelope
    set?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    disconnect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    delete?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    connect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    update?: LeadCommentUpdateWithWhereUniqueWithoutLeadInput | LeadCommentUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadCommentUpdateManyWithWhereWithoutLeadInput | LeadCommentUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadCommentScalarWhereInput | LeadCommentScalarWhereInput[]
  }

  export type LeadMetadataUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadMetadataCreateWithoutLeadInput, LeadMetadataUncheckedCreateWithoutLeadInput> | LeadMetadataCreateWithoutLeadInput[] | LeadMetadataUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadMetadataCreateOrConnectWithoutLeadInput | LeadMetadataCreateOrConnectWithoutLeadInput[]
    upsert?: LeadMetadataUpsertWithWhereUniqueWithoutLeadInput | LeadMetadataUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadMetadataCreateManyLeadInputEnvelope
    set?: LeadMetadataWhereUniqueInput | LeadMetadataWhereUniqueInput[]
    disconnect?: LeadMetadataWhereUniqueInput | LeadMetadataWhereUniqueInput[]
    delete?: LeadMetadataWhereUniqueInput | LeadMetadataWhereUniqueInput[]
    connect?: LeadMetadataWhereUniqueInput | LeadMetadataWhereUniqueInput[]
    update?: LeadMetadataUpdateWithWhereUniqueWithoutLeadInput | LeadMetadataUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadMetadataUpdateManyWithWhereWithoutLeadInput | LeadMetadataUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadMetadataScalarWhereInput | LeadMetadataScalarWhereInput[]
  }

  export type LeadChatUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadChatCreateWithoutLeadInput, LeadChatUncheckedCreateWithoutLeadInput> | LeadChatCreateWithoutLeadInput[] | LeadChatUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadChatCreateOrConnectWithoutLeadInput | LeadChatCreateOrConnectWithoutLeadInput[]
    upsert?: LeadChatUpsertWithWhereUniqueWithoutLeadInput | LeadChatUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadChatCreateManyLeadInputEnvelope
    set?: LeadChatWhereUniqueInput | LeadChatWhereUniqueInput[]
    disconnect?: LeadChatWhereUniqueInput | LeadChatWhereUniqueInput[]
    delete?: LeadChatWhereUniqueInput | LeadChatWhereUniqueInput[]
    connect?: LeadChatWhereUniqueInput | LeadChatWhereUniqueInput[]
    update?: LeadChatUpdateWithWhereUniqueWithoutLeadInput | LeadChatUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadChatUpdateManyWithWhereWithoutLeadInput | LeadChatUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadChatScalarWhereInput | LeadChatScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ScheduleCreateWithoutLeadInput, ScheduleUncheckedCreateWithoutLeadInput> | ScheduleCreateWithoutLeadInput[] | ScheduleUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutLeadInput | ScheduleCreateOrConnectWithoutLeadInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutLeadInput | ScheduleUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ScheduleCreateManyLeadInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutLeadInput | ScheduleUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutLeadInput | ScheduleUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type LaneUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<LaneCreateWithoutLeadsInput, LaneUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: LaneCreateOrConnectWithoutLeadsInput
    upsert?: LaneUpsertWithoutLeadsInput
    connect?: LaneWhereUniqueInput
    update?: XOR<XOR<LaneUpdateToOneWithWhereWithoutLeadsInput, LaneUpdateWithoutLeadsInput>, LaneUncheckedUpdateWithoutLeadsInput>
  }

  export type LeadLostReasonUpdateOneWithoutLeadsNestedInput = {
    create?: XOR<LeadLostReasonCreateWithoutLeadsInput, LeadLostReasonUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: LeadLostReasonCreateOrConnectWithoutLeadsInput
    upsert?: LeadLostReasonUpsertWithoutLeadsInput
    disconnect?: LeadLostReasonWhereInput | boolean
    delete?: LeadLostReasonWhereInput | boolean
    connect?: LeadLostReasonWhereUniqueInput
    update?: XOR<XOR<LeadLostReasonUpdateToOneWithWhereWithoutLeadsInput, LeadLostReasonUpdateWithoutLeadsInput>, LeadLostReasonUncheckedUpdateWithoutLeadsInput>
  }

  export type LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadCampaignCreateWithoutLeadInput, LeadCampaignUncheckedCreateWithoutLeadInput> | LeadCampaignCreateWithoutLeadInput[] | LeadCampaignUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadCampaignCreateOrConnectWithoutLeadInput | LeadCampaignCreateOrConnectWithoutLeadInput[]
    upsert?: LeadCampaignUpsertWithWhereUniqueWithoutLeadInput | LeadCampaignUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadCampaignCreateManyLeadInputEnvelope
    set?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    disconnect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    delete?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    connect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    update?: LeadCampaignUpdateWithWhereUniqueWithoutLeadInput | LeadCampaignUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadCampaignUpdateManyWithWhereWithoutLeadInput | LeadCampaignUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadCampaignScalarWhereInput | LeadCampaignScalarWhereInput[]
  }

  export type LeadTagUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadTagCreateWithoutLeadInput, LeadTagUncheckedCreateWithoutLeadInput> | LeadTagCreateWithoutLeadInput[] | LeadTagUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadTagCreateOrConnectWithoutLeadInput | LeadTagCreateOrConnectWithoutLeadInput[]
    upsert?: LeadTagUpsertWithWhereUniqueWithoutLeadInput | LeadTagUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadTagCreateManyLeadInputEnvelope
    set?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    disconnect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    delete?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    connect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    update?: LeadTagUpdateWithWhereUniqueWithoutLeadInput | LeadTagUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadTagUpdateManyWithWhereWithoutLeadInput | LeadTagUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadTagScalarWhereInput | LeadTagScalarWhereInput[]
  }

  export type LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadDocumentCreateWithoutLeadInput, LeadDocumentUncheckedCreateWithoutLeadInput> | LeadDocumentCreateWithoutLeadInput[] | LeadDocumentUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadDocumentCreateOrConnectWithoutLeadInput | LeadDocumentCreateOrConnectWithoutLeadInput[]
    upsert?: LeadDocumentUpsertWithWhereUniqueWithoutLeadInput | LeadDocumentUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadDocumentCreateManyLeadInputEnvelope
    set?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    disconnect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    delete?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    connect?: LeadDocumentWhereUniqueInput | LeadDocumentWhereUniqueInput[]
    update?: LeadDocumentUpdateWithWhereUniqueWithoutLeadInput | LeadDocumentUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadDocumentUpdateManyWithWhereWithoutLeadInput | LeadDocumentUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadDocumentScalarWhereInput | LeadDocumentScalarWhereInput[]
  }

  export type LeadCommentUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadCommentCreateWithoutLeadInput, LeadCommentUncheckedCreateWithoutLeadInput> | LeadCommentCreateWithoutLeadInput[] | LeadCommentUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadCommentCreateOrConnectWithoutLeadInput | LeadCommentCreateOrConnectWithoutLeadInput[]
    upsert?: LeadCommentUpsertWithWhereUniqueWithoutLeadInput | LeadCommentUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadCommentCreateManyLeadInputEnvelope
    set?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    disconnect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    delete?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    connect?: LeadCommentWhereUniqueInput | LeadCommentWhereUniqueInput[]
    update?: LeadCommentUpdateWithWhereUniqueWithoutLeadInput | LeadCommentUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadCommentUpdateManyWithWhereWithoutLeadInput | LeadCommentUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadCommentScalarWhereInput | LeadCommentScalarWhereInput[]
  }

  export type LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadMetadataCreateWithoutLeadInput, LeadMetadataUncheckedCreateWithoutLeadInput> | LeadMetadataCreateWithoutLeadInput[] | LeadMetadataUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadMetadataCreateOrConnectWithoutLeadInput | LeadMetadataCreateOrConnectWithoutLeadInput[]
    upsert?: LeadMetadataUpsertWithWhereUniqueWithoutLeadInput | LeadMetadataUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadMetadataCreateManyLeadInputEnvelope
    set?: LeadMetadataWhereUniqueInput | LeadMetadataWhereUniqueInput[]
    disconnect?: LeadMetadataWhereUniqueInput | LeadMetadataWhereUniqueInput[]
    delete?: LeadMetadataWhereUniqueInput | LeadMetadataWhereUniqueInput[]
    connect?: LeadMetadataWhereUniqueInput | LeadMetadataWhereUniqueInput[]
    update?: LeadMetadataUpdateWithWhereUniqueWithoutLeadInput | LeadMetadataUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadMetadataUpdateManyWithWhereWithoutLeadInput | LeadMetadataUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadMetadataScalarWhereInput | LeadMetadataScalarWhereInput[]
  }

  export type LeadChatUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<LeadChatCreateWithoutLeadInput, LeadChatUncheckedCreateWithoutLeadInput> | LeadChatCreateWithoutLeadInput[] | LeadChatUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: LeadChatCreateOrConnectWithoutLeadInput | LeadChatCreateOrConnectWithoutLeadInput[]
    upsert?: LeadChatUpsertWithWhereUniqueWithoutLeadInput | LeadChatUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: LeadChatCreateManyLeadInputEnvelope
    set?: LeadChatWhereUniqueInput | LeadChatWhereUniqueInput[]
    disconnect?: LeadChatWhereUniqueInput | LeadChatWhereUniqueInput[]
    delete?: LeadChatWhereUniqueInput | LeadChatWhereUniqueInput[]
    connect?: LeadChatWhereUniqueInput | LeadChatWhereUniqueInput[]
    update?: LeadChatUpdateWithWhereUniqueWithoutLeadInput | LeadChatUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: LeadChatUpdateManyWithWhereWithoutLeadInput | LeadChatUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: LeadChatScalarWhereInput | LeadChatScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ScheduleCreateWithoutLeadInput, ScheduleUncheckedCreateWithoutLeadInput> | ScheduleCreateWithoutLeadInput[] | ScheduleUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutLeadInput | ScheduleCreateOrConnectWithoutLeadInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutLeadInput | ScheduleUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ScheduleCreateManyLeadInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutLeadInput | ScheduleUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutLeadInput | ScheduleUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type LeadCreateNestedOneWithoutMetadataInput = {
    create?: XOR<LeadCreateWithoutMetadataInput, LeadUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: LeadCreateOrConnectWithoutMetadataInput
    connect?: LeadWhereUniqueInput
  }

  export type LeadUpdateOneRequiredWithoutMetadataNestedInput = {
    create?: XOR<LeadCreateWithoutMetadataInput, LeadUncheckedCreateWithoutMetadataInput>
    connectOrCreate?: LeadCreateOrConnectWithoutMetadataInput
    upsert?: LeadUpsertWithoutMetadataInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutMetadataInput, LeadUpdateWithoutMetadataInput>, LeadUncheckedUpdateWithoutMetadataInput>
  }

  export type LeadCreateNestedManyWithoutLostedReasonInput = {
    create?: XOR<LeadCreateWithoutLostedReasonInput, LeadUncheckedCreateWithoutLostedReasonInput> | LeadCreateWithoutLostedReasonInput[] | LeadUncheckedCreateWithoutLostedReasonInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLostedReasonInput | LeadCreateOrConnectWithoutLostedReasonInput[]
    createMany?: LeadCreateManyLostedReasonInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutLostedReasonInput = {
    create?: XOR<LeadCreateWithoutLostedReasonInput, LeadUncheckedCreateWithoutLostedReasonInput> | LeadCreateWithoutLostedReasonInput[] | LeadUncheckedCreateWithoutLostedReasonInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLostedReasonInput | LeadCreateOrConnectWithoutLostedReasonInput[]
    createMany?: LeadCreateManyLostedReasonInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadUpdateManyWithoutLostedReasonNestedInput = {
    create?: XOR<LeadCreateWithoutLostedReasonInput, LeadUncheckedCreateWithoutLostedReasonInput> | LeadCreateWithoutLostedReasonInput[] | LeadUncheckedCreateWithoutLostedReasonInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLostedReasonInput | LeadCreateOrConnectWithoutLostedReasonInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutLostedReasonInput | LeadUpsertWithWhereUniqueWithoutLostedReasonInput[]
    createMany?: LeadCreateManyLostedReasonInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutLostedReasonInput | LeadUpdateWithWhereUniqueWithoutLostedReasonInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutLostedReasonInput | LeadUpdateManyWithWhereWithoutLostedReasonInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutLostedReasonNestedInput = {
    create?: XOR<LeadCreateWithoutLostedReasonInput, LeadUncheckedCreateWithoutLostedReasonInput> | LeadCreateWithoutLostedReasonInput[] | LeadUncheckedCreateWithoutLostedReasonInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLostedReasonInput | LeadCreateOrConnectWithoutLostedReasonInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutLostedReasonInput | LeadUpsertWithWhereUniqueWithoutLostedReasonInput[]
    createMany?: LeadCreateManyLostedReasonInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutLostedReasonInput | LeadUpdateWithWhereUniqueWithoutLostedReasonInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutLostedReasonInput | LeadUpdateManyWithWhereWithoutLostedReasonInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLeadCommentsInput = {
    create?: XOR<UserCreateWithoutLeadCommentsInput, UserUncheckedCreateWithoutLeadCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutCommentsInput = {
    create?: XOR<LeadCreateWithoutCommentsInput, LeadUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutCommentsInput
    connect?: LeadWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeadCommentsNestedInput = {
    create?: XOR<UserCreateWithoutLeadCommentsInput, UserUncheckedCreateWithoutLeadCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadCommentsInput
    upsert?: UserUpsertWithoutLeadCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeadCommentsInput, UserUpdateWithoutLeadCommentsInput>, UserUncheckedUpdateWithoutLeadCommentsInput>
  }

  export type LeadUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<LeadCreateWithoutCommentsInput, LeadUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutCommentsInput
    upsert?: LeadUpsertWithoutCommentsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutCommentsInput, LeadUpdateWithoutCommentsInput>, LeadUncheckedUpdateWithoutCommentsInput>
  }

  export type LeadCreateNestedOneWithoutChatsInput = {
    create?: XOR<LeadCreateWithoutChatsInput, LeadUncheckedCreateWithoutChatsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutChatsInput
    connect?: LeadWhereUniqueInput
  }

  export type LeadUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<LeadCreateWithoutChatsInput, LeadUncheckedCreateWithoutChatsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutChatsInput
    upsert?: LeadUpsertWithoutChatsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutChatsInput, LeadUpdateWithoutChatsInput>, LeadUncheckedUpdateWithoutChatsInput>
  }

  export type LeadCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<LeadCreateWithoutDocumentsInput, LeadUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutDocumentsInput
    connect?: LeadWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeadDocumentsInput = {
    create?: XOR<UserCreateWithoutLeadDocumentsInput, UserUncheckedCreateWithoutLeadDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type LeadUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<LeadCreateWithoutDocumentsInput, LeadUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutDocumentsInput
    upsert?: LeadUpsertWithoutDocumentsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutDocumentsInput, LeadUpdateWithoutDocumentsInput>, LeadUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneWithoutLeadDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutLeadDocumentsInput, UserUncheckedCreateWithoutLeadDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadDocumentsInput
    upsert?: UserUpsertWithoutLeadDocumentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeadDocumentsInput, UserUpdateWithoutLeadDocumentsInput>, UserUncheckedUpdateWithoutLeadDocumentsInput>
  }

  export type LeadCreateNestedManyWithoutLaneInput = {
    create?: XOR<LeadCreateWithoutLaneInput, LeadUncheckedCreateWithoutLaneInput> | LeadCreateWithoutLaneInput[] | LeadUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLaneInput | LeadCreateOrConnectWithoutLaneInput[]
    createMany?: LeadCreateManyLaneInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutLaneInput = {
    create?: XOR<LeadCreateWithoutLaneInput, LeadUncheckedCreateWithoutLaneInput> | LeadCreateWithoutLaneInput[] | LeadUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLaneInput | LeadCreateOrConnectWithoutLaneInput[]
    createMany?: LeadCreateManyLaneInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type LeadUpdateManyWithoutLaneNestedInput = {
    create?: XOR<LeadCreateWithoutLaneInput, LeadUncheckedCreateWithoutLaneInput> | LeadCreateWithoutLaneInput[] | LeadUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLaneInput | LeadCreateOrConnectWithoutLaneInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutLaneInput | LeadUpsertWithWhereUniqueWithoutLaneInput[]
    createMany?: LeadCreateManyLaneInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutLaneInput | LeadUpdateWithWhereUniqueWithoutLaneInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutLaneInput | LeadUpdateManyWithWhereWithoutLaneInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutLaneNestedInput = {
    create?: XOR<LeadCreateWithoutLaneInput, LeadUncheckedCreateWithoutLaneInput> | LeadCreateWithoutLaneInput[] | LeadUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutLaneInput | LeadCreateOrConnectWithoutLaneInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutLaneInput | LeadUpsertWithWhereUniqueWithoutLaneInput[]
    createMany?: LeadCreateManyLaneInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutLaneInput | LeadUpdateWithWhereUniqueWithoutLaneInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutLaneInput | LeadUpdateManyWithWhereWithoutLaneInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutConstructionCompanyInput = {
    create?: XOR<ProjectCreateWithoutConstructionCompanyInput, ProjectUncheckedCreateWithoutConstructionCompanyInput> | ProjectCreateWithoutConstructionCompanyInput[] | ProjectUncheckedCreateWithoutConstructionCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutConstructionCompanyInput | ProjectCreateOrConnectWithoutConstructionCompanyInput[]
    createMany?: ProjectCreateManyConstructionCompanyInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutConstructionCompanyInput = {
    create?: XOR<ContactCreateWithoutConstructionCompanyInput, ContactUncheckedCreateWithoutConstructionCompanyInput> | ContactCreateWithoutConstructionCompanyInput[] | ContactUncheckedCreateWithoutConstructionCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutConstructionCompanyInput | ContactCreateOrConnectWithoutConstructionCompanyInput[]
    createMany?: ContactCreateManyConstructionCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutConstructionCompanyInput = {
    create?: XOR<ProjectCreateWithoutConstructionCompanyInput, ProjectUncheckedCreateWithoutConstructionCompanyInput> | ProjectCreateWithoutConstructionCompanyInput[] | ProjectUncheckedCreateWithoutConstructionCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutConstructionCompanyInput | ProjectCreateOrConnectWithoutConstructionCompanyInput[]
    createMany?: ProjectCreateManyConstructionCompanyInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutConstructionCompanyInput = {
    create?: XOR<ContactCreateWithoutConstructionCompanyInput, ContactUncheckedCreateWithoutConstructionCompanyInput> | ContactCreateWithoutConstructionCompanyInput[] | ContactUncheckedCreateWithoutConstructionCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutConstructionCompanyInput | ContactCreateOrConnectWithoutConstructionCompanyInput[]
    createMany?: ContactCreateManyConstructionCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutConstructionCompanyNestedInput = {
    create?: XOR<ProjectCreateWithoutConstructionCompanyInput, ProjectUncheckedCreateWithoutConstructionCompanyInput> | ProjectCreateWithoutConstructionCompanyInput[] | ProjectUncheckedCreateWithoutConstructionCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutConstructionCompanyInput | ProjectCreateOrConnectWithoutConstructionCompanyInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutConstructionCompanyInput | ProjectUpsertWithWhereUniqueWithoutConstructionCompanyInput[]
    createMany?: ProjectCreateManyConstructionCompanyInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutConstructionCompanyInput | ProjectUpdateWithWhereUniqueWithoutConstructionCompanyInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutConstructionCompanyInput | ProjectUpdateManyWithWhereWithoutConstructionCompanyInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutConstructionCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutConstructionCompanyInput, ContactUncheckedCreateWithoutConstructionCompanyInput> | ContactCreateWithoutConstructionCompanyInput[] | ContactUncheckedCreateWithoutConstructionCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutConstructionCompanyInput | ContactCreateOrConnectWithoutConstructionCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutConstructionCompanyInput | ContactUpsertWithWhereUniqueWithoutConstructionCompanyInput[]
    createMany?: ContactCreateManyConstructionCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutConstructionCompanyInput | ContactUpdateWithWhereUniqueWithoutConstructionCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutConstructionCompanyInput | ContactUpdateManyWithWhereWithoutConstructionCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutConstructionCompanyNestedInput = {
    create?: XOR<ProjectCreateWithoutConstructionCompanyInput, ProjectUncheckedCreateWithoutConstructionCompanyInput> | ProjectCreateWithoutConstructionCompanyInput[] | ProjectUncheckedCreateWithoutConstructionCompanyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutConstructionCompanyInput | ProjectCreateOrConnectWithoutConstructionCompanyInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutConstructionCompanyInput | ProjectUpsertWithWhereUniqueWithoutConstructionCompanyInput[]
    createMany?: ProjectCreateManyConstructionCompanyInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutConstructionCompanyInput | ProjectUpdateWithWhereUniqueWithoutConstructionCompanyInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutConstructionCompanyInput | ProjectUpdateManyWithWhereWithoutConstructionCompanyInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutConstructionCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutConstructionCompanyInput, ContactUncheckedCreateWithoutConstructionCompanyInput> | ContactCreateWithoutConstructionCompanyInput[] | ContactUncheckedCreateWithoutConstructionCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutConstructionCompanyInput | ContactCreateOrConnectWithoutConstructionCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutConstructionCompanyInput | ContactUpsertWithWhereUniqueWithoutConstructionCompanyInput[]
    createMany?: ContactCreateManyConstructionCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutConstructionCompanyInput | ContactUpdateWithWhereUniqueWithoutConstructionCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutConstructionCompanyInput | ContactUpdateManyWithWhereWithoutConstructionCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CampaignCreateNestedManyWithoutProjectInput = {
    create?: XOR<CampaignCreateWithoutProjectInput, CampaignUncheckedCreateWithoutProjectInput> | CampaignCreateWithoutProjectInput[] | CampaignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutProjectInput | CampaignCreateOrConnectWithoutProjectInput[]
    createMany?: CampaignCreateManyProjectInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ConstructionCompanyCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ConstructionCompanyCreateWithoutProjectsInput, ConstructionCompanyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ConstructionCompanyCreateOrConnectWithoutProjectsInput
    connect?: ConstructionCompanyWhereUniqueInput
  }

  export type CampaignUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<CampaignCreateWithoutProjectInput, CampaignUncheckedCreateWithoutProjectInput> | CampaignCreateWithoutProjectInput[] | CampaignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutProjectInput | CampaignCreateOrConnectWithoutProjectInput[]
    createMany?: CampaignCreateManyProjectInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CampaignCreateWithoutProjectInput, CampaignUncheckedCreateWithoutProjectInput> | CampaignCreateWithoutProjectInput[] | CampaignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutProjectInput | CampaignCreateOrConnectWithoutProjectInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutProjectInput | CampaignUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CampaignCreateManyProjectInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutProjectInput | CampaignUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutProjectInput | CampaignUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ConstructionCompanyUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<ConstructionCompanyCreateWithoutProjectsInput, ConstructionCompanyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ConstructionCompanyCreateOrConnectWithoutProjectsInput
    upsert?: ConstructionCompanyUpsertWithoutProjectsInput
    connect?: ConstructionCompanyWhereUniqueInput
    update?: XOR<XOR<ConstructionCompanyUpdateToOneWithWhereWithoutProjectsInput, ConstructionCompanyUpdateWithoutProjectsInput>, ConstructionCompanyUncheckedUpdateWithoutProjectsInput>
  }

  export type CampaignUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<CampaignCreateWithoutProjectInput, CampaignUncheckedCreateWithoutProjectInput> | CampaignCreateWithoutProjectInput[] | CampaignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutProjectInput | CampaignCreateOrConnectWithoutProjectInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutProjectInput | CampaignUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: CampaignCreateManyProjectInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutProjectInput | CampaignUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutProjectInput | CampaignUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type LeadCampaignCreateNestedManyWithoutCampaignInput = {
    create?: XOR<LeadCampaignCreateWithoutCampaignInput, LeadCampaignUncheckedCreateWithoutCampaignInput> | LeadCampaignCreateWithoutCampaignInput[] | LeadCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LeadCampaignCreateOrConnectWithoutCampaignInput | LeadCampaignCreateOrConnectWithoutCampaignInput[]
    createMany?: LeadCampaignCreateManyCampaignInputEnvelope
    connect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
  }

  export type CampaignSourceCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<CampaignSourceCreateWithoutCampaignsInput, CampaignSourceUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: CampaignSourceCreateOrConnectWithoutCampaignsInput
    connect?: CampaignSourceWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<ProjectCreateWithoutCampaignsInput, ProjectUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCampaignsInput
    connect?: ProjectWhereUniqueInput
  }

  export type LeadCampaignUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<LeadCampaignCreateWithoutCampaignInput, LeadCampaignUncheckedCreateWithoutCampaignInput> | LeadCampaignCreateWithoutCampaignInput[] | LeadCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LeadCampaignCreateOrConnectWithoutCampaignInput | LeadCampaignCreateOrConnectWithoutCampaignInput[]
    createMany?: LeadCampaignCreateManyCampaignInputEnvelope
    connect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
  }

  export type LeadCampaignUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<LeadCampaignCreateWithoutCampaignInput, LeadCampaignUncheckedCreateWithoutCampaignInput> | LeadCampaignCreateWithoutCampaignInput[] | LeadCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LeadCampaignCreateOrConnectWithoutCampaignInput | LeadCampaignCreateOrConnectWithoutCampaignInput[]
    upsert?: LeadCampaignUpsertWithWhereUniqueWithoutCampaignInput | LeadCampaignUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: LeadCampaignCreateManyCampaignInputEnvelope
    set?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    disconnect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    delete?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    connect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    update?: LeadCampaignUpdateWithWhereUniqueWithoutCampaignInput | LeadCampaignUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: LeadCampaignUpdateManyWithWhereWithoutCampaignInput | LeadCampaignUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: LeadCampaignScalarWhereInput | LeadCampaignScalarWhereInput[]
  }

  export type CampaignSourceUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<CampaignSourceCreateWithoutCampaignsInput, CampaignSourceUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: CampaignSourceCreateOrConnectWithoutCampaignsInput
    upsert?: CampaignSourceUpsertWithoutCampaignsInput
    disconnect?: CampaignSourceWhereInput | boolean
    delete?: CampaignSourceWhereInput | boolean
    connect?: CampaignSourceWhereUniqueInput
    update?: XOR<XOR<CampaignSourceUpdateToOneWithWhereWithoutCampaignsInput, CampaignSourceUpdateWithoutCampaignsInput>, CampaignSourceUncheckedUpdateWithoutCampaignsInput>
  }

  export type ProjectUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<ProjectCreateWithoutCampaignsInput, ProjectUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCampaignsInput
    upsert?: ProjectUpsertWithoutCampaignsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCampaignsInput, ProjectUpdateWithoutCampaignsInput>, ProjectUncheckedUpdateWithoutCampaignsInput>
  }

  export type LeadCampaignUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<LeadCampaignCreateWithoutCampaignInput, LeadCampaignUncheckedCreateWithoutCampaignInput> | LeadCampaignCreateWithoutCampaignInput[] | LeadCampaignUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: LeadCampaignCreateOrConnectWithoutCampaignInput | LeadCampaignCreateOrConnectWithoutCampaignInput[]
    upsert?: LeadCampaignUpsertWithWhereUniqueWithoutCampaignInput | LeadCampaignUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: LeadCampaignCreateManyCampaignInputEnvelope
    set?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    disconnect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    delete?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    connect?: LeadCampaignWhereUniqueInput | LeadCampaignWhereUniqueInput[]
    update?: LeadCampaignUpdateWithWhereUniqueWithoutCampaignInput | LeadCampaignUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: LeadCampaignUpdateManyWithWhereWithoutCampaignInput | LeadCampaignUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: LeadCampaignScalarWhereInput | LeadCampaignScalarWhereInput[]
  }

  export type LeadCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<LeadCreateWithoutCampaignsInput, LeadUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutCampaignsInput
    connect?: LeadWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutLeadsInput = {
    create?: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLeadsInput
    connect?: CampaignWhereUniqueInput
  }

  export type LeadUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<LeadCreateWithoutCampaignsInput, LeadUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutCampaignsInput
    upsert?: LeadUpsertWithoutCampaignsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutCampaignsInput, LeadUpdateWithoutCampaignsInput>, LeadUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLeadsInput
    upsert?: CampaignUpsertWithoutLeadsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutLeadsInput, CampaignUpdateWithoutLeadsInput>, CampaignUncheckedUpdateWithoutLeadsInput>
  }

  export type CampaignCreateNestedManyWithoutSourceInput = {
    create?: XOR<CampaignCreateWithoutSourceInput, CampaignUncheckedCreateWithoutSourceInput> | CampaignCreateWithoutSourceInput[] | CampaignUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSourceInput | CampaignCreateOrConnectWithoutSourceInput[]
    createMany?: CampaignCreateManySourceInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<CampaignCreateWithoutSourceInput, CampaignUncheckedCreateWithoutSourceInput> | CampaignCreateWithoutSourceInput[] | CampaignUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSourceInput | CampaignCreateOrConnectWithoutSourceInput[]
    createMany?: CampaignCreateManySourceInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignUpdateManyWithoutSourceNestedInput = {
    create?: XOR<CampaignCreateWithoutSourceInput, CampaignUncheckedCreateWithoutSourceInput> | CampaignCreateWithoutSourceInput[] | CampaignUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSourceInput | CampaignCreateOrConnectWithoutSourceInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutSourceInput | CampaignUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: CampaignCreateManySourceInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutSourceInput | CampaignUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutSourceInput | CampaignUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<CampaignCreateWithoutSourceInput, CampaignUncheckedCreateWithoutSourceInput> | CampaignCreateWithoutSourceInput[] | CampaignUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutSourceInput | CampaignCreateOrConnectWithoutSourceInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutSourceInput | CampaignUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: CampaignCreateManySourceInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutSourceInput | CampaignUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutSourceInput | CampaignUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type LeadTagCreateNestedManyWithoutTagInput = {
    create?: XOR<LeadTagCreateWithoutTagInput, LeadTagUncheckedCreateWithoutTagInput> | LeadTagCreateWithoutTagInput[] | LeadTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: LeadTagCreateOrConnectWithoutTagInput | LeadTagCreateOrConnectWithoutTagInput[]
    createMany?: LeadTagCreateManyTagInputEnvelope
    connect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
  }

  export type LeadTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<LeadTagCreateWithoutTagInput, LeadTagUncheckedCreateWithoutTagInput> | LeadTagCreateWithoutTagInput[] | LeadTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: LeadTagCreateOrConnectWithoutTagInput | LeadTagCreateOrConnectWithoutTagInput[]
    createMany?: LeadTagCreateManyTagInputEnvelope
    connect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
  }

  export type LeadTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<LeadTagCreateWithoutTagInput, LeadTagUncheckedCreateWithoutTagInput> | LeadTagCreateWithoutTagInput[] | LeadTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: LeadTagCreateOrConnectWithoutTagInput | LeadTagCreateOrConnectWithoutTagInput[]
    upsert?: LeadTagUpsertWithWhereUniqueWithoutTagInput | LeadTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: LeadTagCreateManyTagInputEnvelope
    set?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    disconnect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    delete?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    connect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    update?: LeadTagUpdateWithWhereUniqueWithoutTagInput | LeadTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: LeadTagUpdateManyWithWhereWithoutTagInput | LeadTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: LeadTagScalarWhereInput | LeadTagScalarWhereInput[]
  }

  export type LeadTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<LeadTagCreateWithoutTagInput, LeadTagUncheckedCreateWithoutTagInput> | LeadTagCreateWithoutTagInput[] | LeadTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: LeadTagCreateOrConnectWithoutTagInput | LeadTagCreateOrConnectWithoutTagInput[]
    upsert?: LeadTagUpsertWithWhereUniqueWithoutTagInput | LeadTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: LeadTagCreateManyTagInputEnvelope
    set?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    disconnect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    delete?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    connect?: LeadTagWhereUniqueInput | LeadTagWhereUniqueInput[]
    update?: LeadTagUpdateWithWhereUniqueWithoutTagInput | LeadTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: LeadTagUpdateManyWithWhereWithoutTagInput | LeadTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: LeadTagScalarWhereInput | LeadTagScalarWhereInput[]
  }

  export type LeadCreateNestedOneWithoutTagsInput = {
    create?: XOR<LeadCreateWithoutTagsInput, LeadUncheckedCreateWithoutTagsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutTagsInput
    connect?: LeadWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutLeadsInput = {
    create?: XOR<TagCreateWithoutLeadsInput, TagUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: TagCreateOrConnectWithoutLeadsInput
    connect?: TagWhereUniqueInput
  }

  export type LeadUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<LeadCreateWithoutTagsInput, LeadUncheckedCreateWithoutTagsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutTagsInput
    upsert?: LeadUpsertWithoutTagsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutTagsInput, LeadUpdateWithoutTagsInput>, LeadUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<TagCreateWithoutLeadsInput, TagUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: TagCreateOrConnectWithoutLeadsInput
    upsert?: TagUpsertWithoutLeadsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutLeadsInput, TagUpdateWithoutLeadsInput>, TagUncheckedUpdateWithoutLeadsInput>
  }

  export type ConstructionCompanyCreateNestedOneWithoutContactsInput = {
    create?: XOR<ConstructionCompanyCreateWithoutContactsInput, ConstructionCompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ConstructionCompanyCreateOrConnectWithoutContactsInput
    connect?: ConstructionCompanyWhereUniqueInput
  }

  export type ConstructionCompanyUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<ConstructionCompanyCreateWithoutContactsInput, ConstructionCompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ConstructionCompanyCreateOrConnectWithoutContactsInput
    upsert?: ConstructionCompanyUpsertWithoutContactsInput
    connect?: ConstructionCompanyWhereUniqueInput
    update?: XOR<XOR<ConstructionCompanyUpdateToOneWithWhereWithoutContactsInput, ConstructionCompanyUpdateWithoutContactsInput>, ConstructionCompanyUncheckedUpdateWithoutContactsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumScheduleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusFilter<$PrismaModel> | $Enums.ScheduleStatus
  }

  export type NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduleStatusFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPermissionCreateWithoutUserInput = {
    createdAt?: Date | string
    Permission: PermissionCreateNestedOneWithoutUsersInput
  }

  export type UserPermissionUncheckedCreateWithoutUserInput = {
    permissionId: string
    createdAt?: Date | string
  }

  export type UserPermissionCreateOrConnectWithoutUserInput = {
    where: UserPermissionWhereUniqueInput
    create: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput>
  }

  export type UserPermissionCreateManyUserInputEnvelope = {
    data: UserPermissionCreateManyUserInput | UserPermissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutBrokerInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutBrokerInput = {
    id?: string
    title: string
    customerId: string
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutBrokerInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutBrokerInput, LeadUncheckedCreateWithoutBrokerInput>
  }

  export type LeadCreateManyBrokerInputEnvelope = {
    data: LeadCreateManyBrokerInput | LeadCreateManyBrokerInput[]
    skipDuplicates?: boolean
  }

  export type LeadCommentCreateWithoutUserInput = {
    id?: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Lead: LeadCreateNestedOneWithoutCommentsInput
  }

  export type LeadCommentUncheckedCreateWithoutUserInput = {
    id?: string
    leadId: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCommentCreateOrConnectWithoutUserInput = {
    where: LeadCommentWhereUniqueInput
    create: XOR<LeadCommentCreateWithoutUserInput, LeadCommentUncheckedCreateWithoutUserInput>
  }

  export type LeadCommentCreateManyUserInputEnvelope = {
    data: LeadCommentCreateManyUserInput | LeadCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeadDocumentCreateWithoutUserInput = {
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Lead: LeadCreateNestedOneWithoutDocumentsInput
  }

  export type LeadDocumentUncheckedCreateWithoutUserInput = {
    leadId: string
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadDocumentCreateOrConnectWithoutUserInput = {
    where: LeadDocumentWhereUniqueInput
    create: XOR<LeadDocumentCreateWithoutUserInput, LeadDocumentUncheckedCreateWithoutUserInput>
  }

  export type LeadDocumentCreateManyUserInputEnvelope = {
    data: LeadDocumentCreateManyUserInput | LeadDocumentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutUserInput = {
    id?: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Lead: LeadCreateNestedOneWithoutSchedulesInput
    Participants?: ScheduleParticipantCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutUserInput = {
    id?: string
    leadId: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Participants?: ScheduleParticipantUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutUserInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput>
  }

  export type ScheduleCreateManyUserInputEnvelope = {
    data: ScheduleCreateManyUserInput | ScheduleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleParticipantCreateWithoutParticipantInput = {
    Schedule: ScheduleCreateNestedOneWithoutParticipantsInput
  }

  export type ScheduleParticipantUncheckedCreateWithoutParticipantInput = {
    scheduleId: string
  }

  export type ScheduleParticipantCreateOrConnectWithoutParticipantInput = {
    where: ScheduleParticipantWhereUniqueInput
    create: XOR<ScheduleParticipantCreateWithoutParticipantInput, ScheduleParticipantUncheckedCreateWithoutParticipantInput>
  }

  export type ScheduleParticipantCreateManyParticipantInputEnvelope = {
    data: ScheduleParticipantCreateManyParticipantInput | ScheduleParticipantCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserPermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPermissionWhereUniqueInput
    update: XOR<UserPermissionUpdateWithoutUserInput, UserPermissionUncheckedUpdateWithoutUserInput>
    create: XOR<UserPermissionCreateWithoutUserInput, UserPermissionUncheckedCreateWithoutUserInput>
  }

  export type UserPermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPermissionWhereUniqueInput
    data: XOR<UserPermissionUpdateWithoutUserInput, UserPermissionUncheckedUpdateWithoutUserInput>
  }

  export type UserPermissionUpdateManyWithWhereWithoutUserInput = {
    where: UserPermissionScalarWhereInput
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPermissionScalarWhereInput = {
    AND?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
    OR?: UserPermissionScalarWhereInput[]
    NOT?: UserPermissionScalarWhereInput | UserPermissionScalarWhereInput[]
    userId?: StringFilter<"UserPermission"> | string
    permissionId?: StringFilter<"UserPermission"> | string
    createdAt?: DateTimeFilter<"UserPermission"> | Date | string
  }

  export type LeadUpsertWithWhereUniqueWithoutBrokerInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutBrokerInput, LeadUncheckedUpdateWithoutBrokerInput>
    create: XOR<LeadCreateWithoutBrokerInput, LeadUncheckedCreateWithoutBrokerInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutBrokerInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutBrokerInput, LeadUncheckedUpdateWithoutBrokerInput>
  }

  export type LeadUpdateManyWithWhereWithoutBrokerInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutBrokerInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    title?: StringFilter<"Lead"> | string
    customerId?: StringFilter<"Lead"> | string
    userId?: StringNullableFilter<"Lead"> | string | null
    laneId?: IntFilter<"Lead"> | number
    value?: IntFilter<"Lead"> | number
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    lostedLeadReasonId?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
  }

  export type LeadCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: LeadCommentWhereUniqueInput
    update: XOR<LeadCommentUpdateWithoutUserInput, LeadCommentUncheckedUpdateWithoutUserInput>
    create: XOR<LeadCommentCreateWithoutUserInput, LeadCommentUncheckedCreateWithoutUserInput>
  }

  export type LeadCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: LeadCommentWhereUniqueInput
    data: XOR<LeadCommentUpdateWithoutUserInput, LeadCommentUncheckedUpdateWithoutUserInput>
  }

  export type LeadCommentUpdateManyWithWhereWithoutUserInput = {
    where: LeadCommentScalarWhereInput
    data: XOR<LeadCommentUpdateManyMutationInput, LeadCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type LeadCommentScalarWhereInput = {
    AND?: LeadCommentScalarWhereInput | LeadCommentScalarWhereInput[]
    OR?: LeadCommentScalarWhereInput[]
    NOT?: LeadCommentScalarWhereInput | LeadCommentScalarWhereInput[]
    id?: StringFilter<"LeadComment"> | string
    leadId?: StringFilter<"LeadComment"> | string
    userId?: StringFilter<"LeadComment"> | string
    content?: StringFilter<"LeadComment"> | string
    deleted?: BoolFilter<"LeadComment"> | boolean
    createdAt?: DateTimeFilter<"LeadComment"> | Date | string
    updatedAt?: DateTimeFilter<"LeadComment"> | Date | string
  }

  export type LeadDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: LeadDocumentWhereUniqueInput
    update: XOR<LeadDocumentUpdateWithoutUserInput, LeadDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<LeadDocumentCreateWithoutUserInput, LeadDocumentUncheckedCreateWithoutUserInput>
  }

  export type LeadDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: LeadDocumentWhereUniqueInput
    data: XOR<LeadDocumentUpdateWithoutUserInput, LeadDocumentUncheckedUpdateWithoutUserInput>
  }

  export type LeadDocumentUpdateManyWithWhereWithoutUserInput = {
    where: LeadDocumentScalarWhereInput
    data: XOR<LeadDocumentUpdateManyMutationInput, LeadDocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type LeadDocumentScalarWhereInput = {
    AND?: LeadDocumentScalarWhereInput | LeadDocumentScalarWhereInput[]
    OR?: LeadDocumentScalarWhereInput[]
    NOT?: LeadDocumentScalarWhereInput | LeadDocumentScalarWhereInput[]
    leadId?: StringFilter<"LeadDocument"> | string
    name?: StringFilter<"LeadDocument"> | string
    path?: StringFilter<"LeadDocument"> | string
    userId?: StringNullableFilter<"LeadDocument"> | string | null
    createdAt?: DateTimeFilter<"LeadDocument"> | Date | string
    updatedAt?: DateTimeFilter<"LeadDocument"> | Date | string
  }

  export type ScheduleUpsertWithWhereUniqueWithoutUserInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutUserInput, ScheduleUncheckedUpdateWithoutUserInput>
    create: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutUserInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutUserInput, ScheduleUncheckedUpdateWithoutUserInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutUserInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutUserInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    userId?: StringFilter<"Schedule"> | string
    leadId?: StringFilter<"Schedule"> | string
    date?: DateTimeFilter<"Schedule"> | Date | string
    address?: StringFilter<"Schedule"> | string
    nextNotificationAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    status?: EnumScheduleStatusFilter<"Schedule"> | $Enums.ScheduleStatus
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
  }

  export type ScheduleParticipantUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ScheduleParticipantWhereUniqueInput
    update: XOR<ScheduleParticipantUpdateWithoutParticipantInput, ScheduleParticipantUncheckedUpdateWithoutParticipantInput>
    create: XOR<ScheduleParticipantCreateWithoutParticipantInput, ScheduleParticipantUncheckedCreateWithoutParticipantInput>
  }

  export type ScheduleParticipantUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ScheduleParticipantWhereUniqueInput
    data: XOR<ScheduleParticipantUpdateWithoutParticipantInput, ScheduleParticipantUncheckedUpdateWithoutParticipantInput>
  }

  export type ScheduleParticipantUpdateManyWithWhereWithoutParticipantInput = {
    where: ScheduleParticipantScalarWhereInput
    data: XOR<ScheduleParticipantUpdateManyMutationInput, ScheduleParticipantUncheckedUpdateManyWithoutParticipantInput>
  }

  export type ScheduleParticipantScalarWhereInput = {
    AND?: ScheduleParticipantScalarWhereInput | ScheduleParticipantScalarWhereInput[]
    OR?: ScheduleParticipantScalarWhereInput[]
    NOT?: ScheduleParticipantScalarWhereInput | ScheduleParticipantScalarWhereInput[]
    scheduleId?: StringFilter<"ScheduleParticipant"> | string
    userId?: StringFilter<"ScheduleParticipant"> | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionCreateNestedManyWithoutUserInput
    Leads?: LeadCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentCreateNestedManyWithoutUserInput
    Schedules?: ScheduleCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantCreateNestedManyWithoutParticipantInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    Leads?: LeadUncheckedCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentUncheckedCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentUncheckedCreateNestedManyWithoutUserInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    Leads?: LeadUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUpdateManyWithoutParticipantNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    Leads?: LeadUncheckedUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUncheckedUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUncheckedUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionCreateNestedManyWithoutUserInput
    Leads?: LeadCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentCreateNestedManyWithoutUserInput
    Schedules?: ScheduleCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantCreateNestedManyWithoutParticipantInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    Leads?: LeadUncheckedCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentUncheckedCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentUncheckedCreateNestedManyWithoutUserInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    Leads?: LeadUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUpdateManyWithoutParticipantNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    Leads?: LeadUncheckedUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUncheckedUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUncheckedUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type UserPermissionCreateWithoutPermissionInput = {
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutPermissionsInput
  }

  export type UserPermissionUncheckedCreateWithoutPermissionInput = {
    userId: string
    createdAt?: Date | string
  }

  export type UserPermissionCreateOrConnectWithoutPermissionInput = {
    where: UserPermissionWhereUniqueInput
    create: XOR<UserPermissionCreateWithoutPermissionInput, UserPermissionUncheckedCreateWithoutPermissionInput>
  }

  export type UserPermissionCreateManyPermissionInputEnvelope = {
    data: UserPermissionCreateManyPermissionInput | UserPermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type UserPermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: UserPermissionWhereUniqueInput
    update: XOR<UserPermissionUpdateWithoutPermissionInput, UserPermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<UserPermissionCreateWithoutPermissionInput, UserPermissionUncheckedCreateWithoutPermissionInput>
  }

  export type UserPermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: UserPermissionWhereUniqueInput
    data: XOR<UserPermissionUpdateWithoutPermissionInput, UserPermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type UserPermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: UserPermissionScalarWhereInput
    data: XOR<UserPermissionUpdateManyMutationInput, UserPermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type UserCreateWithoutPermissionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Leads?: LeadCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentCreateNestedManyWithoutUserInput
    Schedules?: ScheduleCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantCreateNestedManyWithoutParticipantInput
  }

  export type UserUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Leads?: LeadUncheckedCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentUncheckedCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentUncheckedCreateNestedManyWithoutUserInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type UserCreateOrConnectWithoutPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutUsersInput = {
    id?: string
    slug: string
    description: string
  }

  export type PermissionUncheckedCreateWithoutUsersInput = {
    id?: string
    slug: string
    description: string
  }

  export type PermissionCreateOrConnectWithoutUsersInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutUsersInput, PermissionUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutPermissionsInput = {
    update: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Leads?: LeadUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUpdateManyWithoutParticipantNestedInput
  }

  export type UserUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Leads?: LeadUncheckedUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUncheckedUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUncheckedUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type PermissionUpsertWithoutUsersInput = {
    update: XOR<PermissionUpdateWithoutUsersInput, PermissionUncheckedUpdateWithoutUsersInput>
    create: XOR<PermissionCreateWithoutUsersInput, PermissionUncheckedCreateWithoutUsersInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutUsersInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutUsersInput, PermissionUncheckedUpdateWithoutUsersInput>
  }

  export type PermissionUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCreateWithoutCustomerInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutCustomerInput = {
    id?: string
    title: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutCustomerInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutCustomerInput, LeadUncheckedCreateWithoutCustomerInput>
  }

  export type LeadCreateManyCustomerInputEnvelope = {
    data: LeadCreateManyCustomerInput | LeadCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type LeadUpsertWithWhereUniqueWithoutCustomerInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutCustomerInput, LeadUncheckedUpdateWithoutCustomerInput>
    create: XOR<LeadCreateWithoutCustomerInput, LeadUncheckedCreateWithoutCustomerInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutCustomerInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutCustomerInput, LeadUncheckedUpdateWithoutCustomerInput>
  }

  export type LeadUpdateManyWithWhereWithoutCustomerInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutCustomerInput>
  }

  export type UserCreateWithoutSchedulesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionCreateNestedManyWithoutUserInput
    Leads?: LeadCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantCreateNestedManyWithoutParticipantInput
  }

  export type UserUncheckedCreateWithoutSchedulesInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    Leads?: LeadUncheckedCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentUncheckedCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentUncheckedCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type UserCreateOrConnectWithoutSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchedulesInput, UserUncheckedCreateWithoutSchedulesInput>
  }

  export type LeadCreateWithoutSchedulesInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutSchedulesInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutSchedulesInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutSchedulesInput, LeadUncheckedCreateWithoutSchedulesInput>
  }

  export type ScheduleParticipantCreateWithoutScheduleInput = {
    Participant: UserCreateNestedOneWithoutScheduleParticipatingInput
  }

  export type ScheduleParticipantUncheckedCreateWithoutScheduleInput = {
    userId: string
  }

  export type ScheduleParticipantCreateOrConnectWithoutScheduleInput = {
    where: ScheduleParticipantWhereUniqueInput
    create: XOR<ScheduleParticipantCreateWithoutScheduleInput, ScheduleParticipantUncheckedCreateWithoutScheduleInput>
  }

  export type ScheduleParticipantCreateManyScheduleInputEnvelope = {
    data: ScheduleParticipantCreateManyScheduleInput | ScheduleParticipantCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSchedulesInput = {
    update: XOR<UserUpdateWithoutSchedulesInput, UserUncheckedUpdateWithoutSchedulesInput>
    create: XOR<UserCreateWithoutSchedulesInput, UserUncheckedCreateWithoutSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSchedulesInput, UserUncheckedUpdateWithoutSchedulesInput>
  }

  export type UserUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    Leads?: LeadUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUpdateManyWithoutParticipantNestedInput
  }

  export type UserUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    Leads?: LeadUncheckedUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUncheckedUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUncheckedUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type LeadUpsertWithoutSchedulesInput = {
    update: XOR<LeadUpdateWithoutSchedulesInput, LeadUncheckedUpdateWithoutSchedulesInput>
    create: XOR<LeadCreateWithoutSchedulesInput, LeadUncheckedCreateWithoutSchedulesInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutSchedulesInput, LeadUncheckedUpdateWithoutSchedulesInput>
  }

  export type LeadUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type ScheduleParticipantUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ScheduleParticipantWhereUniqueInput
    update: XOR<ScheduleParticipantUpdateWithoutScheduleInput, ScheduleParticipantUncheckedUpdateWithoutScheduleInput>
    create: XOR<ScheduleParticipantCreateWithoutScheduleInput, ScheduleParticipantUncheckedCreateWithoutScheduleInput>
  }

  export type ScheduleParticipantUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ScheduleParticipantWhereUniqueInput
    data: XOR<ScheduleParticipantUpdateWithoutScheduleInput, ScheduleParticipantUncheckedUpdateWithoutScheduleInput>
  }

  export type ScheduleParticipantUpdateManyWithWhereWithoutScheduleInput = {
    where: ScheduleParticipantScalarWhereInput
    data: XOR<ScheduleParticipantUpdateManyMutationInput, ScheduleParticipantUncheckedUpdateManyWithoutScheduleInput>
  }

  export type ScheduleCreateWithoutParticipantsInput = {
    id?: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutSchedulesInput
    Lead: LeadCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutParticipantsInput = {
    id?: string
    userId: string
    leadId: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutParticipantsInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutParticipantsInput, ScheduleUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutScheduleParticipatingInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionCreateNestedManyWithoutUserInput
    Leads?: LeadCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentCreateNestedManyWithoutUserInput
    Schedules?: ScheduleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScheduleParticipatingInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    Leads?: LeadUncheckedCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentUncheckedCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentUncheckedCreateNestedManyWithoutUserInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScheduleParticipatingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScheduleParticipatingInput, UserUncheckedCreateWithoutScheduleParticipatingInput>
  }

  export type ScheduleUpsertWithoutParticipantsInput = {
    update: XOR<ScheduleUpdateWithoutParticipantsInput, ScheduleUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ScheduleCreateWithoutParticipantsInput, ScheduleUncheckedCreateWithoutParticipantsInput>
    where?: ScheduleWhereInput
  }

  export type ScheduleUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ScheduleWhereInput
    data: XOR<ScheduleUpdateWithoutParticipantsInput, ScheduleUncheckedUpdateWithoutParticipantsInput>
  }

  export type ScheduleUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutSchedulesNestedInput
    Lead?: LeadUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutScheduleParticipatingInput = {
    update: XOR<UserUpdateWithoutScheduleParticipatingInput, UserUncheckedUpdateWithoutScheduleParticipatingInput>
    create: XOR<UserCreateWithoutScheduleParticipatingInput, UserUncheckedCreateWithoutScheduleParticipatingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScheduleParticipatingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScheduleParticipatingInput, UserUncheckedUpdateWithoutScheduleParticipatingInput>
  }

  export type UserUpdateWithoutScheduleParticipatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    Leads?: LeadUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScheduleParticipatingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    Leads?: LeadUncheckedUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUncheckedUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUncheckedUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LeadCampaignCreateWithoutLeadInput = {
    Campaign: CampaignCreateNestedOneWithoutLeadsInput
  }

  export type LeadCampaignUncheckedCreateWithoutLeadInput = {
    campaignId: string
  }

  export type LeadCampaignCreateOrConnectWithoutLeadInput = {
    where: LeadCampaignWhereUniqueInput
    create: XOR<LeadCampaignCreateWithoutLeadInput, LeadCampaignUncheckedCreateWithoutLeadInput>
  }

  export type LeadCampaignCreateManyLeadInputEnvelope = {
    data: LeadCampaignCreateManyLeadInput | LeadCampaignCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutLeadsInput = {
    id?: string
    picture: string
    name: string
    phone: string
    email: string
    chatwootContactId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUncheckedCreateWithoutLeadsInput = {
    id?: string
    picture: string
    name: string
    phone: string
    email: string
    chatwootContactId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateOrConnectWithoutLeadsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutLeadsInput, CustomerUncheckedCreateWithoutLeadsInput>
  }

  export type UserCreateWithoutLeadsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionCreateNestedManyWithoutUserInput
    LeadComments?: LeadCommentCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentCreateNestedManyWithoutUserInput
    Schedules?: ScheduleCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantCreateNestedManyWithoutParticipantInput
  }

  export type UserUncheckedCreateWithoutLeadsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    LeadComments?: LeadCommentUncheckedCreateNestedManyWithoutUserInput
    LeadDocuments?: LeadDocumentUncheckedCreateNestedManyWithoutUserInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type UserCreateOrConnectWithoutLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
  }

  export type LeadTagCreateWithoutLeadInput = {
    Tag: TagCreateNestedOneWithoutLeadsInput
  }

  export type LeadTagUncheckedCreateWithoutLeadInput = {
    tagId: string
  }

  export type LeadTagCreateOrConnectWithoutLeadInput = {
    where: LeadTagWhereUniqueInput
    create: XOR<LeadTagCreateWithoutLeadInput, LeadTagUncheckedCreateWithoutLeadInput>
  }

  export type LeadTagCreateManyLeadInputEnvelope = {
    data: LeadTagCreateManyLeadInput | LeadTagCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type LeadDocumentCreateWithoutLeadInput = {
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedOneWithoutLeadDocumentsInput
  }

  export type LeadDocumentUncheckedCreateWithoutLeadInput = {
    name: string
    path: string
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadDocumentCreateOrConnectWithoutLeadInput = {
    where: LeadDocumentWhereUniqueInput
    create: XOR<LeadDocumentCreateWithoutLeadInput, LeadDocumentUncheckedCreateWithoutLeadInput>
  }

  export type LeadDocumentCreateManyLeadInputEnvelope = {
    data: LeadDocumentCreateManyLeadInput | LeadDocumentCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type LeadCommentCreateWithoutLeadInput = {
    id?: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutLeadCommentsInput
  }

  export type LeadCommentUncheckedCreateWithoutLeadInput = {
    id?: string
    userId: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCommentCreateOrConnectWithoutLeadInput = {
    where: LeadCommentWhereUniqueInput
    create: XOR<LeadCommentCreateWithoutLeadInput, LeadCommentUncheckedCreateWithoutLeadInput>
  }

  export type LeadCommentCreateManyLeadInputEnvelope = {
    data: LeadCommentCreateManyLeadInput | LeadCommentCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type LeadMetadataCreateWithoutLeadInput = {
    id?: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadMetadataUncheckedCreateWithoutLeadInput = {
    id?: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadMetadataCreateOrConnectWithoutLeadInput = {
    where: LeadMetadataWhereUniqueInput
    create: XOR<LeadMetadataCreateWithoutLeadInput, LeadMetadataUncheckedCreateWithoutLeadInput>
  }

  export type LeadMetadataCreateManyLeadInputEnvelope = {
    data: LeadMetadataCreateManyLeadInput | LeadMetadataCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type LeadChatCreateWithoutLeadInput = {
    conversationId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadChatUncheckedCreateWithoutLeadInput = {
    conversationId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadChatCreateOrConnectWithoutLeadInput = {
    where: LeadChatWhereUniqueInput
    create: XOR<LeadChatCreateWithoutLeadInput, LeadChatUncheckedCreateWithoutLeadInput>
  }

  export type LeadChatCreateManyLeadInputEnvelope = {
    data: LeadChatCreateManyLeadInput | LeadChatCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutLeadInput = {
    id?: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutSchedulesInput
    Participants?: ScheduleParticipantCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutLeadInput = {
    id?: string
    userId: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Participants?: ScheduleParticipantUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutLeadInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutLeadInput, ScheduleUncheckedCreateWithoutLeadInput>
  }

  export type ScheduleCreateManyLeadInputEnvelope = {
    data: ScheduleCreateManyLeadInput | ScheduleCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type LaneCreateWithoutLeadsInput = {
    name: string
    color: string
    sortOrder: number
    principal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaneUncheckedCreateWithoutLeadsInput = {
    id?: number
    name: string
    color: string
    sortOrder: number
    principal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaneCreateOrConnectWithoutLeadsInput = {
    where: LaneWhereUniqueInput
    create: XOR<LaneCreateWithoutLeadsInput, LaneUncheckedCreateWithoutLeadsInput>
  }

  export type LeadLostReasonCreateWithoutLeadsInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadLostReasonUncheckedCreateWithoutLeadsInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadLostReasonCreateOrConnectWithoutLeadsInput = {
    where: LeadLostReasonWhereUniqueInput
    create: XOR<LeadLostReasonCreateWithoutLeadsInput, LeadLostReasonUncheckedCreateWithoutLeadsInput>
  }

  export type LeadCampaignUpsertWithWhereUniqueWithoutLeadInput = {
    where: LeadCampaignWhereUniqueInput
    update: XOR<LeadCampaignUpdateWithoutLeadInput, LeadCampaignUncheckedUpdateWithoutLeadInput>
    create: XOR<LeadCampaignCreateWithoutLeadInput, LeadCampaignUncheckedCreateWithoutLeadInput>
  }

  export type LeadCampaignUpdateWithWhereUniqueWithoutLeadInput = {
    where: LeadCampaignWhereUniqueInput
    data: XOR<LeadCampaignUpdateWithoutLeadInput, LeadCampaignUncheckedUpdateWithoutLeadInput>
  }

  export type LeadCampaignUpdateManyWithWhereWithoutLeadInput = {
    where: LeadCampaignScalarWhereInput
    data: XOR<LeadCampaignUpdateManyMutationInput, LeadCampaignUncheckedUpdateManyWithoutLeadInput>
  }

  export type LeadCampaignScalarWhereInput = {
    AND?: LeadCampaignScalarWhereInput | LeadCampaignScalarWhereInput[]
    OR?: LeadCampaignScalarWhereInput[]
    NOT?: LeadCampaignScalarWhereInput | LeadCampaignScalarWhereInput[]
    leadId?: StringFilter<"LeadCampaign"> | string
    campaignId?: StringFilter<"LeadCampaign"> | string
  }

  export type CustomerUpsertWithoutLeadsInput = {
    update: XOR<CustomerUpdateWithoutLeadsInput, CustomerUncheckedUpdateWithoutLeadsInput>
    create: XOR<CustomerCreateWithoutLeadsInput, CustomerUncheckedCreateWithoutLeadsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutLeadsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutLeadsInput, CustomerUncheckedUpdateWithoutLeadsInput>
  }

  export type CustomerUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    chatwootContactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    chatwootContactId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutLeadsInput = {
    update: XOR<UserUpdateWithoutLeadsInput, UserUncheckedUpdateWithoutLeadsInput>
    create: XOR<UserCreateWithoutLeadsInput, UserUncheckedCreateWithoutLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeadsInput, UserUncheckedUpdateWithoutLeadsInput>
  }

  export type UserUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    LeadComments?: LeadCommentUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUpdateManyWithoutParticipantNestedInput
  }

  export type UserUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    LeadComments?: LeadCommentUncheckedUpdateManyWithoutUserNestedInput
    LeadDocuments?: LeadDocumentUncheckedUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type LeadTagUpsertWithWhereUniqueWithoutLeadInput = {
    where: LeadTagWhereUniqueInput
    update: XOR<LeadTagUpdateWithoutLeadInput, LeadTagUncheckedUpdateWithoutLeadInput>
    create: XOR<LeadTagCreateWithoutLeadInput, LeadTagUncheckedCreateWithoutLeadInput>
  }

  export type LeadTagUpdateWithWhereUniqueWithoutLeadInput = {
    where: LeadTagWhereUniqueInput
    data: XOR<LeadTagUpdateWithoutLeadInput, LeadTagUncheckedUpdateWithoutLeadInput>
  }

  export type LeadTagUpdateManyWithWhereWithoutLeadInput = {
    where: LeadTagScalarWhereInput
    data: XOR<LeadTagUpdateManyMutationInput, LeadTagUncheckedUpdateManyWithoutLeadInput>
  }

  export type LeadTagScalarWhereInput = {
    AND?: LeadTagScalarWhereInput | LeadTagScalarWhereInput[]
    OR?: LeadTagScalarWhereInput[]
    NOT?: LeadTagScalarWhereInput | LeadTagScalarWhereInput[]
    leadId?: StringFilter<"LeadTag"> | string
    tagId?: StringFilter<"LeadTag"> | string
  }

  export type LeadDocumentUpsertWithWhereUniqueWithoutLeadInput = {
    where: LeadDocumentWhereUniqueInput
    update: XOR<LeadDocumentUpdateWithoutLeadInput, LeadDocumentUncheckedUpdateWithoutLeadInput>
    create: XOR<LeadDocumentCreateWithoutLeadInput, LeadDocumentUncheckedCreateWithoutLeadInput>
  }

  export type LeadDocumentUpdateWithWhereUniqueWithoutLeadInput = {
    where: LeadDocumentWhereUniqueInput
    data: XOR<LeadDocumentUpdateWithoutLeadInput, LeadDocumentUncheckedUpdateWithoutLeadInput>
  }

  export type LeadDocumentUpdateManyWithWhereWithoutLeadInput = {
    where: LeadDocumentScalarWhereInput
    data: XOR<LeadDocumentUpdateManyMutationInput, LeadDocumentUncheckedUpdateManyWithoutLeadInput>
  }

  export type LeadCommentUpsertWithWhereUniqueWithoutLeadInput = {
    where: LeadCommentWhereUniqueInput
    update: XOR<LeadCommentUpdateWithoutLeadInput, LeadCommentUncheckedUpdateWithoutLeadInput>
    create: XOR<LeadCommentCreateWithoutLeadInput, LeadCommentUncheckedCreateWithoutLeadInput>
  }

  export type LeadCommentUpdateWithWhereUniqueWithoutLeadInput = {
    where: LeadCommentWhereUniqueInput
    data: XOR<LeadCommentUpdateWithoutLeadInput, LeadCommentUncheckedUpdateWithoutLeadInput>
  }

  export type LeadCommentUpdateManyWithWhereWithoutLeadInput = {
    where: LeadCommentScalarWhereInput
    data: XOR<LeadCommentUpdateManyMutationInput, LeadCommentUncheckedUpdateManyWithoutLeadInput>
  }

  export type LeadMetadataUpsertWithWhereUniqueWithoutLeadInput = {
    where: LeadMetadataWhereUniqueInput
    update: XOR<LeadMetadataUpdateWithoutLeadInput, LeadMetadataUncheckedUpdateWithoutLeadInput>
    create: XOR<LeadMetadataCreateWithoutLeadInput, LeadMetadataUncheckedCreateWithoutLeadInput>
  }

  export type LeadMetadataUpdateWithWhereUniqueWithoutLeadInput = {
    where: LeadMetadataWhereUniqueInput
    data: XOR<LeadMetadataUpdateWithoutLeadInput, LeadMetadataUncheckedUpdateWithoutLeadInput>
  }

  export type LeadMetadataUpdateManyWithWhereWithoutLeadInput = {
    where: LeadMetadataScalarWhereInput
    data: XOR<LeadMetadataUpdateManyMutationInput, LeadMetadataUncheckedUpdateManyWithoutLeadInput>
  }

  export type LeadMetadataScalarWhereInput = {
    AND?: LeadMetadataScalarWhereInput | LeadMetadataScalarWhereInput[]
    OR?: LeadMetadataScalarWhereInput[]
    NOT?: LeadMetadataScalarWhereInput | LeadMetadataScalarWhereInput[]
    id?: StringFilter<"LeadMetadata"> | string
    leadId?: StringFilter<"LeadMetadata"> | string
    key?: StringFilter<"LeadMetadata"> | string
    value?: StringFilter<"LeadMetadata"> | string
    createdAt?: DateTimeFilter<"LeadMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"LeadMetadata"> | Date | string
  }

  export type LeadChatUpsertWithWhereUniqueWithoutLeadInput = {
    where: LeadChatWhereUniqueInput
    update: XOR<LeadChatUpdateWithoutLeadInput, LeadChatUncheckedUpdateWithoutLeadInput>
    create: XOR<LeadChatCreateWithoutLeadInput, LeadChatUncheckedCreateWithoutLeadInput>
  }

  export type LeadChatUpdateWithWhereUniqueWithoutLeadInput = {
    where: LeadChatWhereUniqueInput
    data: XOR<LeadChatUpdateWithoutLeadInput, LeadChatUncheckedUpdateWithoutLeadInput>
  }

  export type LeadChatUpdateManyWithWhereWithoutLeadInput = {
    where: LeadChatScalarWhereInput
    data: XOR<LeadChatUpdateManyMutationInput, LeadChatUncheckedUpdateManyWithoutLeadInput>
  }

  export type LeadChatScalarWhereInput = {
    AND?: LeadChatScalarWhereInput | LeadChatScalarWhereInput[]
    OR?: LeadChatScalarWhereInput[]
    NOT?: LeadChatScalarWhereInput | LeadChatScalarWhereInput[]
    leadId?: StringFilter<"LeadChat"> | string
    conversationId?: StringFilter<"LeadChat"> | string
    status?: StringFilter<"LeadChat"> | string
    createdAt?: DateTimeFilter<"LeadChat"> | Date | string
    updatedAt?: DateTimeFilter<"LeadChat"> | Date | string
  }

  export type ScheduleUpsertWithWhereUniqueWithoutLeadInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutLeadInput, ScheduleUncheckedUpdateWithoutLeadInput>
    create: XOR<ScheduleCreateWithoutLeadInput, ScheduleUncheckedCreateWithoutLeadInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutLeadInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutLeadInput, ScheduleUncheckedUpdateWithoutLeadInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutLeadInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutLeadInput>
  }

  export type LaneUpsertWithoutLeadsInput = {
    update: XOR<LaneUpdateWithoutLeadsInput, LaneUncheckedUpdateWithoutLeadsInput>
    create: XOR<LaneCreateWithoutLeadsInput, LaneUncheckedCreateWithoutLeadsInput>
    where?: LaneWhereInput
  }

  export type LaneUpdateToOneWithWhereWithoutLeadsInput = {
    where?: LaneWhereInput
    data: XOR<LaneUpdateWithoutLeadsInput, LaneUncheckedUpdateWithoutLeadsInput>
  }

  export type LaneUpdateWithoutLeadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaneUncheckedUpdateWithoutLeadsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadLostReasonUpsertWithoutLeadsInput = {
    update: XOR<LeadLostReasonUpdateWithoutLeadsInput, LeadLostReasonUncheckedUpdateWithoutLeadsInput>
    create: XOR<LeadLostReasonCreateWithoutLeadsInput, LeadLostReasonUncheckedCreateWithoutLeadsInput>
    where?: LeadLostReasonWhereInput
  }

  export type LeadLostReasonUpdateToOneWithWhereWithoutLeadsInput = {
    where?: LeadLostReasonWhereInput
    data: XOR<LeadLostReasonUpdateWithoutLeadsInput, LeadLostReasonUncheckedUpdateWithoutLeadsInput>
  }

  export type LeadLostReasonUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadLostReasonUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateWithoutMetadataInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutMetadataInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutMetadataInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutMetadataInput, LeadUncheckedCreateWithoutMetadataInput>
  }

  export type LeadUpsertWithoutMetadataInput = {
    update: XOR<LeadUpdateWithoutMetadataInput, LeadUncheckedUpdateWithoutMetadataInput>
    create: XOR<LeadCreateWithoutMetadataInput, LeadUncheckedCreateWithoutMetadataInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutMetadataInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutMetadataInput, LeadUncheckedUpdateWithoutMetadataInput>
  }

  export type LeadUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateWithoutLostedReasonInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutLostedReasonInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutLostedReasonInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutLostedReasonInput, LeadUncheckedCreateWithoutLostedReasonInput>
  }

  export type LeadCreateManyLostedReasonInputEnvelope = {
    data: LeadCreateManyLostedReasonInput | LeadCreateManyLostedReasonInput[]
    skipDuplicates?: boolean
  }

  export type LeadUpsertWithWhereUniqueWithoutLostedReasonInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutLostedReasonInput, LeadUncheckedUpdateWithoutLostedReasonInput>
    create: XOR<LeadCreateWithoutLostedReasonInput, LeadUncheckedCreateWithoutLostedReasonInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutLostedReasonInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutLostedReasonInput, LeadUncheckedUpdateWithoutLostedReasonInput>
  }

  export type LeadUpdateManyWithWhereWithoutLostedReasonInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutLostedReasonInput>
  }

  export type UserCreateWithoutLeadCommentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionCreateNestedManyWithoutUserInput
    Leads?: LeadCreateNestedManyWithoutBrokerInput
    LeadDocuments?: LeadDocumentCreateNestedManyWithoutUserInput
    Schedules?: ScheduleCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantCreateNestedManyWithoutParticipantInput
  }

  export type UserUncheckedCreateWithoutLeadCommentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    Leads?: LeadUncheckedCreateNestedManyWithoutBrokerInput
    LeadDocuments?: LeadDocumentUncheckedCreateNestedManyWithoutUserInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type UserCreateOrConnectWithoutLeadCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeadCommentsInput, UserUncheckedCreateWithoutLeadCommentsInput>
  }

  export type LeadCreateWithoutCommentsInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutCommentsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutCommentsInput, LeadUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutLeadCommentsInput = {
    update: XOR<UserUpdateWithoutLeadCommentsInput, UserUncheckedUpdateWithoutLeadCommentsInput>
    create: XOR<UserCreateWithoutLeadCommentsInput, UserUncheckedCreateWithoutLeadCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeadCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeadCommentsInput, UserUncheckedUpdateWithoutLeadCommentsInput>
  }

  export type UserUpdateWithoutLeadCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    Leads?: LeadUpdateManyWithoutBrokerNestedInput
    LeadDocuments?: LeadDocumentUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUpdateManyWithoutParticipantNestedInput
  }

  export type UserUncheckedUpdateWithoutLeadCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    Leads?: LeadUncheckedUpdateManyWithoutBrokerNestedInput
    LeadDocuments?: LeadDocumentUncheckedUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type LeadUpsertWithoutCommentsInput = {
    update: XOR<LeadUpdateWithoutCommentsInput, LeadUncheckedUpdateWithoutCommentsInput>
    create: XOR<LeadCreateWithoutCommentsInput, LeadUncheckedCreateWithoutCommentsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutCommentsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutCommentsInput, LeadUncheckedUpdateWithoutCommentsInput>
  }

  export type LeadUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateWithoutChatsInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutChatsInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutChatsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutChatsInput, LeadUncheckedCreateWithoutChatsInput>
  }

  export type LeadUpsertWithoutChatsInput = {
    update: XOR<LeadUpdateWithoutChatsInput, LeadUncheckedUpdateWithoutChatsInput>
    create: XOR<LeadCreateWithoutChatsInput, LeadUncheckedCreateWithoutChatsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutChatsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutChatsInput, LeadUncheckedUpdateWithoutChatsInput>
  }

  export type LeadUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateWithoutDocumentsInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutDocumentsInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutDocumentsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutDocumentsInput, LeadUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutLeadDocumentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionCreateNestedManyWithoutUserInput
    Leads?: LeadCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentCreateNestedManyWithoutUserInput
    Schedules?: ScheduleCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantCreateNestedManyWithoutParticipantInput
  }

  export type UserUncheckedCreateWithoutLeadDocumentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    master?: boolean
    status?: $Enums.UserStatus
    chatwootAgentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Permissions?: UserPermissionUncheckedCreateNestedManyWithoutUserInput
    Leads?: LeadUncheckedCreateNestedManyWithoutBrokerInput
    LeadComments?: LeadCommentUncheckedCreateNestedManyWithoutUserInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    ScheduleParticipating?: ScheduleParticipantUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type UserCreateOrConnectWithoutLeadDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeadDocumentsInput, UserUncheckedCreateWithoutLeadDocumentsInput>
  }

  export type LeadUpsertWithoutDocumentsInput = {
    update: XOR<LeadUpdateWithoutDocumentsInput, LeadUncheckedUpdateWithoutDocumentsInput>
    create: XOR<LeadCreateWithoutDocumentsInput, LeadUncheckedCreateWithoutDocumentsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutDocumentsInput, LeadUncheckedUpdateWithoutDocumentsInput>
  }

  export type LeadUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type UserUpsertWithoutLeadDocumentsInput = {
    update: XOR<UserUpdateWithoutLeadDocumentsInput, UserUncheckedUpdateWithoutLeadDocumentsInput>
    create: XOR<UserCreateWithoutLeadDocumentsInput, UserUncheckedCreateWithoutLeadDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeadDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeadDocumentsInput, UserUncheckedUpdateWithoutLeadDocumentsInput>
  }

  export type UserUpdateWithoutLeadDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUpdateManyWithoutUserNestedInput
    Leads?: LeadUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUpdateManyWithoutParticipantNestedInput
  }

  export type UserUncheckedUpdateWithoutLeadDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    master?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    chatwootAgentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Permissions?: UserPermissionUncheckedUpdateManyWithoutUserNestedInput
    Leads?: LeadUncheckedUpdateManyWithoutBrokerNestedInput
    LeadComments?: LeadCommentUncheckedUpdateManyWithoutUserNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    ScheduleParticipating?: ScheduleParticipantUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type LeadCreateWithoutLaneInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutLaneInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutLaneInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutLaneInput, LeadUncheckedCreateWithoutLaneInput>
  }

  export type LeadCreateManyLaneInputEnvelope = {
    data: LeadCreateManyLaneInput | LeadCreateManyLaneInput[]
    skipDuplicates?: boolean
  }

  export type LeadUpsertWithWhereUniqueWithoutLaneInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutLaneInput, LeadUncheckedUpdateWithoutLaneInput>
    create: XOR<LeadCreateWithoutLaneInput, LeadUncheckedCreateWithoutLaneInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutLaneInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutLaneInput, LeadUncheckedUpdateWithoutLaneInput>
  }

  export type LeadUpdateManyWithWhereWithoutLaneInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutLaneInput>
  }

  export type ProjectCreateWithoutConstructionCompanyInput = {
    id?: string
    title: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: CampaignCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutConstructionCompanyInput = {
    id?: string
    title: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: CampaignUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutConstructionCompanyInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutConstructionCompanyInput, ProjectUncheckedCreateWithoutConstructionCompanyInput>
  }

  export type ProjectCreateManyConstructionCompanyInputEnvelope = {
    data: ProjectCreateManyConstructionCompanyInput | ProjectCreateManyConstructionCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutConstructionCompanyInput = {
    id?: string
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUncheckedCreateWithoutConstructionCompanyInput = {
    id?: string
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutConstructionCompanyInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutConstructionCompanyInput, ContactUncheckedCreateWithoutConstructionCompanyInput>
  }

  export type ContactCreateManyConstructionCompanyInputEnvelope = {
    data: ContactCreateManyConstructionCompanyInput | ContactCreateManyConstructionCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutConstructionCompanyInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutConstructionCompanyInput, ProjectUncheckedUpdateWithoutConstructionCompanyInput>
    create: XOR<ProjectCreateWithoutConstructionCompanyInput, ProjectUncheckedCreateWithoutConstructionCompanyInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutConstructionCompanyInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutConstructionCompanyInput, ProjectUncheckedUpdateWithoutConstructionCompanyInput>
  }

  export type ProjectUpdateManyWithWhereWithoutConstructionCompanyInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutConstructionCompanyInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    url?: StringFilter<"Project"> | string
    constructionId?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutConstructionCompanyInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutConstructionCompanyInput, ContactUncheckedUpdateWithoutConstructionCompanyInput>
    create: XOR<ContactCreateWithoutConstructionCompanyInput, ContactUncheckedCreateWithoutConstructionCompanyInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutConstructionCompanyInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutConstructionCompanyInput, ContactUncheckedUpdateWithoutConstructionCompanyInput>
  }

  export type ContactUpdateManyWithWhereWithoutConstructionCompanyInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutConstructionCompanyInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringFilter<"Contact"> | string
    constructionCompanyId?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type CampaignCreateWithoutProjectInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadCampaignCreateNestedManyWithoutCampaignInput
    Source?: CampaignSourceCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutProjectInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutProjectInput, CampaignUncheckedCreateWithoutProjectInput>
  }

  export type CampaignCreateManyProjectInputEnvelope = {
    data: CampaignCreateManyProjectInput | CampaignCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ConstructionCompanyCreateWithoutProjectsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Contacts?: ContactCreateNestedManyWithoutConstructionCompanyInput
  }

  export type ConstructionCompanyUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Contacts?: ContactUncheckedCreateNestedManyWithoutConstructionCompanyInput
  }

  export type ConstructionCompanyCreateOrConnectWithoutProjectsInput = {
    where: ConstructionCompanyWhereUniqueInput
    create: XOR<ConstructionCompanyCreateWithoutProjectsInput, ConstructionCompanyUncheckedCreateWithoutProjectsInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutProjectInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutProjectInput, CampaignUncheckedUpdateWithoutProjectInput>
    create: XOR<CampaignCreateWithoutProjectInput, CampaignUncheckedCreateWithoutProjectInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutProjectInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutProjectInput, CampaignUncheckedUpdateWithoutProjectInput>
  }

  export type CampaignUpdateManyWithWhereWithoutProjectInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutProjectInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    title?: StringFilter<"Campaign"> | string
    sourceId?: StringNullableFilter<"Campaign"> | string | null
    projectId?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type ConstructionCompanyUpsertWithoutProjectsInput = {
    update: XOR<ConstructionCompanyUpdateWithoutProjectsInput, ConstructionCompanyUncheckedUpdateWithoutProjectsInput>
    create: XOR<ConstructionCompanyCreateWithoutProjectsInput, ConstructionCompanyUncheckedCreateWithoutProjectsInput>
    where?: ConstructionCompanyWhereInput
  }

  export type ConstructionCompanyUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ConstructionCompanyWhereInput
    data: XOR<ConstructionCompanyUpdateWithoutProjectsInput, ConstructionCompanyUncheckedUpdateWithoutProjectsInput>
  }

  export type ConstructionCompanyUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Contacts?: ContactUpdateManyWithoutConstructionCompanyNestedInput
  }

  export type ConstructionCompanyUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Contacts?: ContactUncheckedUpdateManyWithoutConstructionCompanyNestedInput
  }

  export type LeadCampaignCreateWithoutCampaignInput = {
    Lead: LeadCreateNestedOneWithoutCampaignsInput
  }

  export type LeadCampaignUncheckedCreateWithoutCampaignInput = {
    leadId: string
  }

  export type LeadCampaignCreateOrConnectWithoutCampaignInput = {
    where: LeadCampaignWhereUniqueInput
    create: XOR<LeadCampaignCreateWithoutCampaignInput, LeadCampaignUncheckedCreateWithoutCampaignInput>
  }

  export type LeadCampaignCreateManyCampaignInputEnvelope = {
    data: LeadCampaignCreateManyCampaignInput | LeadCampaignCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignSourceCreateWithoutCampaignsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignSourceUncheckedCreateWithoutCampaignsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignSourceCreateOrConnectWithoutCampaignsInput = {
    where: CampaignSourceWhereUniqueInput
    create: XOR<CampaignSourceCreateWithoutCampaignsInput, CampaignSourceUncheckedCreateWithoutCampaignsInput>
  }

  export type ProjectCreateWithoutCampaignsInput = {
    id?: string
    title: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ConstructionCompany: ConstructionCompanyCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutCampaignsInput = {
    id?: string
    title: string
    url: string
    constructionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateOrConnectWithoutCampaignsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCampaignsInput, ProjectUncheckedCreateWithoutCampaignsInput>
  }

  export type LeadCampaignUpsertWithWhereUniqueWithoutCampaignInput = {
    where: LeadCampaignWhereUniqueInput
    update: XOR<LeadCampaignUpdateWithoutCampaignInput, LeadCampaignUncheckedUpdateWithoutCampaignInput>
    create: XOR<LeadCampaignCreateWithoutCampaignInput, LeadCampaignUncheckedCreateWithoutCampaignInput>
  }

  export type LeadCampaignUpdateWithWhereUniqueWithoutCampaignInput = {
    where: LeadCampaignWhereUniqueInput
    data: XOR<LeadCampaignUpdateWithoutCampaignInput, LeadCampaignUncheckedUpdateWithoutCampaignInput>
  }

  export type LeadCampaignUpdateManyWithWhereWithoutCampaignInput = {
    where: LeadCampaignScalarWhereInput
    data: XOR<LeadCampaignUpdateManyMutationInput, LeadCampaignUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignSourceUpsertWithoutCampaignsInput = {
    update: XOR<CampaignSourceUpdateWithoutCampaignsInput, CampaignSourceUncheckedUpdateWithoutCampaignsInput>
    create: XOR<CampaignSourceCreateWithoutCampaignsInput, CampaignSourceUncheckedCreateWithoutCampaignsInput>
    where?: CampaignSourceWhereInput
  }

  export type CampaignSourceUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: CampaignSourceWhereInput
    data: XOR<CampaignSourceUpdateWithoutCampaignsInput, CampaignSourceUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignSourceUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignSourceUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpsertWithoutCampaignsInput = {
    update: XOR<ProjectUpdateWithoutCampaignsInput, ProjectUncheckedUpdateWithoutCampaignsInput>
    create: XOR<ProjectCreateWithoutCampaignsInput, ProjectUncheckedCreateWithoutCampaignsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCampaignsInput, ProjectUncheckedUpdateWithoutCampaignsInput>
  }

  export type ProjectUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ConstructionCompany?: ConstructionCompanyUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    constructionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateWithoutCampaignsInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Tags?: LeadTagCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutCampaignsInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Tags?: LeadTagUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutCampaignsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutCampaignsInput, LeadUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignCreateWithoutLeadsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Source?: CampaignSourceCreateNestedOneWithoutCampaignsInput
    Project: ProjectCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutLeadsInput = {
    id?: string
    title: string
    sourceId?: string | null
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateOrConnectWithoutLeadsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
  }

  export type LeadUpsertWithoutCampaignsInput = {
    update: XOR<LeadUpdateWithoutCampaignsInput, LeadUncheckedUpdateWithoutCampaignsInput>
    create: XOR<LeadCreateWithoutCampaignsInput, LeadUncheckedCreateWithoutCampaignsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutCampaignsInput, LeadUncheckedUpdateWithoutCampaignsInput>
  }

  export type LeadUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type CampaignUpsertWithoutLeadsInput = {
    update: XOR<CampaignUpdateWithoutLeadsInput, CampaignUncheckedUpdateWithoutLeadsInput>
    create: XOR<CampaignCreateWithoutLeadsInput, CampaignUncheckedCreateWithoutLeadsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutLeadsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutLeadsInput, CampaignUncheckedUpdateWithoutLeadsInput>
  }

  export type CampaignUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Source?: CampaignSourceUpdateOneWithoutCampaignsNestedInput
    Project?: ProjectUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateWithoutSourceInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadCampaignCreateNestedManyWithoutCampaignInput
    Project: ProjectCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutSourceInput = {
    id?: string
    title: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Leads?: LeadCampaignUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSourceInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSourceInput, CampaignUncheckedCreateWithoutSourceInput>
  }

  export type CampaignCreateManySourceInputEnvelope = {
    data: CampaignCreateManySourceInput | CampaignCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithWhereUniqueWithoutSourceInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutSourceInput, CampaignUncheckedUpdateWithoutSourceInput>
    create: XOR<CampaignCreateWithoutSourceInput, CampaignUncheckedCreateWithoutSourceInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutSourceInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutSourceInput, CampaignUncheckedUpdateWithoutSourceInput>
  }

  export type CampaignUpdateManyWithWhereWithoutSourceInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutSourceInput>
  }

  export type LeadTagCreateWithoutTagInput = {
    Lead: LeadCreateNestedOneWithoutTagsInput
  }

  export type LeadTagUncheckedCreateWithoutTagInput = {
    leadId: string
  }

  export type LeadTagCreateOrConnectWithoutTagInput = {
    where: LeadTagWhereUniqueInput
    create: XOR<LeadTagCreateWithoutTagInput, LeadTagUncheckedCreateWithoutTagInput>
  }

  export type LeadTagCreateManyTagInputEnvelope = {
    data: LeadTagCreateManyTagInput | LeadTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type LeadTagUpsertWithWhereUniqueWithoutTagInput = {
    where: LeadTagWhereUniqueInput
    update: XOR<LeadTagUpdateWithoutTagInput, LeadTagUncheckedUpdateWithoutTagInput>
    create: XOR<LeadTagCreateWithoutTagInput, LeadTagUncheckedCreateWithoutTagInput>
  }

  export type LeadTagUpdateWithWhereUniqueWithoutTagInput = {
    where: LeadTagWhereUniqueInput
    data: XOR<LeadTagUpdateWithoutTagInput, LeadTagUncheckedUpdateWithoutTagInput>
  }

  export type LeadTagUpdateManyWithWhereWithoutTagInput = {
    where: LeadTagScalarWhereInput
    data: XOR<LeadTagUpdateManyMutationInput, LeadTagUncheckedUpdateManyWithoutTagInput>
  }

  export type LeadCreateWithoutTagsInput = {
    id?: string
    title: string
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignCreateNestedManyWithoutLeadInput
    Customer?: CustomerCreateNestedOneWithoutLeadsInput
    Broker?: UserCreateNestedOneWithoutLeadsInput
    Documents?: LeadDocumentCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataCreateNestedManyWithoutLeadInput
    Chats?: LeadChatCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleCreateNestedManyWithoutLeadInput
    Lane?: LaneCreateNestedOneWithoutLeadsInput
    LostedReason?: LeadLostReasonCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaigns?: LeadCampaignUncheckedCreateNestedManyWithoutLeadInput
    Documents?: LeadDocumentUncheckedCreateNestedManyWithoutLeadInput
    Comments?: LeadCommentUncheckedCreateNestedManyWithoutLeadInput
    Metadata?: LeadMetadataUncheckedCreateNestedManyWithoutLeadInput
    Chats?: LeadChatUncheckedCreateNestedManyWithoutLeadInput
    Schedules?: ScheduleUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutTagsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutTagsInput, LeadUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutLeadsInput = {
    id?: string
    name: string
    description: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    description: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutLeadsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutLeadsInput, TagUncheckedCreateWithoutLeadsInput>
  }

  export type LeadUpsertWithoutTagsInput = {
    update: XOR<LeadUpdateWithoutTagsInput, LeadUncheckedUpdateWithoutTagsInput>
    create: XOR<LeadCreateWithoutTagsInput, LeadUncheckedCreateWithoutTagsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutTagsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutTagsInput, LeadUncheckedUpdateWithoutTagsInput>
  }

  export type LeadUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type TagUpsertWithoutLeadsInput = {
    update: XOR<TagUpdateWithoutLeadsInput, TagUncheckedUpdateWithoutLeadsInput>
    create: XOR<TagCreateWithoutLeadsInput, TagUncheckedCreateWithoutLeadsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutLeadsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutLeadsInput, TagUncheckedUpdateWithoutLeadsInput>
  }

  export type TagUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConstructionCompanyCreateWithoutContactsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Projects?: ProjectCreateNestedManyWithoutConstructionCompanyInput
  }

  export type ConstructionCompanyUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Projects?: ProjectUncheckedCreateNestedManyWithoutConstructionCompanyInput
  }

  export type ConstructionCompanyCreateOrConnectWithoutContactsInput = {
    where: ConstructionCompanyWhereUniqueInput
    create: XOR<ConstructionCompanyCreateWithoutContactsInput, ConstructionCompanyUncheckedCreateWithoutContactsInput>
  }

  export type ConstructionCompanyUpsertWithoutContactsInput = {
    update: XOR<ConstructionCompanyUpdateWithoutContactsInput, ConstructionCompanyUncheckedUpdateWithoutContactsInput>
    create: XOR<ConstructionCompanyCreateWithoutContactsInput, ConstructionCompanyUncheckedCreateWithoutContactsInput>
    where?: ConstructionCompanyWhereInput
  }

  export type ConstructionCompanyUpdateToOneWithWhereWithoutContactsInput = {
    where?: ConstructionCompanyWhereInput
    data: XOR<ConstructionCompanyUpdateWithoutContactsInput, ConstructionCompanyUncheckedUpdateWithoutContactsInput>
  }

  export type ConstructionCompanyUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Projects?: ProjectUpdateManyWithoutConstructionCompanyNestedInput
  }

  export type ConstructionCompanyUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Projects?: ProjectUncheckedUpdateManyWithoutConstructionCompanyNestedInput
  }

  export type AccountCreateManyUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPermissionCreateManyUserInput = {
    permissionId: string
    createdAt?: Date | string
  }

  export type LeadCreateManyBrokerInput = {
    id?: string
    title: string
    customerId: string
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCommentCreateManyUserInput = {
    id?: string
    leadId: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadDocumentCreateManyUserInput = {
    leadId: string
    name: string
    path: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateManyUserInput = {
    id?: string
    leadId: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleParticipantCreateManyParticipantInput = {
    scheduleId: string
  }

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPermissionUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Permission?: PermissionUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserPermissionUncheckedUpdateWithoutUserInput = {
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPermissionUncheckedUpdateManyWithoutUserInput = {
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutBrokerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutBrokerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutBrokerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lead?: LeadUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type LeadCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadDocumentUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lead?: LeadUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type LeadDocumentUncheckedUpdateWithoutUserInput = {
    leadId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadDocumentUncheckedUpdateManyWithoutUserInput = {
    leadId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lead?: LeadUpdateOneRequiredWithoutSchedulesNestedInput
    Participants?: ScheduleParticipantUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Participants?: ScheduleParticipantUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleParticipantUpdateWithoutParticipantInput = {
    Schedule?: ScheduleUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ScheduleParticipantUncheckedUpdateWithoutParticipantInput = {
    scheduleId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleParticipantUncheckedUpdateManyWithoutParticipantInput = {
    scheduleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserPermissionCreateManyPermissionInput = {
    userId: string
    createdAt?: Date | string
  }

  export type UserPermissionUpdateWithoutPermissionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type UserPermissionUncheckedUpdateWithoutPermissionInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPermissionUncheckedUpdateManyWithoutPermissionInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyCustomerInput = {
    id?: string
    title: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleParticipantCreateManyScheduleInput = {
    userId: string
  }

  export type ScheduleParticipantUpdateWithoutScheduleInput = {
    Participant?: UserUpdateOneRequiredWithoutScheduleParticipatingNestedInput
  }

  export type ScheduleParticipantUncheckedUpdateWithoutScheduleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleParticipantUncheckedUpdateManyWithoutScheduleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCampaignCreateManyLeadInput = {
    campaignId: string
  }

  export type LeadTagCreateManyLeadInput = {
    tagId: string
  }

  export type LeadDocumentCreateManyLeadInput = {
    name: string
    path: string
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCommentCreateManyLeadInput = {
    id?: string
    userId: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadMetadataCreateManyLeadInput = {
    id?: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadChatCreateManyLeadInput = {
    conversationId: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateManyLeadInput = {
    id?: string
    userId: string
    date: Date | string
    address: string
    nextNotificationAt?: Date | string | null
    status?: $Enums.ScheduleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCampaignUpdateWithoutLeadInput = {
    Campaign?: CampaignUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadCampaignUncheckedUpdateWithoutLeadInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCampaignUncheckedUpdateManyWithoutLeadInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadTagUpdateWithoutLeadInput = {
    Tag?: TagUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadTagUncheckedUpdateWithoutLeadInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadTagUncheckedUpdateManyWithoutLeadInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadDocumentUpdateWithoutLeadInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutLeadDocumentsNestedInput
  }

  export type LeadDocumentUncheckedUpdateWithoutLeadInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadDocumentUncheckedUpdateManyWithoutLeadInput = {
    name?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCommentUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutLeadCommentsNestedInput
  }

  export type LeadCommentUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCommentUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadMetadataUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadMetadataUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadMetadataUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadChatUpdateWithoutLeadInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadChatUncheckedUpdateWithoutLeadInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadChatUncheckedUpdateManyWithoutLeadInput = {
    conversationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutSchedulesNestedInput
    Participants?: ScheduleParticipantUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Participants?: ScheduleParticipantUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    nextNotificationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyLostedReasonInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    laneId?: number
    value: number
    status?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateWithoutLostedReasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    Lane?: LaneUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutLostedReasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutLostedReasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    laneId?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyLaneInput = {
    id?: string
    title: string
    customerId: string
    userId?: string | null
    value: number
    status?: $Enums.LeadStatus
    lostedLeadReasonId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUpdateManyWithoutLeadNestedInput
    Customer?: CustomerUpdateOneWithoutLeadsNestedInput
    Broker?: UserUpdateOneWithoutLeadsNestedInput
    Tags?: LeadTagUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUpdateManyWithoutLeadNestedInput
    LostedReason?: LeadLostReasonUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: LeadCampaignUncheckedUpdateManyWithoutLeadNestedInput
    Tags?: LeadTagUncheckedUpdateManyWithoutLeadNestedInput
    Documents?: LeadDocumentUncheckedUpdateManyWithoutLeadNestedInput
    Comments?: LeadCommentUncheckedUpdateManyWithoutLeadNestedInput
    Metadata?: LeadMetadataUncheckedUpdateManyWithoutLeadNestedInput
    Chats?: LeadChatUncheckedUpdateManyWithoutLeadNestedInput
    Schedules?: ScheduleUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    lostedLeadReasonId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyConstructionCompanyInput = {
    id?: string
    title: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyConstructionCompanyInput = {
    id?: string
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutConstructionCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: CampaignUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutConstructionCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaigns?: CampaignUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutConstructionCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutConstructionCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateWithoutConstructionCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyWithoutConstructionCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyProjectInput = {
    id?: string
    title: string
    sourceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadCampaignUpdateManyWithoutCampaignNestedInput
    Source?: CampaignSourceUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCampaignCreateManyCampaignInput = {
    leadId: string
  }

  export type LeadCampaignUpdateWithoutCampaignInput = {
    Lead?: LeadUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type LeadCampaignUncheckedUpdateWithoutCampaignInput = {
    leadId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCampaignUncheckedUpdateManyWithoutCampaignInput = {
    leadId?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCreateManySourceInput = {
    id?: string
    title: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadCampaignUpdateManyWithoutCampaignNestedInput
    Project?: ProjectUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Leads?: LeadCampaignUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadTagCreateManyTagInput = {
    leadId: string
  }

  export type LeadTagUpdateWithoutTagInput = {
    Lead?: LeadUpdateOneRequiredWithoutTagsNestedInput
  }

  export type LeadTagUncheckedUpdateWithoutTagInput = {
    leadId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadTagUncheckedUpdateManyWithoutTagInput = {
    leadId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}